<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0' />
<title>IIH ALL+Glossary</title>
<link rel="stylesheet" href="style-iih.css">
</head>

<body>
<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>ВВЕДЕНИЕ</h2>
<p>УРОК Nº 1.</p>

<div id="notetran">
<h3>МИНИ-ВСТУПЛЕНИЕ ОТ ПЕРЕВОДЧИКА</h3>
<p>
		Признаться, я ни за что бы не начал изучать учебник который называется
		"HTML & CSS Is Hard".
		Но этот учебник в своем блоге порекомендовал Дерек Сиверс, один из удивительнейших
		известных мне людей.
</p><p>
		Я перечитал его на английском дважды.
		Читая в первый раз, я почти ничего не знал об Html&CSS.
		Тем не менее я быстро смог разобраться в базовых положениях.
		Проскочив несколько глав я прочитал как сделать адаптивный дизайн для смартфонов.
		Я тут же попробовал и... у меня получилось!!!
</p><p>
		Читая далее, с каждым разом я понимал все больше.
		Восхищала краткость и ясность подачи материала.
		Именно из-за этой ясности, легкодоступности, ну и из-за краткости тоже, я
		решил перевести этот учебник на русский язык.
		В процессе перевода я рассчитывал продвинуться на более глубокий
		уровень понимания языка разметки и стилей.
</p><p>
		Надеюсь, что читателю тоже понравится и пригодится этот учебник.
		Перевод сделан близко к тексту, но дословным переводом его назвать конечно
		же нельзя.<br>
		Предполагаю, что какой-никакой базовый английский у вас все-таки есть...
		а как иначе?
</p><p>
<small>
		Если ваш английский все-таки "хромает", одна из самых лучших лично мне известных
		методик изучения иностранных языков - speakasap.ru Елены Шипиловой.
		Может вам начать с бесплатного курса <a href="https://speakasap.com/en/seven/" target="_blank">
		Английский за 7 уроков</a>
</small>
</p><p>
		В некоторых местах текста я сделал "примечания переводчика" для русскоязычного
		читателя.
		Чтобы выделить отделить их от оригинального текста, примечания переводчика
		[заключены в квадратные скобки] или выделены знаком "*" как сноски.
</p><p>
		Если читатель обнаружит ошибки в терминологии, да и вообще любые опечатки или
		логические нестыковки, прошу сообщить об этом мне по мейлу <mark>sla@yarve.com</mark>.
</p></div>



<hr>

<h2>ВВЕДЕНИЕ в курс HTML & CSS IS HARD</h2>

<p>
		Изучать HTML&CSS нелегко?
		Нет, это стереотип.
		Данный учебник, состоящий из 14 глав, является одним из самых легкопонятных
		руководств по HTML и CSS в Интернете.
		В нем рассказано обо всем, начиная с выбора хорошего текстового редактора
		(что на удивление важно) и заканчивая созданием полноценных веб-страниц
		профессионального качества. И все это "с нуля".
</p>

<figure><img class="pic-pages" src="./images/iih01-intro-01-becoming-a-web-developer-0530f1.3b5388b5.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption>
		Скриншот 1: программист, создающий веб-страницы
</figcaption>
</figure>

<p>
		Данный курс задуман как учебник HTML и CSS, включающий ВСЁ, что необходимо
		знать на эту тему.
		Если вы приложите усилия для изучения каждого урока, собственноручно напишите
		все приведенные фрагменты кода, то этот учебник заменит вам онлайн-курсы и
		тренинги стоимостью в сотни и даже тысячи долларов.
</p><p>
		Главная цель данного учебника - максимально упростить ваше превращение из
		новичка в профессионала веб-разработки.
		Если вы никогда не писали кода, но подумываете о смене профессии, сварите
		себе чашечку кофе и присаживайтесь поудобнее.
		Мы начинаем.
</p>

<div class="title">HTML, CSS, & JAVASCRIPT</div>
<p>
		Язык гипертекстовой разметки (HTML), каскадные таблицы стилей (CSS) и JavaScript
		- это языки, на которых работает Интернет.
		Они очень тесно связаны между собой, но при этом предназначены для решения
		совершенно разных задач.
		Понимание их взаимодействия между собой, поможет вам стать
		веб-разработчиком.
		Мы будем раскрывать эту тему на протяжении всего курса, но суть ее такова:
</p>
<ul>
<li>HTML придает смысл исходному контенту* через разметку.</li>
<li>CSS форматирует размеченный контент.</li>
<li>JavaScript делает интерактивным контент и форматирование.</li>
</ul>
<p>
		Другими словами, HTML это абстрактный текст и изображения, лежащие в основе
		веб-страницы.<br>
		CSS это отображение страницы на экране.<br>
		JavaScript это элементы поведения, которые могут управлять как HTML, так и CSS.
</p><p class="notetran">
		* - content означает содержимое. Переводы других терминов <a href="/iih-gloss.html">
		ЗДЕСЬ</a>.
</p>

<figure><img class="pic-pages" src="./images/iih01-intro-02-html-css-javascript-905348.7c291929.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
		Скриншот 2: HTML как древо узлов, CSS как отрисованная веб-страница,
		JavaScript как интерактивная веб-страница
</figcaption>
</figure>

<p>
		Например, с помощью этого HTML можно выделить определенный фрагмент текста
		как абзац:
</p><p class="code">
&lt;p id='some-paragraph'&gt;Здесь помещается содержимое абзаца.&lt;/p&gt;

</p><p>
		Затем с помощью CSS можно задать размер и цвет этого абзаца:
</p><p class="code">
<span class="code-strong">p</span> {<br>
<span class="code-green">font-size</span>: 20px;<br>
<span class="code-green">color</span>: blue;<br>
}
</p><p>
		И если вы вошли во вкус, с помощью JavaScript можно сделать так, что после
		щелчка мышью, текст полностью поменяется!
		Первоначальный текст: "Здесь помещается содержимое абзаца" после щелчка мышью
		поменяется на 'Текст который "щелкнули"' (однако язык JavaScript мы оставим
		для будущих учебников.)
</p><p class="code">
<span class="code-strong">var</span> p = document.getElementById('some-paragraph');<br>
p.addEventListener('click', <span class="code-strong">function</span>(event) {<br>
p.innerHTML = 'Текст который щелкнули.';<br>
});
</p><p>
		Как видите, HTML, CSS и JavaScript - это совершенно разные языки, но все они
		так или иначе связаны друг с другом.
		Большинство веб-сайтов используют все три языка, но внешний вид каждого сайта
		определяется HTML и CSS.
		Это делает данный учебник отличной отправной точкой в вашем путешествии по
		веб-разработке.
</p><p>

<div class="title">ЯЗЫКИ И "ВЕБ-РАЗРАБОТКА"<br>languages versus “web development”
</div>
<p>
		К сожалению, владение HTML, CSS и JavaScript - это лишь необходимое условие
		для того, чтобы стать профессиональным веб-разработчиком.
		Существует целый ряд других практических навыков, необходимых для работы с
		сайтом:
</p>
<ul>
<li>Объединение HTML в шаблоны многократного использования</li>
<li>Подготовка веб-сервера к работе</li>
<li>Перенос файлов с локального ПК на веб-сервер</li>
<li>Возврат к предыдущей версии при обнаружении "багов"</li>
<li>Создание и настройка доменного имени вашего сервера</li>
</ul>
<p>
		Для решения этих довольно сложных задач необходимо настроить различные
		"среды" [environments] для организации файлов и сборки/развертывания сайта.
		Это не связано с кодом HTML, CSS и JavaScript, из которого состоит сайт.
		Данные процессы выходят за рамки нашего курса.
		Основное внимание уделяется языкам HTML и CSS, а не настройке этих "сред".
</p>

<figure><img class="pic-pages" src="./images/iih01-intro-03-languages-vs-web-dev-b849db.a1ad228a.png"
width="70%" alt="Interneting is hard HTML+CSS 3">
<figcaption>
		Скриншот 3: HTML, CSS и JavaScript, указывающие на создание веб-сайта
		(инструменты сборки, доменное имя, веб-сервер), в результате чего создается
		веб-сайт
</figcaption>
</figure>

<p>
		Однако сейчас нет необходимости забивать голову этими процессами.
		Сейчас ваша цель - свободное владение HTML и CSS.
		Это важный первый шаг к тому, чтобы стать настоящим веб-разработчиком.
		Нам не хотелось бы создать иллюзию, что после изучения этого учебника
		вы сходу сможете самостоятельно создать полноценный сайт.
		Однако у вас будут навыки, позволяющие воссоздать подавляющее большинство
		сайтов в Интернете.
</p>

<div class="title">ВЕБ-ПУБЛИКАЦИЯ<br>web publishing</div>
<p>
		Итак, что же нужно для того, чтобы "выучить" HTML и CSS?
		Давайте посмотрим через призму истории полиграфии.
		Еще во времена первых печатных станков печатники создавали документы, располагая
		металлические бруски (типографские литеры), обмакивая их в краску и делая оттиск на лист бумаги.
</p><p>
		Почти то же самое делают сегодня веб-разработчики.
		Только вместо расставления типографских литер, они пишут HTML и CSS.
		Происходит тот же процесс, что и ранее: передача содержания в осмысленном виде.
		Даже задачи остаются те же: выбор шрифта, установка размера заголовков,
		определение расстояния между строками текста.
</p>

<figure>
<img class="pic-pages" src="./images/iih01-intro-04-web-publishing-cd96b2.87351deb.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
		Скриншот 4: металлический штамп становится HTML и CSS, печатная страница
		становится веб-страницей, книга - веб-сайтом
</figcaption>
</figure>

<p>
		Раньше в типографии печаталась пачка страниц и скреплялась в книгу.
		Сегодня мы создаем множество HTML-файлов и соединяем их в веб-сайт.
		Изучение HTML и CSS сводится к пониманию доступной разметки HTML и правил CSS,
		позволяющих браузеру отображать эти файлы так, как задумано.
</p>

<div class="title">ФУНДАМЕНТАЛЬНЫЕ ОСНОВЫ <br>ВМЕСТО ФРЕЙМВОРКОВ<br>
fundamentals, not frameworks</div>
<p>
		Существует множество фреймворков для разработки сайтов (<a href="http://getbootstrap.com/">
		Bootstrap</a>, <a href="http://foundation.zurb.com/">ZURB foundation</a>,
		<a href="http://purecss.io/">Pure CSS</a> и др.).
		Цель каждого из них - абстрагироваться от излишеств, связанных с созданием
		веб-страниц с нуля. Подобные фреймворки являются важной частью реальной
		веб-разработки, и их обязательно стоит изучить, но только после того, как вы
		освоите <a href="/">основы HTML и CSS</a>.
</p><p>
		Данный учебник посвящен основам HTML и CSS.
		Вы сможете создать практически все, что может понадобиться вам как веб-разработчику,
		используя только HTML и CSS.
		Это знание останется с вами навсегда, несмотря на новые блестящие дополнения
		к стандартам HTML и CSS или новомодные фреймворки, помогающие работать быстрее.
</p>

<div class="title">ПРАКТИЧЕСКОЕ ОБУЧЕНИЕ<br>hands-on learning</div>
<p>
		Данный учебник - это обучение основанное на практике.
		За исключением того, что вы уже прочитали, весь этот учебник выстроен на
		конкретных примерах, попутно объясняя концептуальные аспекты HTML и CSS.
</p><p>
		Чтобы получить максимальную пользу от этого курса, необходимо активно создавать
		веб-страницы и выполнять все шаги каждой главы.
		Если вы всерьез намерены стать веб-разработчиком, то вам следует набирать
		каждый фрагмент кода "ручками", а не копипастить Сtrl+V.
</p><p>
		Почему?
		Потому что именно это вы будете делать в качестве настоящего веб-разработчика.
		"Ручной" ввод примеров кода способствует развитию моторной памяти, которая
		пригодится вам в реальной работе по разметке контента для реальных сайтов.
</p>

<div class="title">ПРОФЕССИОНАЛЬНЫЕ ИНСТРУМЕНТЫ<br>tools of the trade</div>
<p>
		Для этого курса достаточно иметь удобный текстовый редактор и веб-браузер.
		Основная работа заключается в том, чтобы написать код в текстовом редакторе,
		а затем открыть его в браузере и посмотреть, как он выглядит.
		По мере создания собственных сайтов вы будете добавлять в свой инструментарий
		все новые и новые инструменты, но важно начать с минимума и досконально
		изучить основы HTML и CSS.
</p>

<figure>
<img class="pic-pages" src="./images/iih01-intro-05-tools-of-the-trade-649a9a.f6744354.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
		Скриншот 5: текстовый редактор (здесь пишут код) и веб-браузер
		(здесь код отображается)
</figcaption>
</figure>

<p>
		Не пожалейте времени на то, чтобы освоить работу с текстовым редактором.
		Хорошие редакторы оснащены функциями (автозавершение тегов, переход по тексту,
		навигация по файловой системе и т.п.), позволяющими писать код быстрее обычного.
		Мастерское владение текстовым редактором это часть изучения HTML и CSS.
</p><p>
		Единственным и самым важным требованием для хорошего браузера является его
		актуальность и широкое распространение.
<a href="https://www.google.com/chrome/browser/desktop/">
		Chrome</a> и <a href="https://www.mozilla.org/en-US/firefox/new/">Firefox</a>
		- фавориты среди веб-разработчиков.
		Safari тоже подойдет, если вы работаете в OS X.
		Настоятельно рекомендуем при создании сайтов <em>отказаться от</em> Internet Explorer.
		Для профессиональной веб-разработки часто требуется эффективный способ
		тестирования кода на всех этих браузерах.
		Но изучением темы тестирования кода займемся в другой раз.
		Сейчас в этом нет критической необходимости.
</p>

<div class="title" id="atom">ТЕКСТОВЫЙ РЕДАКТОР ATOM<br>atom text editor</div>
<p>
		Мы рекомендуем текстовый редактор <a href="https://github.com/atom/atom/releases/tag/v1.60.0">
		Atom</a>.
		Он удобен даже для начинающих пользователей,
		обладает всеми полезными функциями, о которых мы говорили выше, и доступен для
		всех основных операционных систем.
		Кроме того, его можно бесконечно настраивать, что будет важно по мере выявления
		повторяющихся задач, которые можно автоматизировать.
</p><p>
		Если у вас еще нет Atom, <a href="https://github.com/atom/atom/releases/tag/v1.60.0">
		загрузите его прямо сейчас</a>, поскольку он понадобится вам на следующем уроке.
		После загрузки откройте его, чтобы мы могли вкратце ознакомиться с его основными
		возможностями.
		Вы должны увидеть две панели с различными окнами приветствия:
</p>

<figure>
<img class="pic-pages" src="./images/iih01-intro-06-atom-welcome-screen-a59275.4180ffb5.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
		Скриншот 6: приветственное окно текстового редактора Atom
</figcaption>
</figure>

<p>
		Оба эти экрана приветствия нам не нужны.
		Закройте их, щелкнув на значок X в соответствующих вкладках.
		Для их закрытия можно также воспользоваться сочетанием клавиш <strong>Cmd+W (Mac)</strong>
		или <strong>Ctrl+W</strong> (Windows/Linux)<br>
		(сочетания клавиш - отличная вещь, пользуйтесь ими при любой возможности).
		У вас должна остаться одна <strong>вкладка без названия</strong>.
</p>

<div class="title">СОЗДАНИЕ ПРОЕКТА<br>creating a project</div>
<p>
		Каждый сайт, над которым вы работаете в Atom, представляет собой "проект".
		По сути, это просто папка в вашей файловой системе, содержащая HTML- и CSS-файлы.
		Давайте познакомимся с Atom, создав фиктивный проект и добавив в него несколько
		текстовых файлов.
		Нажмите <strong>File > Open</strong> в строке меню, чтобы открыть диалоговое
		окно файла, затем создайте новую папку, выбрав <strong>New Folder</strong>.
		Назовите ее hello-atom и щелкните <strong>Open</strong>.
</p>

<figure>
<img class="pic-pages" src="./images/iih01-intro-07-file-browser-051ac0.207cd074.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
		Скриншот 7: устройство редактора Atom: в левой боковой панели - файловый браузер,
		справа - рабочая панель (здесь пишем и редактируем код)
</figcaption>
</figure>

<p>
		В левой части интерфейса должна появиться боковая панель с надписью
		hello-atom вверху рядом с маленьким значком папки.
		Это и есть наш файловый браузер.
		Конечно, он ничего не покажет, пока мы не добавим туда файлы, так что
		давайте это и сделаем.
</p>

<div class="title">СОЗДАНИЕ ФАЙЛОВ<br>creating files</div>
<p>
		Добавьте на <strong>вкладку без названия</strong> произвольный текст.
		Сохраните изменения нажав <strong>Cmd+S</strong> (Mac)
		или <strong>Ctrl+S</strong> (Windows, Linux).
		Назовите файл page-one.html.
		После этого вы должны увидеть его в браузере файлов Atom.
</p><p>
		Создадим еще один файл, нажав <strong>Cmd+N</strong> (Mac) или <strong>
		Ctrl+N</strong> (Windows, Linux).
		Это создаст еще одну <strong>вкладку без названия</strong>.
		Как и в предыдущем файле, добавьте любой текст и сохраните его под именем
		page-two.html.
</p>

<div class="title">НАВИГАЦИЯ ПО ФАЙЛОВОЙ СИСТЕМЕ<br>navigating the file system</div>
<p>
		Один из важнейших аспектов полноценного редактора - удобная навигация по всем
		файлам проекта.
		В Atom вы можете выбрать вкладку файла, с которым хотите работать, или найти
		его в браузере файлов в левой части интерфейса.
		Переходить по открытым вкладками можно также с помощью <strong>
		Ctrl+Tab</strong>.
</p>

<img class="pic-pages" src="./images/iih01-intro-08-creating-html-files-7489ae.8ff7e31f.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption>
		Скриншот 8: файловый браузер Atom после создания нескольких HTML-файлов
</figcaption>
</figure>

<p>
		Все это хорошо и удобно для <em>просмотра</em> файлов, но зачастую возникает
		необходимость <em>поиска</em> конкретного файла.
		Например, во время проверки работоспособности, вы обнаружили неработающую
		ссылку на своем сайте.
		Вы хотели бы с помощью Atom мгновенно "прыгнуть" в этот файл, чтобы быстро
		исправить сломанную ссылку?
</p>

<figure>
<img class="pic-pages" src="./images/iih01-intro-09-atom-command-t-2fbe5e.2f7aeabb.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
		Скриншот 9: результаты поиска в Atom’s fuzzy finder,
</figcaption>
</figure>

<p>
		Вам поможет так называемый Atom’s fuzzy finder.
		Это строка поиска, вызваемая комбинацией <strong>Cmd+T</strong> (Mac) или <strong>
		Ctrl+T</strong> (Windows, Linux).
		Эта комбинация клавиш открывает строку поиска и позволяет ввод имени (или
		части имени) искомого файла.
		Попробуйте закрыть обе вкладки, нажать <strong>Cmd+T</strong> или <strong>
		Ctrl+T</strong> и ввести "<strong>one</strong>".
		На экране появится файл page-one.html, и вы сможете нажать <strong>Enter</strong>
		для редактирования этого файла.
		Данная опция бесценна, когда проект разрастается до десятков файлов в разных папках.
</p>

<div class="title">ДОПОЛНИТЕЛЬНЫЕ ПАНЕЛИ<br>multiple panes</div>
<p>
		Atom позволяет иметь не только несколько вкладок, но и несколько панелей.
		Чтобы понять, о чем идет речь, щелкните правой кнопкой мыши на один
		из файлов в браузере файлов и выберите команду <strong>Split Right</strong>.
		Файл откроется в новой панели, что позволит просматривать несколько файлов одновременно.
</p>

<figure>
<img class="pic-pages" src="./images/iih01-intro-10-atom-split-panes-515aba.50ae933c.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
		Скриншот 10: две панели [pane] редактора Atom, расположенные рядом друг с другом
</figcaption>
</figure>

<p>
		Дополнительные панели очень удобны для одновременного просмотра CSS-файла
		и связанного с ним HTML-файла.
</p>

<div class="title">ЗА ПРЕДЕЛАМИ РЕДАКТОРА ATOM<br>outside of atom</div>
<p>
		Иногда требуется работать с файлами "за пределами" редактора Atom
		(например, для добавления картинки на наш сайт).
		Для этого воспользуйтесь встроенным файловым браузером.
		Щелкните правой кнопкой мыши на файл в браузере файлов Atom и выберите
<strong>
		Show in Finder/File Manager/Explorer</strong> ...
		Это позволит открыть данный файл в Проводнике или в другом файловом браузере,
		открывающимся в вашем компьютере по умолчанию.
</p><p>
		Отсюда вы можете добавлять новые файлы, создавать папки или открывать HTML-файлы
		в веб-браузере.
		Это станет обычной процедурой до конца всего курса, поэтому давайте попробуем
		это сделать с файлом page-one.html.
		Щелкните его правой кнопкой мыши в стандартном файловом браузере вашей системы
		и выберите <strong>Open With > Chrome/Firefox/Safari</strong>.
		Текст в файле, должен отобразиться в виде веб-страницы в вашем стандартном
		веб-браузере.
</p>

<figure>
<img class="pic-pages" src="./images/iih01-intro-11-web-dev-workflow-1faddb.8b895f23.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
		Скриншот 11: EDIT HERE - редактируем код в редакторе Атом, RELOAD HERE -
		перезагружаем браузер и просматриваем изменения
</figcaption>
</figure>

<p>
		Теперь можно редактировать страницу page-one.html в Atom,
		сохранять изменения и просматривать в браузере.
		Для обновления окна браузера нажмите <strong>Cmd+R</strong> (Mac)
		или <strong>Ctrl+R</strong> (Windows, Linux).
		Это и есть базовый процесс редактирования для всех веб-разработчиков,
		и вы очень быстро привыкнете к нему задолго до конца изучения последующих
		13 уроков.
</p>

<div class="title">РЕЗЮМЕ</div>
<p>
		Поздравляем!
		Вы сделали первый шаг к тому, чтобы стать профессиональным веб-разработчиком.
		Надеемся, что эта глава дала вам базовое понимание того, как HTML и CSS используются
		в сфере веб-разработки, а также общей философии нашего учебника.
</p><p>
		Все вышесказанное об Atom станет частью нашей повседневной работы.
		Поэтому прежде чем двигаться дальше, убедитесь, что вам все понятно.
		Мы рекомендуем немного поиграть с нашим фиктивным проектом, добавляя новые
		файлы и тренируясь в переходах от одного файла к другому.
		Овладение навыками написания HTML и CSS - это то, что отличает невероятно
		продуктивных разработчиков от обычных.
</p><p>
		Теперь, когда у нас есть полноценный текстовый редактор, мы готовы приступить
		к созданию полноценных веб-страниц.
		В следующих двух главах мы начнем с изучения наиболее распространенных
		элементов HTML, а затем добавим к ним CSS.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>ЧТО НУЖНО ЗНАТЬ О ВЕБСТРАНИЦАХ</h2>
<p>УРОК Nº 2.</p>
<p><em>
    Простое и понятное руководство по созданию (по-настоящему) простых веб-страниц
</em></p>

<p>
    HTML определяет содержание каждой веб-страницы в Интернете.
		Разметив исходное содержимое с помощью HTML-тегов, можно указать веб-браузерам,
		как следует отображать различные части содержимого.
		Создание HTML-документа с правильно размеченным содержимым - это первый шаг
		в разработке веб-страницы.
</p>

<figure><img class="pic-pages" src="./images/iih02-01-html-markup-0761f7.562e8e23.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 1: исходное содержимое (контент) становится HTML-кодом, затем веб-страницей
</figcaption>
</figure>

<p>
	  В этой главе мы создадим нашу первую веб-страницу.
		На ней не будет ни одного CSS, поэтому выглядеть она будет как полная хрень.
		Зато она послужит основательным введением в элементы HTML, с которыми
		веб-разработчики работают каждый день.
</p><p>
    При работе с примерами старайтесь подходить к ним как к более практичной версии
<a href="https://ru.wikipedia.org/wiki/WYSIWYG" target="_blank">
	  WYSIWYG-редактора</a>, например Google Docs или Microsoft Word.
		Мы будем работать со всеми теми же типами контента (заголовки, абзацы, списки
		и т.д.), просто мы будем определять их немного более наглядно с помощью HTML.
</p>

<div class="title">подготовка<br>setup</div>
<p>
    Для начала создадим в Atom новый проект с именем basic-web-pages.
		Затем создадим в этой папке новый файл basics.html.
		Этот HTML-файл представляет собой одну веб-страницу, и именно в него мы
		поместим весь наш код для этой главы.
		Если вы еще не знакомы с Atom, обязательно прочитайте <a href="file:///Users/yarve/SynologyDrive/-FTP/yarve/iih-intro.html">
		Введение</a> к этой серии уроков.
</p>

<figure>
<img class="pic-pages" src="./images/iih01-intro-11-web-dev-workflow-1faddb.8b895f23.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 2: EDIT HERE - редактируем в редакторе Атом, просматриваем изменения в браузере
</figcaption>
</figure>

<p>
    Напоминаем, что рабочий процесс веб-разработчиков - большей частью редактирование
		HTML в текстовом редакторе и просмотр изменений в веб-браузере.
		Именно это вы должны делать для каждой секции этого урока.
</p>

<div class="title">СТРУКТУРА ВЕБ-СТРАНИЦЫ<br>structure of a web page</div>
<p>
    Добавьте в наш файл basics.html показанную ниже HTML-разметку.
		Это то, с чего вы будете начинать каждую свою веб-страницу.
		Обычно для того, чтобы избежать повторного ввода лишних частей, используется
		какой-либо шаблонизатор, но в данном учебном пособии мы сосредоточимся на
		исходном HTML.
</p><p class="code">
<span class="code-green">&lt;!DOCTYPE html&gt;</span><br>
<span class="code-blue">&lt;html&gt;</span><br>
<span class="code-blue">&lt;head&gt;</span><br>
<span class="code-grey">
	    &lt;!-- Метаданные будут здесь --&gt;
</span><br>
<span class="code-blue">&lt;/head&gt;</span><br>
<span class="code-blue">&lt;body&gt;</span><br>
<span class="code-grey">
	    &lt;!-- Содержание (content) будет здесь --&gt;
</span><br>
<span class="code-blue">&lt;/body&gt;</span><br>
<span class="code-blue">&lt;/html&gt;</span>
</p><p>
    Прежде всего, с помощью строки &lt;!DOCTYPE html&gt;, необходимо указать
		браузерам, что это веб-страница HTML5.
		Это специальная строка, которую браузеры ищут при попытке отобразить нашу
		веб-страницу, и она всегда должна выглядеть в точности так, как показано выше.
</p><p>
    Затем вся наша веб-страница должна быть обернута в теги &lt;html&gt;.
		Сам текст &lt;html&gt; называется "открывающим тегом" [opening tag], а &lt;/html&gt; -
		"закрывающим тегом" [closing tag].
		Все, что находится внутри этих тегов, считается частью "элемента" &lt;html&gt;,
		то есть той невидимой части, которая создается, когда веб-браузер анализирует
		ваши HTML-теги.
</p>

<figure>
<img class="pic-pages" src="./images/iih02-02-html-tags-elements-72813b.d8a695f9.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 3: элемент HTML, состоящий из открывающего и закрывающего тегов
</figcaption>
</figure>

<p>
    Внутри элемента &lt;html&gt; есть еще два элемента, называемые &lt;head&gt;
		и &lt;body&gt;.
		В головном элементе веб-страницы содержатся все метаданные, такие как заголовок
		страницы [page title], таблицы стилей CSS [CSS stylesheets] и другие элементы,
		необходимые для отображения страницы, но которые пользователю видеть
		совсем не обязательно.
		Основная часть нашей HTML-разметки будет находиться в элементе &lt;body&gt;,
		который представляет собой видимое содержимое страницы.
		Обратите внимание, что при открытии нашей страницы в браузере ничего не
		отобразится, поскольку она имеет пустой &lt;body&gt;.
</p>

<figure>
<img class="pic-pages" src="./images/iih02-03-html-head-body-7c2a73.dcf01064.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 4: веб-страница, разделенная на элементы &lt;head&gt; и &lt;body&gt;
</figcaption>
</figure>

<p>
    Назначение этого разделения &lt;head&gt;/&lt;body&gt; станет более понятным
		через несколько уроков, когда мы начнем работать с CSS.
</p><p>
    Обратите также внимание на синтаксис HTML-комментария в приведенном выше фрагменте.
		Все, что начинается с &lt;!-- и заканчивается на --&gt;, будет полностью
		проигнорировано браузером. Это удобно для работы над документированием кода
		и создания заметок "для себя". Эти заметки пользователь не увидит.
</p>

<div class="title">ЗАГОЛОВКИ ДОКУМЕНТА<br>page titles</div>
 <p>
    Одной из наиболее важных частей метаданных является заголовок документа.
		Он задается HTML-элементом &lt;title&gt;.
		Браузеры отображают этот элемент на самом верху страницы - а именно на вкладке
		(см. скриншот ниже).
		Также заголовок документа отображается в результатах поиска
		[в Гугл и др. поисковиках].
</p><p>
    Попробуйте обновить &lt;head&gt; нашего файла basic.html следующим образом:
</p><p class="code">
	&lt;!DOCTYPE html&gt;<br>
	&lt;html&gt;<br>
	&lt;head&gt;<br>
	&lt;title&gt;Interneting Is Easy! &lt;/title&gt;<br>
	&lt;/head&gt;<br>
	&lt;body&gt;<br>
	<span class="code-grey">
			&lt;!-- Содержание (content) будет здесь --&gt;
	</span><br>
		&lt;/body&gt;<br>
	&lt;/html&gt;
</p><p>
    При перезагрузке страницы в браузере должна появиться пустая страница,
		но при этом во вкладке браузера будет отображаться надпись <strong>
		Interneting Is Easy!</strong>
</p>

<figure>
<img class="pic-pages" src="./images/iih02-04-html-title-element-f4eb85.764db0a6.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 5: Веб-страница с элементом &lt;title&gt;, отображаемым на вкладке браузера
</figcaption>
</figure>

<p>
    Обратите внимание, как аккуратно вложены все HTML-теги в нашей веб-странице.
		Очень важно следить за тем, чтобы не было пересекающихся элементов.
		Например, элемент &lt;title&gt; должен находиться внутри &lt;head&gt;,
		поэтому ни в коем случае нельзя добавлять закрывающий тег &lt;/head&gt; перед
		закрывающим тегом &lt;/title&gt;:
</p><p class="code">
<span class="code-grey">
&lt;!-- (Никогда не делайте так!) --&gt;
</span><br>
	&lt;head&gt;<br>
	  &lt;title&gt;Interneting Is Easy!&lt;/head&gt;<br>
	&lt;/title&gt;
</p>

<div class="title">абзацы<br>paragraphs</div>
 <p>
    Заголовки - это, конечно, хорошо, но давайте сделаем что-то, что можно
		реально увидеть воочию.
		Элемент &lt;p&gt; выделяет весь текст внутри себя как отдельный абзац.
		Добавьте следующий элемент &lt;p&gt; в тело нашей веб-страницы:
</p><p class="code">
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
	&lt;head&gt;<br>
	  &lt;title&gt;Interneting Is Easy! &lt;/title&gt;<br>
	&lt;/head&gt;<br>
	&lt;body&gt;<br>
	  &lt;p&gt;First, we need to learn some basic HTML.&lt;/p&gt;<br>
		&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    На странице должно появиться некоторое содержимое.
		Опять же, поскольку это содержимое, которое мы хотим отобразить, оно должно
		быть помещено в элемент &lt;body&gt;, а не в &lt;head&gt;.
</p>

<figure>
<img class="pic-pages" src="./images/iih02-05-html-paragraph-element-842f23.20597f96.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 6: Веб-страница, показывающая элемент &lt;p&gt; с неким содержимым
</figcaption>
</figure>

<p>
    Обратите внимание, что элементы &lt;p&gt; и &lt;title&gt; имеют двойной
		indent-отступ*, а &lt;body&gt; и &lt;head&gt; - одинарный.
		Подобные отступы для вложенных элементов - наилучшая практика.
		Это делает ваш HTML более удобным для чтения другими разработчиками (или для
		вас лично, если вы вернетесь через 5 месяцев и захотите что-то изменить).
</p><p>
    Вы и ваша команда разработчиков сами решаете, использовать ли для отступов
		пробелы или символы табуляции.
		Вы можете установить это предпочтение в своем текстовом редакторе в разделе
<strong>
		Atom > Preferences > Editor</strong> и прокрутить вниз до параметра
<strong>
	  Tab Type.</strong>
</p><p class="notetran">
    * - по техническим причинам, в русскоязычном переводе данного учебника
		indent-отступы отсутствуют.
</p>

<div class="title" id="headings">заголовки секций<br>headings</div>
<p>
    Заголовок секции &lt;h1&gt; похож на заголовок документа &lt;title&gt;.
		Но в отличие от заголовков документов, заголовки h1...h6 фактически
		отображаются на странице.
		В HTML предусмотрено шесть уровней заголовков.
		Это &lt;h1&gt;, &lt;h2&gt;,&lt;h3&gt;, ... , &lt;h6&gt;.
		Чем выше номер, тем менее значимым является заголовок.
</p><p>
    Первым заголовком на странице, как правило, должен быть &lt;h1&gt;, поэтому
		давайте вставим его над существующим элементом &lt;p&gt;.
		Очень часто первый элемент &lt;h1&gt; совпадает с &lt;title&gt; документа,
		как это сделано здесь:
</p><p class="code">
&lt;body&gt;<br>
&lt;h1&gt;Interneting Is Easy! &lt;/h1&gt;<br>
&lt;p&gt;First, we need to learn some basic HTML.&lt;/p&gt;<br>
&lt;/body&gt;
</p><p>
    По умолчанию браузеры отображают менее важные заголовки меньшим шрифтом.
		Для примера включим заголовок второго уровня и посмотрим, что получится:
</p><p class="code">
	&lt;!DOCTYPE html&gt;<br>
	&lt;html&gt;<br>
		&lt;head&gt;<br>
		  &lt;title&gt;Interneting Is Easy! &lt;/title&gt;<br>
		&lt;/head&gt;<br>
		&lt;body&gt;<br>
&lt;h1&gt;Interneting Is Easy! &lt;/h1&gt;<br>
&lt;p&gt;First, we need to learn some basic HTML.&lt;/p&gt;<br>
<br>
&lt;h2&gt;Headings&lt;/h2&gt;<br>
&lt;p&gt;Headings define the outline of your site.
There are 6 levels of headings.&lt;/p&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    В результате веб-страница будет выглядеть примерно так:
</p>

<figure>
<img class="pic-pages" src="./images/iih02-06-html-heading-elements-f7fe6a.2b91d981.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 7: Веб-страница с бОльшим элементом &lt;h1&gt; и меньшим элементом &lt;h2&gt;
</figcaption>
</figure>

<p>
    Заголовки секций - это основной способ обозначения различных компонентов содержимого.
		Элементы заголовков секций  определяют контур веб-страницы, как ее видят люди
		и поисковые системы.
		Поэтому выбор подходящих заголовков очень важен для создания качественной
		веб-страницы.
</p>

<div class="title">неупорядоченные списки<br>unordered lists</div>
 <p>
    Всякий раз, заключая какой-либо текст в HTML-теги, мы придаем ему новый смысл.
		"Обертывание" содержимого в теги &lt;ul&gt; сообщает браузеру, что все, что
		находится внутри, должно отображаться как "неупорядоченный список".
		Чтобы обозначить отдельные элементы этого списка, нужно обернуть каждый из
		этих элементов тегами &lt;li&gt;, например, так:
</p><p class="code">
&lt;h2&gt; Lists &lt;/h2&gt;<br>
<br>
&lt;p&gt;This is how you make an unordered list:&lt;/p&gt;<br>
<br>
&lt;ul&gt;<br>
&lt;li&gt;Add a "ul" element (it stands for unordered list)&lt;/li&gt;<br>
&lt;li&gt;Add each item in its own "li" element&lt;/li&gt;<br>
&lt;li&gt;They don't need to be in any particular order&lt;/li&gt;<br>
&lt;/ul&gt;
</p><p>
    После добавления этой разметки в элемент &lt;body&gt; (под существующим
		содержимым) должен появиться маркированный список с отдельным маркером в
		виде круга (bullet) для каждого элемента &lt;li&gt;:
</p>

<figure>
<img class="pic-pages" src="./images/iih02-07-html-unordered-lists-f45526.11fc3b9f.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 8: веб-страница, на которой показан элемент &lt;ul&gt; с
		элементами &lt;li&gt; внутри него
</figcaption>
</figure>

<p>

<!-- <p class="notetran">
    This is how you make an unordered list: - Так создается неупорядоченный список:
<br>
    Add a "ul" element (it stands for unordered list) -
		Добавляем элемент "ul" (он обозначает неупорядоченный список)
<br>
    Add each item in its own "li" element -
		Добавляем каждый элемент списка как отдельный элемент "li"
<br>
    They don't need to be in any particular order -
		Порядок расположения элементов не играет роли
</p> -->


	<p>
    Спецификация HTML определяет строгие правила относительно того, какие элементы
		могут находиться внутри других элементов.
		В данном случае элементы &lt;ul&gt; должны содержать только элементы &lt;li&gt;.
		Это означает, что вы никогда не должны писать что-то подобное:
</p><p class="code">
<span class="code-grey">
&lt;!-- Никогда не делайте так! --&gt;
</span><br>
&lt;ul&gt;<br>
&lt;p&gt;Add a "ul" element (it stands for unordered list)&lt;/p&gt;<br>
&lt;/ul&gt;
</p><p>
	  Вместо этого следует обернуть этот абзац тегами &lt;li&gt;:
</p><p class="code">
<span class="code-grey">
&lt;!-- Вместо этого сделайте вот это --&gt;
</span><br>
	&lt;ul&gt;<br>
&lt;li&gt;&lt;p&gt;Add a "ul" element (it stands for unordered list)&lt;/p&gt;&lt;/li&gt;<br>
	&lt;/ul&gt;
</p><p>
    А откуда мы знаем, что &lt;ul&gt; принимает только элементы &lt;li&gt; и
		что &lt;li&gt; допускает вложенные абзацы?
		Потому что так утверждает <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element">
		Mozilla Developer Network</a> (MDN).
		MDN - это превосходный справочник по элементам HTML.
		В этом учебнике мы постараемся рассказать как можно больше о том, как использовать
		основные элементы HTML, но если вы не уверены в каком-либо элементе,
		введите в Google* такой запрос <strong>"MDN &lt;некий элемент&gt;"</strong>.

</p><p class="notetran">
    * - Если желаете увидеть результаты поиска на русском языке, вместо Гугла
		ищите в Яндексе.
		Например, спросите в Яндексе: <strong>"MDN &lt;li&gt;"</strong>.
</p>

<div class="title">упорядоченные списки<br>ordered lists</div>
<p>
    В неупорядоченном списке перестановка элементов &lt;li&gt; не должна изменить
		смысл списка.
		Если же последовательность элементов списка все же имеет значение,
		то вместо нее следует использовать "упорядоченный список".
		Чтобы создать упорядоченный список, просто замените родительский элемент &lt;ul&gt;
		на &lt;ol&gt;.
		Добавьте следующее содержимое в раздел Lists файла basics.html:
</p><p class="code">
&lt;p&gt;This is what an ordered list looks like:&lt;/p&gt;<br>
<br>
&lt;ol&gt;<br>
&lt;li&gt;Notice the new "ol" element wrapping everything&lt;/li&gt;<br>
&lt;li&gt;But, the list item elements are the same&lt;/li&gt;<br>
&lt;li&gt;Also note how the numbers increment on their own&lt;/li&gt;<br>
&lt;li&gt;You should be noticing things is this precise order, because this is
	      an ordered list&lt;/li&gt;<br>
&lt;/ol&gt;
</p><p>
    При перезагрузке страницы в браузере можно заметить, что браузер автоматически
		увеличил числовое значение для каждого элемента &lt;li&gt;.
		В разделе <a href="file:///Users/yarve/SynologyDrive/-FTP/yarve/iih4-hello-css.html">
		Привет, CSS</a> мы узнаем, как изменить тип отображаемых чисел.
</p>

<figure>
<img class="pic-pages" src="./images/iih02-08-html-ordered-lists-120411.11ef13b5.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 9: Веб-страница, на которой отображается &lt;ol&gt; с элементами &lt;li&gt;
		внутри него
</figcaption>
</figure>

<p>
    Разница между неупорядоченным и упорядоченным списком может показаться
		незначительной, но для веб-браузеров, поисковых систем и, конечно же, читателей
		разница очень даже значительна.
		Кроме того, это проще, чем вручную нумеровать каждый элемент списка.
</p><p>
    Пошаговые процедуры, такие как рецепты, инструкции и даже оглавления, являются
		хорошими "кандидатурами" для упорядоченных списков.
		В то время как списки &lt;ul&gt; лучше подходят для представления инвентаризации
		товаров, характеристик продуктов, сравнения "за" и "против", а также для
		создания меню навигации.
</p>

<div class="title" id="elements-italic">акцентирующие (курсивные) элементы<br>emphasis (italic) elements</div>
 <p>
    До сих пор мы работали только с "блоковыми элементами" [block-level elements].
		Они также называются "потоковый контент" [flow content].
		Второй тип содержимого, крупный и крайне важный - "строчные элементы" [inline elements].
		Другое название - "фразовый контент" [phrasing content].
		Блочные элементы всегда отображаются на новой строке, в то время как
		строчные элементы могут воздействовать на участки текста в любом месте строки.
</p>

<figure>
<img class="pic-pages" src="./images/iih02-09-inline-vs-block-elements-44860e.2d5e4a82.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 10: сравнение блоковых элементов (обертывающих несколько строчных
		элементов) и строчных (inline) элементов (внутри блокового элемента)
</figcaption>
</figure>

<p>
    Например, &lt;p&gt; - это блоковый элемент, а &lt;em&gt; - строчный элемент.
		&lt;em&gt; воздействует на участок текста <em>внутри</em> абзаца.
		Он означает "акцентирование" и обычно отображается в виде текста,
		выделенного курсивом.
		Для демонстрации акцентированного текста на нашей веб-странице, добавьте на
		нее новый раздел:
</p><p class="code">
&lt;h2&gt; Inline Elements &lt;/h2&gt;<br>
<br>
&lt;p&gt;&lt;em&gt;Sometimes&lt;/em&gt;, you need to draw attention to a
particular word or<br>
phrase.&lt;/p&gt;
</p><p>
    При этом часть, обернутая в тэги &lt;em&gt;, должна отображаться курсивом,
		как показано на скриншоте ниже.
		Обратите внимание, что затронута только часть строки.
		Это характерно для строчных элементов.
		В главе <a href="iih05-css-box-model.html">Блоковая модель CSS</a> мы узнаем,
		как строчные и блоковые элементы могут существенно влиять на оформление страницы.
</p>

<figure>
<img class="pic-pages" src="./images/iih02-10-html-emphasis-element-87be03.83b41738.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 11: веб-страница с выделением текста курсивом (акцентированием),
    с помощью элемента &lt;em&gt;
</figcaption>
</figure>

<p>
    На всякий случай, если все еще осталась неясность, повторимся.
<em>Крайне</em> важно правильно вложить друг в друга элементы HTML.
		Когда несколько HTML элементов вложены друг в друга, легко может возникнуть
		путаница с порядком следования тегов.
		Поэтому убедитесь, что ваша разметка не выглядит так, как показано ниже:
</p><p class="code">
<span class="code-grey">
&lt;!-- (Никогда не делайте так!) --&gt;
</span><br>
&lt;p&gt;Это курсивом &lt;em&gt;выделенный текст&lt;/p&gt;&lt;/em&gt;
</p>

<div class="title">элементы сильной значимости<br>strong (bold) elements</div>
 <p>
    Если вы хотите придать тексту еще больше значения, серьезности или срочности,
		чем с помощью тега &lt;em&gt;, используйте элемент &lt;strong&gt;.
		Это такой же строчный элемент, как и &lt;em&gt;, а выглядит он так:
</p><p class="code">
&lt;p&gt;Other times, you need to &lt;strong&gt;strong&lt;/strong&gt;ly emphasize
the importance<br> of a word or phrase.&lt;/p&gt;
</p><p>
    На веб-странице элемент &lt;strong&gt; проявится в виде полужирного* текста, см. ниже:
</p><p class="notetran">
    * - для меня все еще загадка, почему в ИТ слово bold переводится как "полужирный".
</p>

<figure>
<img class="pic-pages" src="./images/iih02-11-html-strong-element-d3135f.c06f7a6d.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 12: веб-страница, выделяющая полужирным шрифтом текст, созданный
		с помощью элемента &lt;strong&gt;
</figcaption>
</figure>

<p>
    Чтобы привлечь еще большее внимание к участку текста, можно вложить элемент
		&lt;strong&gt; в элемент &lt;em&gt; (или наоборот).
		В результате текст будет одновременно и полужирным и курсивным:
</p><p class="code">
&lt;p&gt;&lt;em&gt;&lt;strong&gt;And sometimes you need to shout!&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
</p><p>
    Как следует из текста примера, это фактически типографский эквивалент крика.
		Ознакомьтесь с главой <a href="iih14-web-typography.html">Веб-Типографика</a>,
		чтобы не переборщить с использованием полужирных и курсивных шрифтов.
</p>

<figure>
<img class="pic-pages" src="./images/iih02-12-html-strong-emphasis-element-5b0eb2.c94cd79c.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
	 Скриншот 13: веб-страница c полужирным курсивным текстом, созданным
	 с помощью элемента &lt;strong&gt;, обернутого в элемент &lt;em&gt;
</figcaption>
</figure>

<div class="title" id="structure-vs-presentation">структура и внешний вид<br>structure versus presentation</div>
 <p>
    Вам интересно, почему мы используем термины "акцентирование" [emphasis]
		вместо "курсив" [italic] и "сильный" [strong] вместо "полужирный" [bold]?
		Вот мы и подошли к важному различию между HTML и CSS.
		Разметка HTML должна предоставлять <em>семантическую</em> [смысловую] информацию
		о контенте, а не <em>презентационную</em>.
		Другими словами, HTML должен определять структуру документа.
		В то время как в за его внешний вид отвечает CSS.
</p>

<figure>
<img class="pic-pages" src="./images/iih02-13-structure-vs-presentation-05c228.5f730b58.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 14: HTML и CSS. HTML как абстрактное дерево узлов.
	  А CSS как различные формы визуализируемого текста
</figcaption>
</figure>

<p>
    Классическими примером вышеупомянутого различия являются якобы устаревшие
		элементы &lt;b&gt; и &lt;i&gt;.
		Раньше они обозначали "полужирный" [bold] и "курсив" [italic] соответственно.
		Однако в HTML5 была сделана попытка создать четкое разделение между структурой
		документа и его презентацией.
		Поэтому &lt;i&gt; был заменен на &lt;em&gt;, поскольку акцентировать текст
		можно не только курсивом, но и другими способами (например,
		другим шрифтом, другим цветом или бОльшим размером).
		По такому же принципу &lt;b&gt; поменяли на &lt;strong&gt;.
</p><p>
    В разделе <a href="iih04-hello-css.html">Привет, CSS</a>, вы узнаете, как
		изменять отображение браузером элементов &lt;strong&gt; и &lt;em&gt;.
		Это еще раз подтверждает тезис, согласно которому не следует выделять курсивом
		или жирным шрифтом текст в HTML.
		Это должен делать CSS.
</p>

<div class="title" id="empty-html-elements">пустые html-элементы<br>empty html elements</div>
 <p>
    HTML-теги, с которыми мы до сих пор встречались, обертывают либо текстовый
		контент (например, &lt;p&gt;), либо другие HTML-элементы (например, &lt;ol&gt;).
		Но это не относится ко всем элементам HTML.
		Некоторые из них могут быть "пустыми" или "самозакрывающимися".
		Переносы строк и горизонтальные прямые - наиболее распространенные пустые элементы.
</p>
<div class="title-under">ЭЛЕМЕНТ ПЕРЕНОСА СТРОКИ<br>line breaks</div>
<p>
    HTML объединяет идущие друг за другом пробелы, табуляции или новые строки</mark>
		(вместе известные как "пробельные символы") в один пробел.
		Для лучшего понимания добавим в наш файл basics.html следующий раздел:
</p><p class="code">
&lt;h2&gt;Empty Elements&lt;/h2&gt;<br>
<br>
&lt;p&gt;Thanks for reading! Interneting should be getting easier now.&lt;/p&gt;<br>
<br>
&lt;p&gt;Regards,<br>
The Authors&lt;/p&gt;
</p><p>
    Новая строка после Regards в приведенном фрагменте будет преобразована в пробел,
		а не отображена как перенос строки:
</p>

<figure>
<img class="pic-pages" src="./images/iih02-14-html-collapsing-whitespace-c4012d.161f3055.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
	 Скриншот 15: веб-страница, показывающая пользователю пробел вместо переноса
	 строки в документе html
</figcaption>
</figure>

<p>
    Такое поведение может показаться интуитивно понятным, но веб-разработчики
		часто устанавливают в своих редакторах ограничение на длину строки около
		80 символов.
		Программисту так удобнее работать с кодом.
		Но если каждая новая строка будет отображаться на готовой веб-странице,
		это сильно испортит ее внешний вид.
</p><p>
    Чтобы "приказать" браузеру сделать на готовой веб-странице перенос строки,
		используем элемент &lt;br/&gt;, например, так:
</p><p class="code">
&lt;p&gt;Regards,&lt;br/&gt;<br>
The Authors&lt;/p&gt;
</p><p>
    Элемент &lt;br/&gt; полезен там, где важно форматирование текста.
		Хайку, тексты песен, подписи - вот лишь несколько примеров, где он
		может пригодиться.
</p>

<figure>
<img class="pic-pages" src="./images/iih02-15-html-line-break-element-f40443.61956877.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
	 Скриншот 16: веб-страница, показывающая пользователю перенос строки благодаря
	 элементу &lt;br/&gt; в документе html
</figcaption>
</figure>
<p>
    Однако следует быть очень осторожным и не злоупотреблять тегом &lt;br/&gt;.
		Каждый из них должен нести <em>смысловую нагрузку</em>.
		Не стоит использовать его, например, для добавления промежутков между абзацами:
</p><p class="code">
<span class="code-grey">
		    &lt;!-- За такой код вас "запинают" --&gt;
</span><br>
&lt;p&gt;This paragraph needs some space below it...&lt;/p&gt;<br>
&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;<br>
&lt;p&gt;So, I added some hard line breaks.&lt;/p&gt;
</p><p>
    Как уже упоминалось ранее, подобная презентационная вёрстка должна быть
		определена в CSS, а не в HTML.
</p>


<div class="title-under">ГОРИЗОНТАЛЬНЫЕ ПРЯМЫЕ<br>horizontal rules</div>
<p>
    Элемент &lt;hr/&gt; - это "горизонтальное прямая", которое представляет собой
		тематическое разделение.
		Переход от одной сцены рассказа к другой или между концом письма и
		постскриптумом - хорошие примеры того, когда горизонтальное линия уместна.
		Например:
</p><p class="code">
&lt;h2&gt;Empty Elements&lt;/h2&gt;<br>
<br>
&lt;p&gt;Thanks for reading! Interneting should be getting easier now.&lt;/p&gt;<br>
<br>
&lt;p&gt;Regards,&lt;br/&gt;<br>
The Authors&lt;/p&gt;<br>
<br>
&lt;hr/&gt;<br>
<br>
&lt;p&gt;P.S. This page might look like crap, but we'll fix<br> that with some CSS
soon.&lt;/p&gt;
</p><p>
    Одной из тем этого урока было отделение содержания (HTML) от презентации (CSS),
		и &lt;hr/&gt; не является исключением.
		Как и &lt;em&gt; и &lt;strong&gt;, он имеет определенный вид по умолчанию
		(горизонтальная линия).
		Но как только мы начнем работать с CSS, мы сможем использовать его для
		создания дополнительного пространства между секциями, декоративного символа
		или вообще для любых других целей.
</p>

<figure>
<img class="pic-pages" src="./images/iih02-16-html-horizontal-rule-element-49f526.985a65dd.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 17: веб-страница, демонстрирующая элемент &lt;hr/&gt;
</figcaption>
</figure>

<p>
    Подобно &lt;br/&gt;, элемент &lt;hr/&gt; должен нести смысловую нагрузку - не
		стоит использовать его, когда нужно просто вывести строку лишь для эстетики.
		Для эстетики лучше использовать свойство CSS "border", о котором мы поговорим
		через несколько уроков.
</p><p>
    Другой способ восприятия элемента &lt;hr/&gt; заключается в том, что он имеет
<em>меньшее</em> значение, чем разделение, создаваемое элементом заголовка нового абзаца,
	  но <em>большее</em> значение, чем непосредственно новый абзац.
</p>

<div class="title-under">ЗАВЕРШАЮЩИЙ СЛЕШ НЕОБЯЗАТЕЛЕН!<br>optional trailing slash</div>
<p>
    Завершающий слеш (символ "/") во всех пустых HTML-элементах совсем необязателен.
		Приведенный ранее фрагмент можно было бы разметить и так, как показано на
		скриншоте ниже. Обратите внимание на отсутствие слеша в тегах &lt;br&gt; и &lt;hr&gt;:
</p><p class="code">
&lt;p&gt;Regards,&lt;br&gt;<br>
The Authors&lt;/p&gt;<br>
<br>
&lt;hr&gt;<br>
</p><p>
    В принципе, нет разницы, какую разметку вы выберете, но для достижения
		единообразия выберите одну и придерживайтесь ее.
		В данном учебнике мы будем включать символ "/" [slash], так как он ясно
		показывает, что это самозакрывающийся элемент.
		А это, в свою очередь, поможет избежать поиска закрывающего тега в другом
		месте документа.
</p>

<div class="title">РЕЗЮМЕ</div>
<p>
    Этот урок мог показаться бесконечным списком элементов HTML, и, в общем-то,
		так оно и было.
		HTML довольно прост, если разобраться.
		Веб-страницы состоят из HTML-элементов.
		Каждый элемент привносит свой смысл в текст, который он содержит.
		Элементы могут быть вложены друг в друга.
</p><p>
    То, что мы сделали в этом уроке, схематично показывает первый шаг в процессе
		разработки веб-страниц: сначала определяем, <em>что</em> будет сказано - это HTML.
		А затем уже определяем <em>как</em> оно будет представлено - это CSS.
		Надеемся, что файл basics.html, созданный нами в этой главе, послужит
		полезным кратким справочником по основным элементам HTML.
		Если вы вдруг потеряете его, то вот как он должен выглядеть:
</p>

<figure>
<img class="pic-pages" src="./images/iih02-17-basic-web-pages-f786d5.8b5b2562.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
	  Скриншот 18: основные элементы HTML: &lt;title&gt;, &lt;p&gt;,
&lt;h1&gt;, &lt;ol&gt; и др.
</figcaption>
</figure>

<p>
    Ранее говорилось, что написание HTML кода похоже на работу в
		редакторе WYSIWYG.
		Разумеется, писать на HTML - гораздо более трудоемкий процесс.
		Однако трудоемкость уравновешивается его невероятной гибкостью.
		Написанный вами код отобразится на экране ноутбука или ПК, смартфоне,
		планшете или на листе бумаги.
		Причем каждое из этих отображений может иметь другое оформление.
		Изменить стиль нескольких документов, можно всего лишь изменив одну строку CSS.
		Microsoft Word и близко не стоит к потенциалу HTML/CSS как инструмента
		для работы с контентом.
</p><p>
    На следующем уроке мы завершим наше обучение HTML с помощью остальных элементов,
		с которыми вы будете сталкиваться постоянно: ссылок и изображений.
		Если желаете самостоятельно изучить менее известные элементов, рекомендуем
<a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element">
		справочник MDN по элементам HTML</a>.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>ССЫЛКИ И КАРТИНКИ</h2>
<p>УРОК Nº 3</p>
<p><em>
    Просто и понятно про взаимодействие веб-страниц друг с другом
</em></p>


<p>
    На <a href="iih02-basic-web-pages.html">предыдущем уроке</a> были рассмотрены
		некоторые весьма важные элементы HTML, но мы имели дело только с одной вебстраницей.
		Принципиальное отличие ссылок и изображений в том, что они имеют дело с
<em>внешними</em> ресурсами.
		Гиперссылки [тж. просто "ссылки"] указывают пользователю на другой HTML-документ,
		а изображения добавляют на страницу другой файл.
</p>

<figure>
<img class="pic-pages" src="./images/iih03-01-links-and-images-6820c7.7d96205e.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 1: картинка, указывающая на элемент &lt;img&gt; на веб-странице, и
		HTML-ссылка, указывающая с веб-страницы на другую веб-страницу
</figcaption>
</figure>

<p>
	  Для использования ссылок и картинок нам также необходимо познакомиться с
		еще одним компонентом синтаксиса HTML - атрибутами.
		Атрибуты откроют перед нами целый мир новых возможностей для наших веб-страниц.
</p><p>
    На этом уроке мы создадим простой сайт, состоящий из нескольких HTML-документов
		и файлов изображений*.
		Хотя урок называется "Ссылки и картинки", на самом деле основная тема - структура
		файлов и папок.
		Начав работать с несколькими файлами, вы поймете, насколько организованность
		важна для веб-разработчика.
</p><p class="notetran">
    * - десь и далее понятия "изображение" и "картинка" - синонимы, означающие
		одно и то же.
</p>

<div class="title">подготовка<br>setup</div>
<p>
    Поскольку этот урок посвящен взаимодействию веб-страниц друг с другом,
		прежде чем приступить к созданию кода, мы создим несколько новых HTML-файлов.
		Мы будем работать с тремя отдельными веб-страницами, а также с несколькими
		файлами изображений различных форматов:
</p>

<figure>
<img class="pic-pages" src="./images/iih03-02-links-and-images-example-7ab70f.bfcb5afb.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 2: Семь файлов для данного проекта (3 HTML-файла, 4 файла картинок)
</figcaption>
</figure>

<p>
    Для начала создайте новую папку links-and-images.
		Все наши файлы будут храниться в ней.
	  Попробуйте сделать это в Atom, следуя инструкциям из главы <a href="iih01-intro.html#atom">
		Введение</a>.
</p>

<div class="title-under">СТРАНИЦА LINKS<br>links page</div>
<p>
    Затем добавьте в созданную папку новый файл links.html.
		Напишите внутри него следующий HTML-код.
		Он вам уже знаком по предыдущему уроку.
</p><p class="code">
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
&lt;head&gt;<br>
&lt;title&gt;Links&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
&lt;h1&gt;Links&lt;/h1&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p>

<div class="title-under">СТРАНИЦА IMAGES<br>images page</div>
<p>
	В той же папке создаем еще один файл с именем images.html:
</p><p class="code">
	&lt;!DOCTYPE html&gt;<br>
	&lt;html&gt;<br>
	&lt;head&gt;<br>
	&lt;title&gt;Images&lt;/title&gt;<br>
	&lt;/head&gt;<br>
	&lt;body&gt;<br>
	&lt;h1&gt;Images&lt;/h1&gt;<br>
	&lt;/body&gt;<br>
	&lt;/html&gt;
</p>

<div class="title-under">СТРАНИЦА EXTRAS<br>extras page</div>
<p>
	Наша последняя страница поможет продемонстрировать нам относительные ссылки.
	Создайте в папке links-and-images новую папку misc.
	Добавьте в нее новый файл - extras.html:
</p><p class="code">
	&lt;!DOCTYPE html&gt;<br>
	&lt;html&gt;<br>
	&lt;head&gt;<br>
	&lt;title&gt;Extras&lt;/title&gt;<br>
	&lt;/head&gt;<br>
	&lt;body&gt;<br>
	&lt;h1&gt;Extras&lt;/h1&gt;<br>
	&lt;/body&gt;<br>
	&lt;/html&gt;
</p><p>
    Кстати можно создать новую папку прямо в Atom, щелкнув правой кнопкой
		мыши на панели браузера файлов и выбрав в контекстном меню пункт <strong>New Folder</strong>.
		Жизнь прекрасна, когда не нужно выходить из текстового редактора.
</p>

<div class="title-under">СКАЧАЙТЕ КАРТИНКИ<br>image downloads</div>
<p>
    Мы будем вставлять изображения в наш файл images.html, поэтому обязательно
		скачайте эти <a href="docs/iih03-images-4149f7.zip">примеры с картинками моти</a>*.
		Распакуйте их в папку links-and-images, сохранив родительскую папку images
		из скачанного ZIP-файла.
		Теперь ваш проект должен выглядеть так:
</p><p class="notetran">
    * - "моти" или "мочи" (яп. 餅) - японский десерт в виде колобков или брусков
		из рисовой муки.
</p>

<figure>
<img class="pic-pages" src="./images/iih03-03-example-files-b21613.a16803e0.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 3: браузер редактора Atom после создания файлов примеров
</figcaption>
</figure>

<div class="title">якоря<br>anchors</div>
<p>
    Ссылки создаются с помощью элемента &lt;a&gt;, который сокращенно означает
		"якорь" [anchor].
		Этот элемент работает так же, как и все элементы из предыдущей главы:
		когда вы оборачиваете фрагмент текста тегами &lt;a&gt;, это изменяет смысл
		его содержимого.
		Рассмотрим это на примере добавления следующего абзаца в элемент &lt;body&gt;
		файла links.html:
</p><p class="code">
&lt;p&gt;This example is about links and &lt;a&gt;images&lt;/a&gt;.&lt;/p&gt;
</p><p>
    Если вы загрузите эту страницу в браузере, то заметите, что элемент &lt;a&gt;
		совсем не похож на ссылку.
		Увы, к сожалению, элемент &lt;a&gt; сам по себе ничего особенного не умеет.
</p>

<div class="title" id="links">ссылки<br>links</div>
<p>
    Подобно тому, как элемент придает смысл содержимому, которое он содержит,
		HTML-атрибут придает смысл элементу, к которому он присоединен.
</p>

<figure>
<img class="pic-pages" src="./images/iih03-04-html-attributes-6f5690.38791440.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 4: HTML-атрибут href, присоединенный к HTML-элементу &lt;a&gt;,
		который в свою очередь присоединен к исходному контенту
</figcaption>
</figure>

<p>
    Разные элементы могут использовать различные атрибуты, и за подробностями
		о том, какие элементы принимают те или иные атрибуты, можно обратиться к
<a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element">MDN</a>.
		В данный момент нас интересует атрибут href, поскольку он определяет, куда
		переходит пользователь при нажатии на элемент &lt;a&gt;.
		Обновите свою ссылку, как показано ниже:
</p><p class="code">
&lt;p&gt;This example is about links and &lt;a href='images.html'&gt;images&lt;/a&gt;.&lt;/p&gt;
</p><p>
    Обратите внимание, как атрибуты располагаются внутри <em>открывающего</em> тега.
		Сначала идет имя атрибута, затем знак равенства, затем "значение" атрибута в
		одинарных или двойных кавычках.
		Такой синтаксис отличает атрибуты от содержимого (которое находится между тегами).
</p><p>
    Дополнительная информация, предоставляемая атрибутом href, сообщает браузеру,
		что данный элемент &lt;a&gt; является ссылкой, и он должен отобразить содержимое
		ссылки в виде синего текста, используемого по умолчанию:
</p>

<figure>
<img class="pic-pages" src="./images/iih03-05-html-link-href-element-61348e.8b7a29a2.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 5: веб-страница с синей ссылкой &lt;a href&gt;.
</figcaption>
</figure>

<div class="title" id="absolute-relative-and-root-relative-links">
    абсолютные, относительные и корневые ссылки<br>absolute, relative, and
		root-relative links
</div>
<p>
    Теперь, когда мы работаем со ссылками, нам необходимо понять, как устроен сайт.
		В нашем случае сайт - это просто набор HTML-файлов, разложенных по папкам.
		Чтобы ссылаться на эти файлы изнутри другого файла, в Интернете используются
		"единые локаторы ресурсов" (URL).
		В зависимости от того, на что вы ссылаетесь, URL могут принимать различные формы.
		Ниже выделены три типа URL, с которыми мы будем иметь дело:
</p>

<figure>
<img class="pic-pages" src="./images/iih03-06-absolute-relative-root-relative-links-104560.44a1740c.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 6: абсолютные (absolute) ссылки, указывающие на другой сайт,
		относительные (relative) ссылки, указывающие на другую страницу того же сайта
		и корневые (root-relative) ссылки, указывающие на другую страницу того же
		сайта через его домен
</figcaption>
</figure>

<p>
    Абсолютные, относительные и корневые ссылки зависят от значения атрибута href.
		Далее вы узнаете, как и когда использовать каждый из них.
		Но сначала давайте добавим в файл links.html следующее:
</p><p class="code">
&lt;p&gt;This example is about links! There are three kinds of links:&lt;/p&gt;<br>
<br>
&lt;ul&gt;<br>
<span class="code-grey">
&lt;!-- Сюда добавляем элементы &lt;li&gt; --&gt;
</span><br>
&lt;/ul&gt;
</p>

<div class="title-under">АБСОЛЮТНЫЕ ССЫЛКИ<br>absolute links</div>
<p>
    "Абсолютные" ссылки [absolute links] - это наиболее подробный способ обращения
		к веб-ресурсу.
		Они начинаются со "схемы" (обычно http:// или https://), за которой следует
		доменное имя сайта, а затем путь к целевой веб-странице.
</p>

<figure>
<img class="pic-pages" src="./images/iih03-07-absolute-link-syntax-64d730.e28d46a7.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 7: схема (https://), домен (developer.mozilla.org),
		путь (/en-us/docs/web/html).
</figcaption>
</figure>

<p>
    Попробуем, например, создать ссылку на справочник HTML-элементов Mozilla
		Developer Network:
</p><p class="code">
&lt;li&gt;Absolute links, like to<br>
&lt;a href='https://developer.mozilla.org/en-US/docs/Web/HTML'&gt; Mozilla<br>
Developer Network</a>, which is a very good resource for web<br>
developers.
&lt;/li&gt;

</p><p>
    Можно использовать абсолютные ссылки для ссылок на страницы собственного сайта,
		но жесткое кодирование своего доменного имени может привести к возникновению
		неприятных ситуаций.
		Поэтому абсолютные ссылки рекомендуется использовать только для перенаправления
		пользователей на другой сайт.
</p>

	<figure>
	<img class="pic-pages" src="./images/iih03-08-absolute-links-32f469.bd16b83a.png"
	width="70%" alt="Interneting is hard HTML+CSS">
	<figcaption>
	    Скриншот 8: абсолютная ссылка, указывающая с нашего сайта на другой сайт
	</figcaption>
	</figure>

<div class="title-under">ОТНОСИТЕЛЬНЫЕ ССЫЛКИ<br>relative links</div>
<p>
  	"Относительные" ссылки [relative links] указывают на другой файл на вашем сайте с перспективы
    того файла, который вы редактируете.
	  При этом подразумевается, что схема и доменное имя совпадают с текущей страницей.
	  Поэтому единственное, что необходимо указать - это путь.
</p><p>
	  Вот как можно сослаться на наш файл extras.html из файла links.html:
</p><p class="code">
&lt;li&gt;Relative links, like to our 	&lt;a href='misc/extras.html'&gt; extras<br>
page&lt;/a&gt;.&lt;/li&gt;
</p><p>
    В данном случае атрибут href представляет собой путь к файлу extras.html
		из файла links.html*.
  	Поскольку extras.html находится в другой папке, в URL необходимо включить
		папку misc.
</p><p class="notetran">
    * - обратите внимание, что путь пролегает <strong>из одного файла в другой</strong>.
    Причем другой файл <strong>extras.html лежит в другой папке</strong>,
    а именно в папке misc.
</p>

<figure>
<img class="pic-pages" src="./images/iih03-09-relative-links-e178d0.de636c3f.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 9: относительная ссылка, указывающая с одной страницы нашего сайта
		на другую
</figcaption>
</figure>

<p>
    Каждая папка и файл разделяются слешем (/).
		Таким образом, если бы мы пытались получить файл, находящийся в двух вложенных
		друг в дружку папках, потребовался бы URL вот такого вида:
</p><p class="code">
misc/other-folder/extras.html
</p>

<div class="title-under">РОДИТЕЛЬСКИЕ ПАПКИ<br>parent folders</div>
<p>
    Как ссылаться на файлы в той же самой папке или во вложенной папке мы разобрались.
		А вот как ссылаться на файл, помещенный в папку <em>уровнем выше</em>?
		Давайте в нашем файле extras.html создадим относительные ссылки на
		links.html и images.html.
		Для этого дообавим немного кода в файл extras.html:
</p><p class="code">
&lt;p&gt;This page is about miscellaneous HTML things, but you may<br>
also be interested in &lt;a href='links.html'&gt;links&lt;/a&gt; or<br>
&lt;a href='images.html'&gt;images&lt;/a&gt;.&lt;/p&gt;
</p><p>
    Однако при щелчке на любую из этих ссылок браузере будет "ругаться" - дескать
		такая страница не существует.
		Взглянув на адресную строку, мы обнаружим, что браузер пытается загрузить
		misc/links.html и misc/images.html.
		Но ведь он ищет эти файлы не в той папке!
		Все это объясняется тем, что наши ссылки являются относительными по отношению
		к расположению файла extras.html, который находится в папке misc.
</p>

<figure>
<img class="pic-pages" src="./images/iih03-10-relative-link-no-parent-4629d0.2a30136c.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 10: заведомо неудачная попытка ссылки на HTML-страницы из-за отсутствия
		обращения к каталогу родителя [parent reference]
</figcaption>
</figure>

<p>
    Чтобы исправить эту ошибку, нам понадобится вот такой синтаксис ".."
		[две последовательные точки без кавычек].
		Именно эти две последовательные точки вставленный в путь к файлу укажут на
		родительский каталог:
</p><p class="code">
&lt;p&gt;This page is about miscellaneous HTML things, but you may<br>
also be interested in &lt;a href='links.html'&gt;links&lt;/a&gt; or<br>
&lt;a href='images.html'&gt;images&lt;/a&gt;.&lt;/p&gt;
<p>
    Это все равно, что сказать:
		"Файл extras.html находится в папке misc.
		Поднимись в папку и найди там links.html и images.html".
</p>

<figure>
<img class="pic-pages" src="./images/iih03-11-relative-link-with-parent-666b79.13ea3d47.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 11: корректная ссылка на HTML-страницы с обращением к каталогу
		родителя
</figcaption>
</figure>

<p>
    Для перехода вверх по каталогам используйте соответствующее число точек.
		В нашем случае точек будет две:
</p><p class="code">
../../elsewhere.html
</p><p>
    Относительные ссылки удобны тем, что позволяют перемещаться по всему каталогу
		без необходимости обновлять все href в элементах &lt;a&gt;.
		Однако возможна и путаница, если все ссылки начинаются с кучи точек.
		Лучше всего относительные ссылки подходят подходят для привязки к файлам,
		находящимся в одной папке или в отдельном разделе сайта.
</p><p>
    Например, все картинки в <a href="/iih/">нашем учебнике</a> загружаются
		через относительные ссылки (про картинки поговорим чуть ниже).
		Благодаря относительным ссылкам мы можем переименовать название любого урока
		без необходимости обновлять все пути к картинкам.
</p>

<div class="title-under">КОРНЕВЫЕ ССЫЛКИ<br>root-relative links</div>

<p>
    "Корневые" ссылки [root-relative links] аналогичны вышеупомянутым относительным ссылкам.
		Но вместо того, чтобы относиться к текущей странице, они относятся к "корню"
		всего сайта.
		Например, если ваш сайт: our-site.com, то все URL-адреса, относящиеся к корню,
		будут относиться к our-site.com.
</p>

<figure>
<img class="pic-pages" src="./images/iih03-12-root-relative-links-368060.237b8500.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 12: ссылка с одной веб-страницы нашего сайта, проходящая через наш
		домен, затем на другую страницу нашего сайта
</figcaption>
</figure>

<p>
    К сожалению, в нашей дискуссии про корневые ссылки есть одна оговорка:
		в данном учебнике используются локальные HTML-файлы, а не сайт, размещенный
		на веб-сервере.
		Это означает, что мы не сможем экспериментировать с корневыми ссылками.
		Но если бы у нас был настоящий сервер, то ссылка на нашу домашнюю страницу
		выглядела бы так:
</p><p class="code">
<span class="code-grey">
&lt;!-- Это не будет работать для наших локальных HTML-файлов --&gt;</span><br>
&lt;li&gt;Root-relative links, like to the &lt;a href='/'&gt;home page&lt;/a&gt;
of our website,<br>
but those aren't useful to us right now.&lt;/li&gt;
<!--
&lt;li&gt;Корневая ссылка на &lt;a href='/'&gt;домашнюю страницу&lt;/a&gt; сайта,<br>
в нашем случае не нужна.&lt;/li&gt; -->

</p><p>
	  Единственное отличие корневой ссылки от относительной заключается в том,
		что корневая <em>начинается</em> с прямого слеша*.
		Cлеш представляет корень нашего сайта.
		После слеша можно добавлять в указанный путь дополнительные папки и файлы,
		как и в случае с относительными ссылками.
		Следующий путь будет работать корректно независимо от того, где находится
		текущая страница (даже в misc/extras.html):
</p><p class="code">
/images.html
</p><p class="notetran">
    * - слеш (forward slash или просто slash) - косая прямая, выглядит как знак
		дроби "/".
</p><p>
    Корневые ссылки - это один из наиболее полезных видов ссылок.
		Они достаточно явны, чтобы избежать потенциальной путаницы с относительными
		ссылками, но не настолько явны, как абсолютные ссылки.
		Вы будете часто видеть их на протяжении всей своей карьеры веб-разработчика,
		особенно на больших сайтах, где трудно уследить за относительными ссылками.
</p>

<div class="title">ЦЕЛИ ССЫЛОК<br>LINK TARGETS</div>

<p>
    Итак, атрибуты изменяют значение HTML-элементов.
		Но иногда требуется изменить не один, а несколько аспектов элемента.
		Например, элементы &lt;a> также допускают атрибут target, определяющий место
		отображения страницы, после того, как пользователь щелкнул на ссылку.
		По умолчанию большинство браузеров заменяют текущую страницу на новую.
		Однако мы можем использовать атрибут target.
		С помощью этого аттрибута мы даем команду браузеру открыть ссылку в новом окне/вкладке.
</p><p>
	  Попробуйте изменить нашу абсолютную ссылку в файле links.html как указано ниже.
		Обратите внимание, что второй атрибут выглядит так же, как и первый, но они
		отделены друг от друга пробелом (или новой строкой):
</p><p class="code">
&lt;li&gt;Absolute links, like to<br>
&lt;a href='https://developer.mozilla.org/en-US/docs/Web/HTML'<br>
target='_blank'&gt;Mozilla Developer Network&lt;/a&gt;, which is a very good<br>
resource for web developers.&lt;/li&gt;
</p><p>
    Атрибут target имеет несколько предопределенных значений, имеющих для браузеров
		особый смысл.
		Самым распространенным значением является _blank, который говорит браузеру:
		"данную ссылку открой в новой вкладке (или в новом окне)*".
		Об остальных значениях можно прочитать на сайте <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/a">
		MDN</a>.
</p><p class="notetran">
    * - так все-таки в новой вкладке или в новом окне? <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/a">
		Англоязычная страница MDN</a> поясняет, что пользователь может изменить настройки
		своего браузера, где открывать ссылок с _target: в новой вкладке либо в новом окне.
		"_blank: usually a new tab, but users can configure browsers to open a new window instead."
</p>

<div class="title">стандарты наименования файлов<br>naming conventions</div>

<p>
    Вы заметили, ни один из наших файлов и папок не содержит пробелов в своем названии?
		Это не случайно.
		Пробелы в URL требуют особого обращения, поэтому ни в коем случае не
		допускайте пробелов.
		Для лучшего понимания попробуйте создать в нашем проекте links-and-images
		новый файл под названием "spaces are bad.html".
		Добавьте в него какой-либо небольшой текст, а затем откройте его в браузере
		Chrome или Safari (Firefox схитрит и сохранит пробелы).
</p><p class="code">
links-and-images/spaces%20are%20bad.html
</p><p>
    В адресной строке вы увидите, что все наши пробелы были заменены на "%20",
		как показано выше.
		Пробелы в URL не допускаются, поэтому для их обозначения используется
		специальная кодировка.
		Вместо пробела всегда следует использовать дефис, как это сделано во всем
		этом учебнике.
		Для единообразия также рекомендуется всегда использовать строчные символы
		вместо заглавных.
</p><p>
    Обратите внимание, что существует прямая связь между именами файлов и папок
		и URL-адресом веб-страницы, которую они представляют.
		Названия наших папок и файлов определяют URL-адреса наших веб-страниц.
		Они видны пользователю, а значит, к наименованию файлов нужно приложить не
		меньше усилий, чем к созданию содержащегося в них содержимого.
</p><p>
    Эти стандарты наименования относятся ко <em>всем</em> файлам сайта, а не только к HTML-файлам.
		В CSS-файлах, JavaScript-файлах и картинках также следует избегать пробелов
		и заглавных букв.
</p>

<div class="title">КАРТИНКИ<br>IMAGES</div>

<p>
    В отличие от всех элементов HTML, с которыми мы до сих пор сталкивались,
		содержимое изображения находится <em>вне</em> веб-страницы, на которой отображается изображение.
		К счастью, у нас уже есть возможность ссылаться на внешние ресурсы из
		HTML-документа: с помощью абсолютных, относительных и корневых ссылок.
</p><p>
    Картинки добавляются на веб-страницы с помощью тега &lt;img/&gt; и его
		атрибута src, указывающего на файл отображаемой картинки.
		Заметьте, что это <a href="iih02-basic-web-pages.html#emptyhtmlelements">
		пустой элемент</a>, как &lt;br/&gt; и &lt;hr/&gt;
		из предыдущего урока.
		(Не стоит пока добавлять его в наш проект.
		Конкретные примеры мы рассмотрим далее).
</p><p class="code">
&lt;img src='some-photo.jpg'/&gt;
</p><p>
    Retina-дисплеи и мобильные устройства делают работу с изображениями
		несколько сложнее, чем старый добрый &lt;img/&gt;.
		Мы оставим эти сложности для главы <a href="iih11-responsive-images.html">
		Responsive Images</a>.
		Также не забудьте ознакомиться с элементами &lt;figure&gt; и &lt;figcaption&gt;
		на уроке <a href="iih12-semantic-html.html">Семантика HTML</a>.
</p><p>
    А мы пока что сфокусируемся на форматах изображений, используемых в сети.
</p>

<div class="title">ФОРМАТЫ ИЗОБРАЖЕНИЙ<br>IMAGE FORMATS</div>

<p>
    Существует четыре основных формата изображений, используемых в сети.
		Все они предназначены для выполнения различных задач.
		Понимание их предназначения позволяет значительно улучшить качество веб-страниц.
</p>

<figure>
<img class="pic-pages" src="./images/iih03-14-image-formats-62b23d.df203a3f.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 13: примеры форматов JPG, GIF, PNG и SVG
</figcaption>
</figure>

<p>
    В следующих нескольких секциях мы рассмотрим идеальные варианты использования
		каждого из этих форматов.
		Прежде чем двигаться дальше, убедитесь, что ZIP-файл с <a href="docs/iih03-images-4149f7.zip">
		картинками моти</a> уже скачан, распакован и добавлен в проект links-and-images.
</p>

<div class="title-under">ФОРМАТ JPG<br></div>
<p>
    Изображения в формате JPG предназначены для работы с большими цветовыми палитрами
		без чрезмерного увеличения размера файла.
		Поэтому они отлично подходят для фотографий и картинок с множеством оттенков.
		Но JPG не позволяют создавать прозрачные фон, в чем можно убедиться, присмотревшись
		к картинке ниже.
		Видите каемку на изображении?
</p>

<figure>
<img class="pic-index" src="./images/iih03-15-mochi-77c69d.385ff9c7.jpg"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 14: моти в прозрачном "пузыре", с каймой
</figcaption>
</figure>

<p>
    Добавьте mochi.jpg на нашу страницу images.html с помощью следующего кода
		(он также содержит немного навигации по другим нашим страницам):
</p><p class="code">
&lt;p&gt;This page covers common image formats, but you may also be looking for &lt;a
<br>
href='links.html'&gt;links&lt;/a&gt; and &lt;a href='misc/extras.html'&gt;useful
<br>
extras&lt;/a&gt;.&lt;/p&gt;<br>
<br>
&lt;h2&gt;JPGs&lt;/h2&gt;<br>
<br>
&lt;p&gt;JPG images are good for photos.&lt;/p&gt;<br>
<br>
&lt;img src='images/mochi.jpg'/&gt;
</p>

<div class="title-under">ФОРМАТ GIF<br></div>
<p>
    GIF-файлы - это оптимальный вариант для простой анимации, но их недостатком
		является то, что они несколько ограничены в плане цветовой палитры.
		Поэтому никогда не используйте "гифки" для фотографий.
		Прозрачные пиксели - это бинарная опция для GIF, т.е. вы не получите
		полупрозрачных пикселей.
		Это может затруднить получение высокого уровня детализации на прозрачном фоне.
		По этой причине лучше использовать PNG-картинки, если вам не требуется анимация.
</p>

<figure>
<img class="pic-index" src="./images/iih03-16-mochi-961ee5.6d9c21cd.gif"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 15: анимированный моти (mochi.gif)
</figcaption>
</figure>

<p>
    Добавить этого малыша в наш файл images.html поможет следующий код:
</p><p class="code">
&lt;h2&gt;GIFs&lt;/h2&gt;<br>
<br>
&lt;p&gt;GIFs are good for animations.&lt;/p&gt;<br>
<br>
&lt;img src='images/mochi.gif'/&gt;
</p>


<div class="title-under">ФОРМАТ PNG<br></div>
<p>
    PNG-файлы отлично подходят для всего, что не является фотографией или анимацией.
		Для фотографий PNG-файл такого же качества (как воспринимает человеческий глаз),
		обычно "весит" больше, чем эквивалентный JPG-файл.
		Однако PNG прекрасно справляются с непрозрачностью и не имеют ограничений
		по цветовой палитре.
		Поэтому они отлично подходят для иконок, технических диаграмм, логотипов и т.д.
</p>

<figure>
<img class="pic-index" src="./images/iih03-17-mochi-f95fdf.849f17a3.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 16: простой моти в формате .png
</figcaption>
</figure>

<p>
    Давайте добавим и эту PNG-картинку в наш проект:
</p><p class="code">
&lt;h2&gt;PNGs&lt;/h2&gt;<br>
<br>
&lt;p&gt;GIFs are good for diagrams and icons.&lt;/p&gt;<br>
<br>
&lt;img src='images/mochi.png'/&gt;
</p>

<div class="title-under" id="svg-images">ФОРМАТ SVG<br></div>
<p>
    В отличие от описанных выше форматов, основанных на пикселях, SVG - это векторный
		графический формат.
		Он может увеличиваться или уменьшаться до любых размеров без потери качества.
		Это свойство делает SVG-изображения прекрасным инструментом для <a href="iih10-responsive-design.html">
		адаптивного дизайна</a>.
		SVG подходят практически для всех тех же целей, что и PNG.
		Используйте SVG при любой возможности.
</p>

<figure>
<img class="pic-pages" src="./images/iih03-18-svg-vs-png-image-3df7fd.cf9848fd.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 17: SVG-изображение с четкими краями по сравнению с пикселизированным
		PNG-изображением
</figcaption>
</figure>

<p>
    Обе картинки на скриншоте выше имели первоначальный размер 100×100 пикселей
		и одинаковую резкость.
		Затем масштаб увеличили до 300×300 пикселей.
    Почувствуйте разницу.
		Четкие, чистые линии на SVG (слева), в то время как PNG (справа) заметно
		пикселизировано.
</p><p>
    Несмотря на то, что SVG является векторным форматом, его можно использовать
		точно так же, как и его растровый аналог.
		Добавьте файл mochi.svg на нашу страницу images.html:
</p>

<p class="code">
&lt;h2&gt;SVGss&lt;/h2&gt;<br>
<br>
&lt;p&gt;SVGs are &lt;em&gt;amazing&lt;/em&gt;. Use them wherever you can.&lt;/p&gt;<br>
<br>
&lt;img src='images/mochi.svg'/&gt;
</p><p>
    Однако у SVG есть одна проблемка: для их корректного отображения в разных браузерах,
		нужно преобразовать все текстовые поля в контуры.
		Например с помощью Adobe Illustrator или <a href="https://www.sketch.com">
		Sketch</a>).
		Если ваши картинки содержат много текста (как, например, причудливые
		скриншоты в этом учебнике), это может сильно повлиять на размер файла.
		По этой причине мы используем PNG вместо SVG.
		Но в любом случае SVG - это супер!
</p>

<div class="title">размеры изображений<br>image dimensions</div>
<p>
    По умолчанию элемент &lt;img/&gt; использует унаследованные размеры своего файла изображения.
		Наши JPG, GIF и PNG на самом деле имеют размер 150×150 пикселей,
		в то время как размер нашего SVG всего 75×75 пикселей.
</p>

<figure>
<img class="pic-pages" src="./images/iih03-19-html-img-formats-3b43c6.998f97de.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 18: веб-страница после встраивания &lt;img&gt;-элементов JPG, GIF,
		PNG и SVG
</figcaption>
</figure>

<p>
		Для корректного отображения пиксельные форматов на дисплеях retina
		[например на дивайсах от Apple] размеры изображений должны быть в два
		раза больше.
    Мы обсудим это в разделе <a href="iih11-responsive-images.html">
		Адаптивные картинки</a>.
		А сейчас атрибут width элемента &lt;img/&gt; поможет нам уменьшить наши
		пиксельные картинки до нужного размера 75×75.
		В файле images.html обновите все наши пиксельные изображения, как показано ниже:
</p><p class="code">
<span class="code-grey">
&lt;!-- в раздел JPG --&gt;</span><br>
&lt;img src='images/mochi.jpg' width='75'/&gt;<br>
<br>
<span class="code-grey">
&lt;!-- в раздел GIF --&gt;</span><br>
&lt;img src='images/mochi.gif' width='75'/&gt;<br>
<br>
<span class="code-grey">
&lt;!-- в раздел PNG --&gt;</span><br>
&lt;img src='images/mochi.png' width='75'/&gt;<br>
</p><p>
	  Атрибут width ["ширина"] задает четкий размер изображения.
	  Также существует атрибут height ["высота"].
	  Задание только одного из них приведет к пропорциональному масштабированию
		изображения, в то время как определение обоих приведет к растяжению изображения.
		Значения размеров указываются в пикселях. Никогда не добавляйте указание каких-либо
		единиц измерения (например, width='75px' будет неверным).
</p><p>
    Атрибуты width и height полезны, но все же в больштнстве случаев лучше задавать
		размеры изображения с помощью CSS, чтобы можно было легко изменять их с помощью
		медиавыражений [media queries].
		Мы обсудим это более подробно, когда дойдем до <a href="iih10-responsive-design.html">
		адаптивного дизайна</a>.
</p>

<div class="title" id="text-alternatives">Текстовые альтернативы<br>text alternatives</div>
<p>
    Добавление атрибутов alt к элементам &lt;img/&gt; является лучшей практикой.
		Эти атрибуты определяют "текстовую альтернативу" отображаемому изображению.
		Это влияет как на поисковые системы, так и на пользователей невизуальных
		браузеров, использующих только текст (например, для людей с нарушениями зрения,
		использующих программы для чтения с экрана).
</p><p>
    Обновим все наши картинки, включив в них описательные атрибуты alt:
</p><p class="code">
<span class="code-grey">
&lt;!-- в раздел JPG --&gt;</span><br>
&lt;img src='images/mochi.jpg' width='75' alt='A mochi ball in a bubble'/&gt;<br>
<br>
<span class="code-grey">
&lt;!-- в раздел GIF --&gt;</span><br>
&lt;img src='images/mochi.gif' width='75' alt='A dancing mochi ball'/&gt;<br>
<br>
<span class="code-grey">
&lt;!-- в раздел PNG --&gt;</span><br>
&lt;img src='images/mochi.png' width='75' alt='A mochi ball'/&gt;<br>
<br>
<span class="code-grey">
&lt;!-- в раздел SVG --&gt;</span><br>
&lt;img src='images/mochi.png' alt='A mochi ball with Bézier handles'/&gt;
</p><p>
    Дополнительные примеры использования атрибута alt приведены в безумно подробной
<a href="https://www.w3.org/TR/html5/embedded-content-0.html#alt">
		официальной спецификации</a>.
</p>

<div class="title" id="more-html-attributes">другие html-атрибуты<br>more html attributes</div>
<p>
    Мы надеемся, что вы достаточно хорошо освоили синтаксис атрибутов HTML.
		Теперь можно добавить пару завершающих штрихов к HTML-коду нашего проекта.
		Каждая создаваемая вами веб-страница должна определять язык, на котором она
		написана, и набор символов.
</p>

<div class="title-under">ЯЗЫК ДОКУМЕНТА<br>document language</div>
<p>
    Язык веб-страницы по умолчанию определяется атрибутом lang в элементе
		верхнего уровня &lt;html&gt;.
		Наш документ написан на английском языке*, поэтому в качестве значения атрибута
		мы будем использовать код страны en.
		Сделайте это для <em>всех</em> созданных нами страниц:
</p><p class="code">
&lt;html lang='en'&gt;<br>
</p><p class="notetran">
    * - для вебстраниц с html-файлами данного перевода я, естественно, использовал
    указание на язык текста 'ru', то есть Russian (&lt;html lang='ru'&gt;).
</p><p>
    Если интересно узнать какому языку соответствует какой языковой код, загляните на
<a href="http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry">
		эту страницу</a> в поле <strong>Subtag</strong>.
</p>

<div class="title-under">КОДИРОВКИ СИМВОЛОВ<br>CHARACTER SETS</div>
<p>
    "Кодировки символов" [или просто "кодировки"] - это что-то вроде цифрового
		алфавита для вашего браузера.
		Он отличается от языка вашего документа тем, что влияет только на отображение
		самих букв, а не на язык контента.
		Попробуйте скопировать и вставить несколько слов с необычными символами в
		наш misc/extras.html.
		Посмотрим, что получится.
</p><p class="code">
&lt;h2&gt;Кодировки&lt;/h2&gt;<br>
<br>
&lt;p&gt;UTF-8 можно использовать для записи счета в турецком языке:&lt;/p&gt;<br>
<br>
&lt;ol&gt;<br>
&lt;li&gt;bir&lt;/li&gt;<br>
&lt;li&gt;iki&lt;/li&gt;<br>
&lt;li&gt;üç&lt;/li&gt;<br>
&lt;li&gt;dört&lt;/li&gt;<br>
&lt;li&gt;beş&lt;/li&gt;<br>
&lt;/ol&gt;
</p><p>
    Просматривая эту запись в браузере, Вы увидите какие-то кракозябры вместо
		международных символов ü, ç, ö и ş:
</p>

<figure>
<img class="pic-pages" src="./images/iih03-20-html-character-sets-no-utf-8-304820.390899c3.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 19: веб-страница показывает кракозябры [weird stuff] вместо
		специальных символов
</figcaption>
</figure>

<p>
    Это происходит потому, что стандартный набор символов, используемый в большинстве
		браузеров, не учитывает эти "специальные" символы.
		Чтобы исправить это, укажите кодировку UTF-8, добавив элемент &lt;meta&gt; с
		атрибутом charset в &lt;head&gt; нашего файла misc/extras.html:
</p><p class="code">
&lt;meta charset='UTF-8'/&gt;
</p><p>
    Теперь все "специальные символы" должны отображаться корректно.
		В наши дни UTF-8 является чем-то вроде универсального алфавита.
		Каждая создаваемая вами веб-страница должна содержать эту строку в &lt;head&gt;.
</p>

<div class="title" id="entities">HTML-сущности<br>html entities</div>
<p>
    Эта секция не имеет никакого отношения к ссылкам и картинкам.
		И все же, прежде чем перейти к CSS, необходимо упомянуть еще одну вещь.
		Речь идет о "сущностях" [HTML entities].
		HTML сущность - это специальный символ, который не может быть представлен в
		виде обычного текста в HTML-документе.
		Обычно это означает либо то, что этот символ зарезервирован в HTML, либо то,
		что отсутствует такая клавиша на вашей клавиатуре.
</p>

<div class="title-under">ЗАРЕЗЕРВИРОВАННЫЕ СИМВОЛЫ<br>reserved characters</div>
<p>
    Символы <, > и & называются "зарезервированные (специальные) символы",
		поскольку их нельзя вставлять в HTML-документ без кодирования.
		Это происходит потому, что они что-либо означают в синтаксисе HTML:
		"<" начинает новый тег, ">" заканчивает тег, а знак амперсанта "&" задает в HTML
		какую-либо сущность.
</p><p>
    В файл misc/extras.html добавьте следующее:
</p><p class="code">
&lt;h2&gt;HTML Entities&lt;/h2&gt;<br>
&lt;p&gt;There are three reserved characters in HTML: &amp;lt; &amp;gt; and &amp;amp;. You<br>
	  should always use HTML entities for these three characters.&lt;/p&gt;
</p><p>
    Сущности всегда начинаются с амперса́нда (&) и заканчиваются точкой с запятой (;).
		Между ними вы помещаете специальный код, который ваш браузер будет интерпретировать
		как символ.
		В данном случае он интерпретирует lt, gt и amp как символы "меньше", "больше"
		и "амперсанд", соответственно.
</p><p>
    Существует бесчисленное множество сущностей HTML.
		Если интересно, большинство из них найдете <a href="https://dev.w3.org/html5/html-author/charref">
		на этом сайте</a>.
</p>

<div class="title-under">КАВЫЧКИ<br>QUOTES</div>
<p>
    Изогнутые кавычки* ни в коем случае не являются необходимыми, но если Вы
		заботитесь о типографике, то они будут одними из наиболее часто используемых
		вами элементов HTML.
		Существует четыре различных вида изогнутых кавычек (открывающие и закрывающие
		одиночные и двойные кавычки):
</p><ul>
<li>&amp;ldquo; [отображается как &ldquo;]</li>
<li>&amp;rdquo; [&rdquo;]</li>
<li>&amp;lsquo; [&lsquo;]</li>
<li>&amp;rsquo; [&rsquo;]</li>
</ul><p class="notetran">
    * - "Изогнутые кавычки" (в оригинале сurly quotes) википедия называет
		"английские двойные" и "английские одиночные".
		Используемые компьютером "прямые" кавычки соответствуют
		ивритским кавычкам (мерхао́т кфуло́т).
		См. https://ru.wikipedia.org/wiki/Кавычки
</p><p>
    Изогнутые кавычки можно использовать их вместо прямых кавычек ' и ".
		Например, вот так:
</p><p class="code">
&lt;p&gt;If you&rsquo;re into &ldquo;web typography,&rdquo; you&rsquo;ll also find
<br>
yourself using curly quotes quite a bit.&lt;/p&gt;
</p><p>
    В отличие от прямых кавычек, эти изогнутые кавычки должны обхватывать текст.
</p>

<div class="title-under">UTF-8 И HTML-СУЩНОСТИ<br>utf-8 and html entities</div>
<p>
    В былые времена Интернета в HTML-файлах не разрешалось вставлять
		специальные символы, что делало сущности гораздо более полезными.
		Но поскольку сейчас мы используем набор символов UTF-8, мы должны иметь возможность
    вставлять любые символы непосредственно в HTML-документ.
		Это делает сущности в основном полезными в качестве зарезервированных символов
		или для удобства при создании стандартного HTML.
</p>

<div class="title">резюме</div>

<p>
    По сути, вебсайт - это просто набор связанных между собой HTML, картинок и
		CSS-файлов.
		Темой "CSS" мы займемся уже на следующем уроке.
		Попробуйте начать думать о сайте как об удобной навигации пользователей по
		папкам и файлам, которые мы создаем в процессе веб-разработки.
		С такой точки зрения должно быть понятно, что поддержание хорошо организованной
		файловой системы является важнейшим аспектом создания вебсайта.
</p><p>
    Мы также узнали о важных атрибутах lang и charset, которые дают базовый
		шаблон.
		Используйте его в начале каждой создаваемой вами веб-страницы:
</p><p class="code">
&lt;!DOCTYPE html&gt;<br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title>Some Web Page&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
&lt;h1&gt;Некая вебстраница&lt;/h1&gt;<br>
<span class="code-grey">
&lt;!-- Здесь помещается все остальное содержимое --&gt;
</span><br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Все таки еще не хватает одной очень серьезной составляющей: CSS.
		На следующем уроке мы изучим атрибуты HTML, позволяющие подключать стили CSS
		к всему нашему сайту.
		Возможность работать с несколькими файлами и связывать их друг с другом "умным"
		способом станет еще более значимой, чем это было на сегодняшнем уроке.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>ПРИВЕТ, CSS</h2>
<p>УРОК Nº 4.</p>
<p><em>
    Самый понятный учебник по созданию более привлекательных вебсайтов
</em></p>

<p>
    Первые несколько глав этого учебника были посвящены исключительно HTML.
		Теперь пришло время сделать все (типа) красивым.
		В этом нам помогут каскадные таблицы стилей - CSS.
		Можно считать, что CSS определяет "дизайн" веб-страницы.
		CSS определяет такие параметры, как размер шрифта, поля и цвета, используя язык,
		совершенно не похожий на HTML.
</p><p>
    Почему это отдельный язык?
		Потому что он служит совершенно иным целям.
		HTML представляет собой содержимое веб-страницы, а CSS определяет, как это
		содержимое будет представлено пользователю.
		Это фундаментальное различие, являющееся основой современной веб-разработки.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-01-css-vs-html-f4fdfa.0a26cc8e.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 1: эскиз (mockup) превращается в CSS, а исходный текст (raw content)
		- в HTML-разметку (html markup).
		И CSS, и HTML превращаются в веб-страницу (web-page).
</figcaption>
</figure>

<p>
    CSS содержит терминологию, командующую браузеру что-нибудь вроде такого:
		"Я хочу, чтобы мои заголовки были очень большими, а боковая панель располагалась
		слева от основной статьи".
		HTML не имеет терминологии для подобных указаний по компоновке.
		Все, что HTML может сказать браузеру:
		"это заголовок, а это боковая панель".
</p><p>
    На этом уроке мы рассмотрим базовый синтаксис CSS, а также способы его подключения
		к нашим HTML-документам.
		Цель урока состоит не в том, чтобы стать экспертом по CSS или запомнить все
		доступные стили, а в том, чтобы понять, как взаимодействуют CSS и HTML.
		CSS обычно хранится в собственном файле, поэтому, как и в <a href="iih03-links-and-images.html">
		предыдущей главе</a>, правильная организация файлов играет первостепенную роль.
</p>

<div class="title">подготовка<br>setup</div>
<p>
    Для простоты мы будем хранить примеры каждого урока этого учебника в отдельной папке.
		Используя <a href="iih01-intro.html#atom">Atom</a>, создайте новый проект hello-css.
		Мы будем стилизовать страницу hello-css.html, поэтому создайте
		ее и добавьте следующую разметку:
</p><p class="code">
&lt;!DOCTYPE html&gt;<br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Hello, CSS&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
&lt;h1&gt;Hello, CSS&lt;/h1&gt;<br>
<br>
&lt;p&gt;CSS lets us style HTML elements. There’s also<br>
&lt;a href='dummy.html'>another page&lt;/a&gt; associated with this example.&lt;/p&gt;<br>
<br>
&lt;h2&gt;List Styles&lt;/h2&gt;<br>
<br>
&lt;p&gt;You can style unordered lists with the following bullets:&lt;/p&gt;<br>
<br>
&lt;ul&gt;<br>
&lt;li&gt;disc&lt;/li&gt;<br>
&lt;li&gt;circle&lt;/li&gt;<br>
&lt;li&gt;square&lt;/li&gt;<br>
&lt;/ul&gt;<br>
<br>
&lt;p&gt;And you can number ordered lists with the following:&lt;/p&gt;<br>
<br>
&lt;ol&gt;<br>
&lt;li&gt;decimal&lt;/li&gt;<br>
&lt;li&gt;lower-roman&lt;/li&gt;<br>
&lt;li&gt;upper-roman&lt;/li&gt;<br>
&lt;li&gt;lower-alpha&lt;/li&gt;<br>
&lt;li&gt;upper-alpha&lt;/li&gt;<br>
&lt;li&gt;(and many more!)&lt;/li&gt;<br>
&lt;/ol&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Еше нам понадобится страница-болванка для изучения того,
		как стили CSS применяются к нескольким веб-страницам.
		Создайте файл dummy.html и добавьте в него следующее:
</p><p class="code">
	&lt;!DOCTYPE html&gt;<br>
	&lt;html lang='en'&gt;<br>
	&lt;head&gt;<br>
	&lt;meta charset='UTF-8'/&gt;<br>
	&lt;title&gt;Dummy&lt;/title&gt;<br>
	&lt;/head&gt;<br>
	&lt;body&gt;<br>
	&lt;h1&gt;Dummy&lt;/h1&gt;<br>
	<br>
&lt;p&gt;This is a dummy page that helps us demonstrate reusable CSS<br>
	       stylesheets. &lt;a href='hello-css.html'&gt;Go back&lt;/a&gt;.&lt;/p&gt;<br>
<br>
&lt;p&gt;Want to try crossing out an &lt;a href='nowhere.html'>obsolete link&lt;/a&gt;? This<br>
	       is your chance!&lt;/p&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p>

<div class="title">таблицы стилей<br>css stylesheets</div>

<p>
    Таблицы стилей CSS находятся в текстовых файлах с расширением .css.
		Создайте новый файл styles.css в папке hello-css.
		В нем будут храниться все наши примеры фрагментов для этой главы.
		Добавим одно правило CSS, чтобы можно было определить, правильно ли подключена
		наша таблица стилей к HTML-страницам.
</p><p class="code">
<span class="code-strong">body</span> {<br>
<span class="code-green">color</span>: #FF0000;<br>
}
</p><p>
    CSS-правило всегда начинается с "селектора", определяющего, к каким
		HTML-элементам оно применяется.
		В данном случае мы пытаемся придать стиль элементу &lt;body&gt;.
		После селектора находится заключенный в фигурные скобки "блок деклараций".
		Все "свойства", которые мы там зададим, будут влиять на элемент &lt;body&gt;.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-02-css-rule-terminology-1a7961.eaaa292a.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 2: CSS-правило (Rule), состоящее из селектора и ряда пар
		"свойство-значение" (property-value)
</figcaption>
</figure>

<p>
    color - это встроенное свойство, определенное спецификацией CSS и определяющее
		цвет текста выбранных HTML-элементов.
		Оно принимает шестнадцатеричное значение, представляющее цвет.
		#FF0000 означает ярко-красный цвет.
</p><p>
    В свойствах CSS (как и в <a href="iih03-links-and-images.html#links">
		атрибутах HTML</a>), используются пары "ключ-значение".
		Только в CSS мы определяем <em>внешний вид</em>, в то время как HTML задает
<em>семантический смысл</em> основного контента.
</p>

<div class="title" id="linking-a-css-stylesheet">
    подключение таблицы стилей css<br>linking a css stylesheet</div>
<p>
    Если вы попробуете загрузить одну из HTML-страниц в браузер, то не увидите
		нашу таблицу стилей в действии.
		Это потому, что мы еще не связали их между собой.
		Для этого предназначен элемент HTML &lt;link/&gt;.
		В файле hello-css.html изменим &lt;head&gt; на такой:
</p><p class="code">
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Hello, CSS&lt;/title&gt;<br>
&lt;link rel='stylesheet' href='styles.css'/&gt;<br>
&lt;/head&gt;
</p><p>
    Элемент &lt;link/&gt; указывает браузеру, что при отображении нашей страницы hello-css.html
		нужно загрузить файл styles.css.
		Теперь весь текст на странице должен стать красным:
</p>

<figure>
<img class="pic-pages" src="./images/iih04-03-linking-a-css-stylesheet-572fd1.b1fa0928.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 3: веб-страница с красным текстом из-за селектора body
</figcaption>
</figure>

<p>
    Элемент &lt;link/&gt; - это такой же элемент, как и &lt;a&gt;, но он используется
		только внутри &lt;head&gt;.
		Находясь в голове документа, &lt;link/&gt; подключается к <em>метаданным</em>,
		определенным за пределами данного документа.
		Также обратите внимание, что &lt;link/&gt; это <a href="iih02-basic-web-pages.html#empty-html-elements">
		пустой элемент</a>.
		Поэтому ему не нужен закрывающий тег.
</p><p>
    Атрибут rel устанавливает связь между ресурсом и HTML-документом.
		Наиболее распространенное значение - stylesheet, но есть и <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">
		несколько других вариантов</a>.
		Атрибут href работает так же, как рассказано на предыдущем уроке, только
		он должен указывать на файл .css, а не на другую веб-страницу.
		Значение href может быть <a href="iih03-links-and-images.html#absolute-relative-and-root-relative-links">
		абсолютной, относительной или корневой ссылкой</a>.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-04-link-element-1beb38.2e70f24e.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 4: HTML-элемент &lt;link&gt; отсылает браузер к таблице стилей CSS
</figcaption>
</figure>

<p>
    Обратите внимание на отсутствие <em>прямой</em> связи между браузером и нашей таблицей CSS.
		Браузер может найти ее только через HTML-разметку.
		Картинки, CSS, и даже JavaScript - все они находятся на HTML-странице, которая
		"склеивает" все это вместе.
		Поэтому HTML-страница является сердцевиной большинства веб-сайтов.
</p>

<div class="title">комментарии css<br>css comments</div>
 <p>
    Теперь, когда наша таблица стилей подключена, давайте немного поиграем с ней.
		Этот красный цвет просто ужасен.
		Давайте сменим тон на приятный глазу серый:
</p><p class="code">
body {<br>
	  color: #414141; <span class="code-grey">/* Темно-серый */</span><br>
}
</p><p>
    Обратите внимание, что комментарии в CSS отличаются от комментариев в HTML.
		Вместо синтаксиса &lt;!-- --&gt; в CSS игнорируется все, что находится между
		символами /* и */.
</p>

<div class="title">Установка нескольких свойств<br>setting multiple properties</div>
<p>
    В блок деклараций CSS можно поместить сколько угодно свойств.
		Попробуем задать цвет фона всей веб-страницы, изменив наше правило на следующее:
</p><p class="code">
body {<br>
color: #414141; <span class="code-grey">/* Темно-серый */</span><br>
background-color: #EEEEEE;<span class="code-grey">/* Светло-серый */</span><br>
}
</p><p>
    Свойство background-color очень похоже на свойство color, но оно определяет
		цвет фона для любого выбранного элемента.
		Обратите внимание на точки с запятой в конце каждого объявления.
		Их удаление приведет к нарушению правила CSS, поэтому <em>всегда ставьте точки
		с запятой</em>!
</p><p>
    Почему мы выбрали оттенки серого, а не черно-белый?
		Использование фона #000000 с цветом текста #FFFFFF дает слишком высокий контраст.
		Создается впечатление, что страница как-бы вибрирует, что может сильно
		отвлекать читателя.
</p>

<div class="title">выбор различных элементов<br>selecting different elements</div>
<p>
    Само собой, вы захотите применить стили к элементам, отличным от &lt;body&gt;.
		Для этого просто добавьте дополнительные правила CSS с различными селекторами.
		Например, измените размер шрифта заголовков &lt;h1&gt;:
</p><p class="code">
body {<br>
color: #414141; <span class="code-grey">/* Dark gray */</span><br>
background-color: #EEEEEE;<span class="code-grey">/* Dark gray */</span><br>
}<br>
<br>
h1 {<br>
  font-size: 36px;<br>
}
</p><p>
    А для изменения размера заголовков h2 добавьте другое правило:
</p><p class="code">
	h2 {<br>
	  font-size: 28px;<br>
	}
</p>

<div class="title" id="units-of-measurement">единицы измерения<br>units of measurement</div>
<p>
    Многие свойства CSS требуют указания единиц измерения.
		Существует <a href="https://developer.mozilla.org/ru/docs/Web/CSS/length">
		множество единиц измерения</a>, но наиболее часто встречающиеся - px (пиксель)
		и em (произносится как "эм").
		Первое - это то, что вы интуитивно называете пикселем, независимо от того,
		есть ли у пользователя дисплей retina или нет.
		А второе - это текущий размер шрифта рассматриваемого элемента.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-05-em-units-dad09a.721071a6.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 5: размеры 1em, 1.6em и 2em для основных размеров шрифта 12px, 16px
		и 20px.
		Размеры em становятся больше по мере увеличения основного размера шрифта.
</figcaption>
</figure>

<p>
    Единица em очень удобна для определения размеров относительно некоторого
		основного шрифта.
		На скриншоте выше показано масштабирование единиц em для соответствия
		основным размерам шрифта 12px, 16px и 20px.
		Конкретным примером является следующий вариант предыдущего кода:
</p><p class="code">
	body {<br>
	color: #414141; <span class="code-grey">/* Dark gray */</span><br>
	background-color: #EEEEEE;<span class="code-grey">/* Dark gray */</span><br>
font-size: 18px;<br>
	}<br>
	<br>
	h1 {<br>
	  font-size: 2em;<br>
	}<br>
<br>
	h2 {<br>
		font-size: 1.6em;<br>
	}
</p><p>
    Сначала задаем основной размер шрифта документа - 18px.
		Тогда наши &lt;h1&gt; будут быть в два раза больше, а наши &lt;h2&gt; - в 1,6 раза.
		Если захотите уменьшить или увеличить базовый, единицы em позволят
		соответственно масштабировать всю страницу.
</p>

<div class="title">выбор нескольких элементов<br>selecting different elements</div>
<p>
    А если мы решим добавить некоторые стили ко <em>всем</em> заголовкам?
		Мы же не хотим иметь множество почти одинаковых правил, поскольку это в итоге
		превратится в кошмар для техподдержки:
</p><p class="code">
<span class="code-grey">/*  (Вы сильно пожалеете о создании таких вот дублирующихся
стилей) */</span><br>
h1 {<br>
font-family: "Helvetica", "Arial", sans-serif;<br>
}<br>
<br>
h2 {<br>
font-family: "Helvetica", "Arial", sans-serif;<br>
}<br>
<br>
h3 {<br>
font-family: "Helvetica", "Arial", sans-serif;<br>
}<br>
<br>
	<span class="code-grey">/* (и так далее) */</span>
</p><p>
	  Вместо этого мы можем выделить несколько HTML-элементов в одном CSS-правиле,
		разделив их запятыми. Добавьте это правило в наш файл styles.css:
<p class="code">
<span class="code-strong">h1, h2, h3, h4, h5, h6</span> {<br>
<span class="code-green">font-family</span>: <span class="code-rust">"Helvetica", "Arial"</span>, sans-serif;<br>
}
</p><p>
    С помощью одного правила мы зададим шрифт для всех наших заголовков.
		Это здорово.
		Ведь если мы захотим сделать правки, мы сделаем это
		только в одном месте.
		Копировать и вставлять код - плохая идея для разработчиков, а "множественные
		селекторы" [multiple selectors] позволяют значительно сократить количество
		подобных действий.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-06-heading-font-families-68964e.ef89d6e4.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 6: веб-страница с заголовками &lt;h1&gt; и &lt;h2&gt; набраными разными шрифтами
</figcaption>
</figure>

<div class="title-under" id="defining-fonts">ВЫБОР ШРИФТОВ<br>defining fonts</div>
<p>
    font-family - еще одно встроенное CSS-свойство, определяющее шрифт для
		выбранного элемента.
		Оно принимает несколько значений, поскольку не у всех пользователей установлены
		одинаковые шрифты.
		На скоиншоте браузер сначала пытается загрузить самый левый шрифт
		(Helvetica), затем переходит к Arial, если у пользователя его нет, и наконец,
		выбирает шрифт без засечек, встроенный в систему sans serif.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-07-system-fonts-6a5c38.859004c6.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 7: Helvetica, переходящая в Arial, переходящая в шрифт без засечек
</figcaption>
</figure>

<p>
    Исторически сложилось так, что встроенные в систему шрифты ограничивают
		возможности веб-дизайнеров.
		Сегодня системные шрифты в значительной степени вытеснены веб-шрифтами.
		Подробнее об этом можно прочитать в главе <a href="iih14-web-typography.html">
		Веб-типографика</a>.
</p>

<div class="title">стили списка<br>list styles</div>
<p>
    Свойство list-style-type позволяет изменять маркет "пульки", используемый
		для элементов &lt;li&gt;.
		Как правило, его нужно задавать для родительского элемента &lt;ul&gt; или &lt;ol&gt;:
</p><p class="code">
	ul {<br>
	  list-style-type: circle;<br>
	}<br>
<br>
	ol {<br>
	  list-style-type: lower-roman;<br>
	}
</p><p>
    Другие распространенные значения можно найти на hello-css.html.
		Особо интересно значение none, обычно используемое для разметки
		навигационного меню с помощью списка &lt;ul&gt;.
		Значение none позволяет стилизовать элементы списка меню под кнопки.
		В главе <a href="iih09-advanced-positioning.html">Продвинутое позиционирование</a>
		мы используем этот прием для создания навигационного меню, показанного ниже.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-08-list-items-for-menus-70abb2.2b19ebae.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 8: веб-страница с элементами &lt;ul&gt; и &lt;li&gt; без маркеров
		элементов списка (bullets)
</figcaption>
</figure>

<p>
    Это хороший пример разделения контента и внешнего вида.
		Навигационное меню - <em>есть</em> неупорядоченный список, но в данном случае имеет смысл
		отображать его в виде кнопок, а не в виде обычного маркированного списка.
		Грамотно разработанный HTML позволяет поисковым системам делать выводы о
		структуре нашего содержимого, а CSS - красиво отображать его для людей.
</p><p>
    Можно даже создавать собственные маркеры списка для элементов &lt;li&gt; с
		помощью свойства list-style-image (см. <a href="https://developer.mozilla.org/ru/docs/Web/CSS/list-style-image">
		соответствующую статью</a> в MDN).
</p><p>
    Определение цвета текста и внешнего вида списка может показаться мелочью.
		И вообщем так оно и есть.
		Но взгляните на картину в целом: речь идет о получении <em>полного</em> контроля
		над внешним видом HTML-документа.
		Отдельное свойство CSS - да, это мелочь.
		Но соберите все CSS-свойства вместе, и у вас получится уникальная веб-страница.
</p>

<div class="title">Таблицы стилей многократного использования<br>reusable stylesheets</div>
<p>
    Итак, мы определили несколько основных стилей для одной из наших веб-страниц.
		Было бы очень удобно, если бы мы могли повторно использовать их и на другой
		странице.
		Для этого достаточно добавить тот же элемент &lt;link/&gt; на все остальные
		страницы, которые мы хотим стилизовать.
		Добавьте в &lt;head&gt; файла dummy.html следующую строку:
</p><p class="code">
&lt;link rel='stylesheet' href='styles.css'/&gt;
</p><p>
    Теперь наши страницы dummy.html должны отвечать стилям hello-css.html.
		При изменении стиля в styles.css эти изменения будут автоматически отражаться
		на каждой из наших веб-страниц.
		Таким образом достигается единый внешний вид и восприятие всего сайта.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-09-reusable-css-stylesheets-43a99a.5322b89d.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 9: таблица стилей (global CSS stylesheet), связанная с тремя HTML-файлами
</figcaption>
</figure>

<p>
    Почти всегда используется хотя бы одна таблица стилей, применяемая ко всему сайту.
		Подключать таблицы стилей обычно рекомендуется через <a href="https://internetingishard.netlify.app/html-and-css/links-and-images/#root-relative-links">
		корневые ссылки</a>.
		Это поможет избежать проблем на вложенных страницах.
		Например, в some-folder/page.html для ссылки на наш файл styles.css
		следует использовать ../styles.css.
    Но это может быстро привести к путанице.
</p>

<div class="title" id="more-text-styles">дополнительные стили текста<br>more text styles
</div>
 <p>
    Данный курс познакомит вас с множеством существующих различных CSS-свойств.
		А пока что закончим с некоторыми наиболее распространенными способами
		форматирования текста.
</p>

<div class="title-under">ПОДЧЕРКИВАНИЯ<br>UNDERLINES</div>
<p>
    Подчеркивание текста задается свойством text-decoration.
		Установив значение none, можно убрать стандартное подчеркивание из всех
		наших ссылок.
		Подробнее о стилях ссылок мы <a href="iih06-css-selectors.html#pseudo-classes-for-links">
		поговорим позже</a>.
</p><p class="code">
	a {<br>
	  text-decoration: none;<br>
	}
</p><p>
    Другим распространенным значением для text-decoration является line-through,
		которое зачеркивает "удаленный" текст.
		Но помните, что <em>смысл</em> всегда должен передаваться с помощью HTML,
		а не CSS.
		Лучше использовать элементы <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/ins">
&lt;ins&gt;</a> и <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/del">
&lt;del&gt;</a>, вместо добавления стиля line-through, например, к элементу
&lt;p&gt;.
</p>

<div class="title-under" id="text-alignment">ВЫРАВНИВАНИЕ ТЕКСТА<br>TEXT ALIGNMENT</div>
<p>
    Метко названное свойство text-align* определяет выравнивание текста в HTML-элементе.
</p><p class="notetran">
    * - align по-английски: "выравнивать".
</p><p class="code">
p {<br>
text-align: left;<br>
}
</p><p>
    Другие допустимые значения: right, center или justify.
		Обратите внимание, что текст всегда выравнивается по всей странице:
</p>

<figure>
<img class="pic-pages" src="./images/iih04-10-css-text-align-right-3c6a95.b44147f0.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 10: веб-страница с текстом, выровненным по правому краю
</figcaption>
</figure>

<p>
    Но это не совсем то, что нужно для большинства сайтов.
		Почему? Узнаете на <a href="./iih05-css-box-model.html">
		следующем уроке</a>, когда речь пойдет о CSS-блоках.
</p>

<div class="title-under">НАЧЕРТАНИЕ ШРИФТОВ И ИХ СТИЛИ<br>FONT WEIGHT AND STYLES</div>
<p>
    Свойство font-weight определяет "жирность" текста в элементе, а свойство
		font-style указывает, является ли он курсивным или нет.
</p><p>
    Давайте предположим, что мы не хотим, чтобы наши заголовки были жирными.
		Обновим правило шрифта заголовков в styles.css следующим образом:
</p><p class="code">
h1, h2, h3, h4, h5, h6 {<br>
font-family: "Helvetica", "Arial", sans-serif;<br>
font-weight: normal; <span class="code-grey">/* Добавьте эту строку */</span><br>
}
</p><p>
    Эти свойства наглядно демонстрируют разделение содержания (HTML) и
		внешнего вида (CSS).
		Следующие правила изменяют внешний вид элементов &lt;em&gt; и &lt;strong&gt;:
</p><p class="code">
<span class="code-grey">/* Пожалуй, не стоит этого делать */</span><br>
em {<br>
  font-weight: bold;<br>
  font-style: normal;<br>
}<br>
<br>
strong {<br>
  font-weight: normal;<br>
  font-style: italic;<br>
}
</p><p>
    Однако мы не советуем делать это для реальных сайтов.
		Стили шрифтов это довольно важная тема.
		Мы углубимся в нее на уроке <a href="iih14-web-typography.html">
		Веб-типографика.</a>
</p>

<div class="title" id="cascade">
    КАСКАДНОСТЬ<br>the cascade</div>

<p>
    В CSS правила "каскадируются" (передаются) из нескольких источников.
		До сих пор мы видели только одно место, где CSS может быть определен:
		внешние .css-файлы.
		Однако внешние таблицы стилей - это лишь одно из многих мест, куда можно
		поместить CSS-код.
</p><p>
    Иерархия CSS для каждой веб-страницы выглядит следующим образом:
</p><p>
<ul>
<li>Таблица стилей браузера по умолчанию</li>
<li>Установленные пользователем таблицы стилей</li>
<li>Внешние таблицы стилей (это мы)</li>
<li>Стили для конкретной страницы (это тоже мы)</li>
<li>Встроенные стили (это можем быть мы, но лучше этого не делать).</li>
</ul>
</p><p>
    Порядок следования - от наименьшего к наибольшему.
		То есть стили, определенные на каждом последующем шаге, <em>отменяют</em> предыдущие.
		Так, встроенные стили всегда будут заставлять браузер игнорировать стили по умолчанию.
		Следующие несколько разделов будут посвящены последним двум вариантам,
		поскольку именно их мы можем контролировать как веб-разработчики
		(в дополнение к внешним стилям, с которыми мы уже начали работать).
</p>

<figure>
<img class="pic-pages" src="./images/iih04-11-css-cascade-0755f2.1b937115.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 11: внешняя таблица стилей, указывающая на внутренние
		стили, указывающие на встроенные стили
</figcaption>
</figure>

<p>
    Мы постарались помочь вам с самого начала найти верный подход к работе с
		внешними стилями.
		Понимание page-specific и inline стилей очень важно, поскольку вы
		наверняка столкнетесь с ними в дальнейшей работе.
		Но внешние стили - это, безусловно, лучшее место для настройки внешнего вида
		вашего сайта.
</p>

<div class="title-under" id="page-specific-styles">ВНУТРЕННИЕ СТИЛИ<br>PAGE-SPECIFIC*</div>
<!--
	1. Встроенный стиль [Inline CSS] <p style="color: red; font-size: 18px;">
	2. Внутренний (тж. внедренный / глобальный) стиль [Internal CSS] <style></style>
	3. Внешний стиль [External CSS] <link rel="stylesheet" href="styles.css">
-->
<p>
    Элемент &lt;style&gt; используется для добавления в отдельные HTML-документы
		соответствующих страниц CSS-правил.
		Элемент &lt;style&gt; всегда находится в &lt;head&gt; веб-страницы, что логично,
		поскольку он представляет метаданные, а не контент как таковой.
</p><p class="notetran">
    * - Page-Specific - "стили для конкретной страницы".
		Другое название Internal, так. наз. "внутреннее" подключение стилей.
		В Рунете встречаются также названия "глобальный" или "внедренный" вид подключения.
</p><p>
    В качестве примера зададим некоторые стили для нашей страницы dummy.html,
		изменив ее элемент &lt;head&gt; следующим образом:
</p><p class="code">
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Dummy&lt;/title&gt;<br>
&lt;link rel='stylesheet' href='styles.css'/&gt;<br>
&lt;style&gt;<br>
<span class="code-strong">body</span> {<br>
<span class="code-green">color</span>: #0000FF;    /* Синий */<br>
}<br>
&lt;/style&gt;<br>
&lt;/head&gt;
</p><p>
    Итак, эти стили будут применяться <em>только</em> для dummy.html.
		На hello-css.html они не повлияют.
		Если вы все сделали правильно, то при загрузке dummy.html в браузере вы
		текст должен стать синим.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-12-page-specific-css-styles-example-99d6c8.e1627bd2.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 12: синий текст вследствие внутреннего (page-specific / internal)
		подключения таблицы CSS к конкретной странице
</figcaption>
</figure>

<p>
    В элемент &lt;style&gt; можно поместить все, что и наш элемент styles.css.
		Он использует точно такой же синтаксис, что и styles.css,
		но все внутри &lt;style&gt; будет <em>переопределять</em> правила из
		styles.css.
		В нашем случае мы приказываем браузеру игнорировать свойство color, определенное
		для &lt;body&gt; в styles.css.
		Новое свойство color: #0000FF; заменяет свойство color из styles.css.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-13-page-specific-css-styles-c6b688.605c6018.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 13: три CSS-правила с внутренним (page-specific / internal) подключением
		в трех различных HTML-документах
</figcaption>
</figure>

<p>
   Проблема внутренних стилей в том, что их крайне сложно обслуживать.
	 Для применения этих стилей на другой HTML-странице необходимо скопировать и
	 вставить их в раздел &lt;head&gt; HTML-кода другой страницы (см. скриншот выше).
	 Отслеживать излишние CSS-правила в нескольких .html-файлах много сложнее
	 редактирования всего одого файла .css.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-14-external-css-styles-b073ea.58f27dbe.png"
width="65%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 14: три веб-страницы, относящихся к одной глобальной таблице стилей CSS
</figcaption>
</figure>

<p>
    Внутренние стили иногда имеют смысл для быстрых изменений внешнего вида
		конкретной страницы.
		И все-же мы не рекомендуем помещать CSS код внутрь элемента &lt;style&gt;.
		Вместо этого, много лучше подключать внешнюю таблицу стилей styles.css.
</p>

<div class="title-under" id="inline-styles">ВСТРОЕННЫЕ СТИЛИ<br>INLINE STYLES</div>
<p>
    Правила CSS можно также поместить в атрибут style HTML-элемента.
		В файле dummy.html у нас есть ссылка, которая никуда не ведет.
		Давайте сделаем ее красной с помощью встроенного стиля, чтобы мы помнили,
		что это неработающая ссылка:
</p><p class="code">
<span class="code-blue">&lt;p&gt;</span>Want to try crossing out an <span class="code-blue">&lt;a href=</span><span class="code-rust">'nowhere.html'</span><br>
<span class="code-blue">style=</span><span class="code-rust">'color: #990000; text-decoration: line-through;'</span><span class="code-blue">&gt;</span>obsolete link<span class="code-blue">&lt;/a&gt;</span>?<br>
This is your chance!<span class="code-blue">&lt;/p&gt;</span>
</p><p>
    Как и в случае с внутренними стилями, используется тот же синтаксис CSS,
		с которым мы уже работали.
		Однако, поскольку он находится в атрибуте, его необходимо сжать до одной строки.
		Встроенные стили - это самое конкретное определение CSS.
    Определенные при этом свойства color и text-decoration имеют <em>наивысший</em>
		приоритет.
		Даже добавив в элемент &lt;style&gt; некое правило типа text-decoration: none,
		это не даст никакого эффекта.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-15-inline-css-styles-are-bad-73261b.5ecc415e.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 15: 10 правил CSS, подключенных напрямую к 10 различным HTML-элементам
		с помощью встроенных стилей
</figcaption>
</figure>

<p>
    Избегайте внутренние стили любой ценой.
		Одна из причин - их вышеупомянутый приоритет.
		Изменить стиль страницы из внешнего CSS файла будет невозможно.
		Если вы захотите изменить стиль своего сайта, будет недостаточно просто изменить
		несколько правил в файле styles.css.
		Придется исправлять и обновлять каждый элемент HTML, имеющий атрибут style.
		Это приводит в ужас.
</p><p>
    Впрочем, иногда необходимо применить стили только к конкретному элементу HTML.
		Для этого всегда следует использовать классы CSS, а не встроенные стили.
		Классы мы рассмотрим на уроке <a href="iih06-css-selectors.html">
		Селекторы CSS</a>.
</p>

<div class="title-under">НЕСКОЛЬКО ТАБЛИЦ СТИЛЕЙ<br>multiple stylesheets</div>
<p>
    Правила CSS можно распределять по нескольким внешним таблицам стилей, просто
		добавляя несколько элементов &lt;link/&gt; на одну и ту же страницу.
		Часто используется разделение стилей для различных разделов сайта.
		Это позволяет выборочно применять согласованные стили к различным категориям
		веб-страниц.
</p><p>
    Представим, что у нас есть куча страниц с товарами, выглядящими иначе, чем
		страница блога.
		Тогда мы могли бы использовать следующий код
		(но на самом деле эти таблицы стилей у нас не определены, поэтому не добавляйте
		их в наш пример):
</p><p class="code">
<span class="code-grey">
&lt;!-- (Все сайты с продуктами имеют такой код) --&gt;
</span><br>
&lt;head&gt;<br>
&lt;link rel='stylesheet' href='styles.css'/&gt;<br>
&lt;link rel='stylesheet' href='product.css'/&gt;<br>
&lt;/head&gt;
</p><p class="code">
<span class="code-grey">
&lt;!-- (Все статьи блога имеют такой код) --&gt;
</span><br>
&lt;head&gt;<br>
&lt;link rel='stylesheet' href='styles.css'/&gt;<br>
&lt;link rel='stylesheet' href='blog.css'/&gt;<br>
&lt;/head&gt;
</p><p>
    Порядок следования элементов &lt;link/&gt; имеет особое значение.
		Таблицы стилей, созданные позднее, будут переопределять, то есть преобладать
		над стилями, созданными ранее.
		Обычно "базовые" стили или стили "по умолчанию" (default) помещаются в одну
		таблицу стилей (styles.css) и дополняются таблицами стилей для конкретных
		разделов (напр. product.css и blog.css).
		Это позволяет организовать CSS-правила в управляемых файлах, избегая опасностей,
		связанных со спецификой страниц и встроенными стилями.
</p>

<div class="title">РЕЗЮМЕ</div>
<p>
    На этом уроке мы много говорили о разделении содержания и внешнего вида.
		Это позволяет использовать одну таблицу стилей CSS в нескольких HTML-документах,
		а также применять <em>различные</em> правила CSS к <em>одинаковому</em> HTML-контенту
		для смартфонов, планшетов и ноутбуков/ПК.
		Эта технология называется <a href="iih10-responsive-design.html">
		Адаптивный дизайн</a>.
</p>

<figure>
<img class="pic-pages" src="./images/iih04-16-responsive-css-b7a057.952cb8fd.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption>
    Скриншот 16: единый HTML-файл с отдельными CSS-стилями для мобильных и
		настольных компьютеров
</figcaption>
</figure>

<p>
    Будучи веб-разработчиком, для работы вы получите уже готовый дизайн.
		Ваша задача - используя знания CSS, превратить его в реальную веб-страницу.
    Как говорилось ранее, настройка отдельных свойств CSS на самом деле довольно проста.
		Самое сложное - объединить огромное число встроенных свойств и создать
		именно то, что ожидает веб-дизайнер, и сделать это быстро.
</p><p>
    На этом уроке речь шла в основном о форматировании текста, но язык каскадных
		таблиц стилей способен на гораздо большее.
		На следующем уроке мы начнем изучать, как CSS определяет верстку веб-страниц.
		Напоминаем, что при возникновении вопросов о том, как работает то или иное
		свойство, всегда можно обратиться к <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Reference">
		Руководству по CSS</a> от MDN.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>БЛОКОВАЯ МОДЕЛЬ В CSS</h2>
<p>УРОК Nº 5.</p>
<p><em>
    Просто и понятно про рамки и отступы (padding, borders, margins)
</em></p>

<hr>
<p>
    На <a href="iih04-hello-css.html">предыдущем уроке</a> были представлены
		основные свойства CSS для форматирования текста, но это был лишь один из
		аспектов стилизации страниц.
		Определение разметки веб-страницы - это совершенно другое дело.
		Именно этому и посвящен данный урок.
</p><p>
    "Блоковая модель CSS" это набор правил, определяющих отображение
		в Интернете любой веб-страницы.
		CSS рассматривает каждый элемент HTML-документа как "блок" [или "бокс"]
		с кучей различных свойств, определяющих	его местоположение на странице.
		До сих пор все наши веб-страницы были просто набором элементов.
		Блоковая модель - это набор инструментов для настройки стандартной
		схемы расположения элементов.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-01-css-html-and-the-box-model-9d82a2.21d4d282.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: таблица стилей CSS, разбитая на две части (форматирование текста
		и блоковая модель)
</small></figcaption>
</figure>

<p>
    Значительная часть работы веб-разработчика - это превращения дизайнерского
		эскиза в веб-страницу посредством блоковой модели CSS.
		Возникнает вопрос - а зачем изучать все эти правила вместо того, чтобы
		просто загрузить одно большое статичное изображение веб-страницы?
		Загрузил эскиз-картинку на веб-сервер и все.
		Разве этого недостаточно?
</p><p>
    Да, это значительно упростило бы жизнь.
		Однако, если не разделять контент на HTML, поисковики не смогут определить
		структуру наших веб-страниц, не будет возможности сделать наш сайт <a href="iih10-responsive-design.html">
		адаптивным</a> и добавить шикарную анимацию или интерактивность
		с помощью JavaScript.
		Цена этого компромисса слишком высока, чтобы игнорировать использование CSS.
</p><p>
    Ниже мы рассмотрим основные компоненты блоковой модели: paddings, margins, рамки,
		inline- и блоковые блоки.
		Можно считать, что это "микро" CSS-макеты, ибо эта модель определяет специфику
		поведения блоков.
		На следующих уроках вы больше узнаете о том, как структура HTML и блоковая модель
		объединяются для создания сложных CSS-версток.
</p>

<div class="title">подготовка<br>setup</div>
<p>
    Для начала создайте новую папку css-box-model.
		Поместите туда новую веб-страницу boxes.html.
		Напишите следующий код:
</p><p class="code">
&lt;!DOCTYPE html&gt;<br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Boxes Are Easy!&lt;/title&gt;<br>
&lt;link rel='stylesheet' href='box-styles.css'/&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
&lt;h1&gt;Headings Are Block Elements&lt;/h1&gt;<br>
<br>
&lt;p&gt;Paragraphs are blocks, too. &lt;em&gt;However&lt;/em&gt;, &amp;lt;em&amp;gt; and &amp;lt;strong&amp;gt;
<br>
elements are not. They are &lt;strong&gt;inline&lt;/strong&gt; elements.&lt;/p&gt;<br>
<br>
&lt;p&gt;Block elements define the flow of the HTML document, while inline elements<br>
do not.&lt;/p&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Вы помните из урока <a href="iih04-hello-css.html">Hello, CSS</a> как HTML-файл
		ссылается на таблицу стилей CSS?
		В данном случае это файл будет box-styles.css.
		Создайте и этот файл для данного урока (пока что его можно оставить пустым).
</p><p>
    Надеемся, что вы уже освоились с особенностями работы в <a href="iih01-intro.html#atom">
		редакторе Atom</a> для создания файлов и папок.
		Если нет, то обязательно просмотрите инструкцию по использованию редактора Atom
		на вводном уроке этого учебника.
</p>

<div class="title" id="block-and-inline-elements">блоковые и строчные элементы<br>
block elements and inline elements</div>
<p>
    В разделе <em>Что нужно знать о веб-страницах</em> мы вкратце рассказали,
<a href="iih02-basic-web-pages.html#elements-italic">как CSS использует "блоки"</a>
    для разметки веб-страницы.
		Каждый отображаемый элемент HTML это блок.
		Они бывают двух видов: "блоковые*" и "строчные (inline)".
</p><p class="notetran">
    * - "блоковый блок" (block box) звучит немного неуклюже.
		И все же я сознательно не употребляю другой перевод слова box - "бокс".
		Потому что на ресурсе, на который ссылается Oliver James, автор данного учебника
		- Mozilla Developers Network (MDN), <a href="https://developer.mozilla.org/ru/docs/Learn/CSS/Building_blocks/The_box_model">
		box переводится как "блок"</a>.
</p]

<figure>
<img class="pic-pages" src="./images/iih05-02-inline-vs-block-boxes-f3e662.816f1448.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2: сравнение элементов: блоковый [block box] и строчные [inline boxes]
</small></figcaption>
</figure>

<p>
    Все элементы HTML, с которыми мы работали, по умолчанию имеют определенный
		тип блока.
		Например, &lt;h1&gt; и &lt;p&gt; - это элементы блокового уровня, а &lt;em&gt;
		и &lt;strong&gt; - inline-элементы.
		Давайте улучшим внешний вид наших блоков, добавив в box-styles.css
		следующий код:
</p><p class="code">
h1, p {<br>
<span class="code-green">background-color</span>: #DDE0E3;    /* светло-серый */ <br>
}<br>
<br>
em, strong {<br>
<span class="code-green">background-color</span>: #B2D6FF;    /* светло-голубой */<br>
}
</p><p>
	Свойство background-color заполняет только фон выбранного блока.
	Это даст нам четкое представление о структуре нашей страницы-примера.
	Наши заголовки и абзацы должны иметь светло-серый фон, а акцентирующие [italic]
	и сильные [strong] элементы - голубой.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-03-block-boxes-and-inline-boxes-7cfa0a.1ef04f8c.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: веб-страница, где блоковые блоки - серые, а строчные - голубые.
</small></figcaption>
</figure>

<p>
    Это демонстрирует нам несколько очень важных особенностей поведения,
		присущего блоковым и строчным блокам:
</p><ul>
<li><strong>
    Блоковые блоки</strong> всегда появляются <strong>ниже</strong> предшествующего
	  блокового элемента.
		Это "естественный" или "статический" поток HTML-документа, когда он отображается
		веб-браузером.
</li><li><strong>
	  Ширина блоковых блоков</strong> устанавливается автоматически на основе ширины
		их родительского контейнера.
		В этом случае ширина блоков всегда равна ширине окна браузера.
</li><li><strong>
    Стандартная высота блоковых блоков</strong> зависит от содержащегося в нем
		контента.
		Сужая окно браузера, &lt;h1&gt; разбивается на две строки, и его
		высота изменяется соответствующим образом.
</li><li><strong>
	  Inline-блоки</strong> не влияют на <strong>вертикальный интервал</strong>.
		Они предназначены для стилизации содержимого <em>внутри</em> блока
		(НЕ для определения макета!).
</li><li><strong>
    Ширина inline-блоков</strong> зависит от содержащегося в них контента
		(НЕ от ширины родительского элемента!).
</li>
</ul>

<div class="title" id="changing-box-behavior">изменяем поведение блоков<br>
changing box behavior</div>
 <p>
    Мы можем переопределить установленный по умолчанию тип box элементов HTML
		с помощью CSS-свойства display.
		К примеру, вам вдруг захотелось строчные элементы &lt;em&gt; и &lt;strong&gt;
		превратить в блоковые.
		Для этого необходимо обновить наше правило в box-styles.css таким образом:
</p><p class="code">
em, strong {<br>
<span class="code-green">background-color</span>: #B2D6FF;<br>
<span class="code-green">display</span>: block;<br>
}
</p><p>
   Теперь эти элементы действуют как наши заголовки и абзацы: они начинаются с
	 отдельной строки и заполняют всю ширину браузера.
	 Это очень удобно, когда мы хотим сделать элементы &lt;a&gt; кнопками или
	 отформатировать элементы &lt;img/&gt; (оба эти элемента по
	 умолчанию inline-блоки).
</p>

<figure>
<img class="pic-pages" src="./images/iih05-04-turning-inline-into-block-boxes-772f4c.603c149e.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: вот что происходит, когда с помощью CSS-свойства display мы из
		inline-блоков делаем блоковые блоки
</small></figcaption>
</figure>

<p>
    Однако делать &lt;em&gt; и &lt;strong&gt; блоковыми элементами - плохая идея.
		Поэтому давайте превратим их обратно в inline-блоки.
		Для этого поменяем их свойство display на inline, как показано ниже:
</p><p class="code">
em, strong {<br>
<span class="code-green">background-color</span>: #B2D6FF;<br>
<span class="code-green">display</span>: inline; <span class="code-grey">
/* em и strong строчные (inline) по умолчанию */</span>
<br>
}
</p>

<div class="title">контент, padding, рамка, margin<br>content, padding, border, and margin</div>
 <p>
    Блоковая модель CSS - это набор правил, определяющих размеры каждого элемента
		веб-страницы.
    Для каждого блока (как inline-, так и блокового), данная модель предусматривает
		четыре свойства:</p><ul>
<li><strong>
	  Content </strong> [содержимое*] - текст, картинка или другой медиаконтент,
	  содержащийся в элементе.</li>
<li><strong>
	  Padding</strong> [внутренний отступ*] - пространство между содержимым блока
		и его границей.</li>
<li><strong>
	  Border</strong> [рамка] отделяет padding от margin</li>
<li><strong>
	  Margin</strong> [внешний отступ*] - пространство между блоком и окружающими
		блоками.</li>
</ul><p>
    Все это необходимо браузеру для отображения блока какого-либо элемента.
		Контент есть "содержимое" HTML-документа.
		Из этих четырех свойств только контент несет cемантическую ценность (именно
		поэтому <a href="iih02-basic-web-pages.html#structure-vs-presentation">
	  контент находится в HTML</a>).
		Остальные три свойства отвечают за внешний вид, то есть за презентацию
		контента.
		Поэтому все три определяются правилами CSS.
</p><p class="notetran">
    * - понятия внешнего и внутреннего отступов из-за схожести легко может привести
		к путанице.
		Поэтому я решил оставить исходные англ. названия: padding и margin.
		По этой же причине, для лучшей наглядности, "содержимое" зачастую заменяется
		словом "контент".
</p>

<figure>
<img class="pic-pages" src="./images/iih05-05-css-box-model-73a525.23b2d64b.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5: блоковая модель CSS: содержимое (content), внутренний отступ (padding),
		рамка (border) и внешний отступ (margin)
</small></figcaption>
</figure>

<div class="title">внутренний отступ<br>padding</div>
<p>
    Давайте начнем изнутри.
		Мы уже рассматривали контент, теперь на очереди padding.
		Свойство padding... вы уже наверно догадались... определяет отступ для
		выбранного элемента:
</p><p class="code">
h1 {<br>
<span class="code-green">padding</span>: 50px;<br>
}
</p><p>
    Это добавляет по 50 пикселей с каждой стороны заголовка &lt;h1&gt;.
		Обратите внимание (скриншот ниже), как расширяется цвет фона, заполняя это пространство.
		Так всегда происходит с padding, поскольку он находится внутри рамки,
		а все, что находится внутри рамки, имеет фон.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-06-increasing-heading-padding-5a289d.f7902edc.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: увеличение отступов в &lt;h1&gt; (размер фона увеличился)
</small></figcaption>
</figure>

<p>
    Иногда требуется стилизовать только одну сторону элемента.
		Для этого в CSS предусмотрены следующие свойства:
</p><p class="code">
p {<br>
<span class="code-green">padding-top</span>: 20px;<br>
<span class="code-green">padding-bottom</span>: 20px;<br>
<span class="code-green">padding-left</span>: 10px;<br>
<span class="code-green">padding-right</span>: 10px;<br>
}
</p><p>
	Для изменения padding можно использовать любые единицы измерения
	(не только пиксели!).
	Помните <a href="iih04-hello-css.html#units-of-measurement">единицы em</a>?
	Они особенно удобны тем, что делают margin ваших элементов изменяющимся вместе
	с изменением размера основного шрифта.
</p>

<div class="title-under" id="shorthand-formats">СОКРАЩЕННЫЕ ФОРМАТЫ<br>
shorthand formats</div>
<p>
    Вводить все эти свойства может быть утомительно, поэтому CSS предусматривает
		альтернативную "сокращенную" форму свойства padding.
		Вы сможете задать верхний/нижний и левый/правый padding всего одной строкой CSS.
		Когда вы указываете <em>два</em> значения свойства padding, они интерпретируются как
		значения вертикального и горизонтального padding соответственно.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-07-padding-shortform-two-values-a7ed4c.ae7f23f3.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: свойство "внутренний отступ" (padding) с выделенными
		вертикальными и горизонтальными значениями
</small></figcaption>
</figure>

<p>
    Это означает, что наше предыдущее правило может быть переписано так:
</p><p class="code">
h1 {<br>
<span class="code-green">padding</span>: 20px 10px; <span class="code-grey">
/* вертикально горизонтально */</span>
<br>
}
</p><p>
    Альтернативный вариант: <em>четыре</em> значения устанавливают padding для
		каждой стороны элемента по отдельности.
		Значения идут по часовой стрелке, начиная с верхнего:
</p>

<figure>
<img class="pic-pages" src="./images/iih05-08-padding-shortform-four-values-93c021.2ee1e6b2.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: cвойство padding с разноцветными значениями верх,
		справа, низ и слева
</small></figcaption>
</figure>

<p>
    Давайте попробуем удалить 10px правого padding из предыдущего правила.
		Получится по 20 пикселей сверху и снизу каждого абзаца, 10 пикселей
		слева и ни одного справа:
</p><p class="code">
h1 {<br>
<span class="code-green">padding</span>: 20px 0 20px 10px; <span class="code-grey">
/* сверху,справа, снизу и слева */</span>
<br>
}
</p><p>
    Использовать сокращенные форматы или нет - в значительной степени вопрос
		личных предпочтений и стандартов работы в будущей команде.
		Некоторым разработчикам импонирует лаконичность сокращенного формата.
		А другие считают, что длинную форму легче понять с первого взгляда
		(и следовательно, легче обслуживать).
		В какой-то момент своей карьеры веб-разработчика вы столкнетесь
		со всеми этими форматами.
</p>

<div class="title">рамки<br>borders</div>
<p>
    Продолжая наше путешествие от центра блоковой модели CSS, мы видим рамку:
		линию, проведенную вокруг контента и padding элемента.
		Свойство рамки требует нового синтаксиса, который нам еще не знаком.
		Сначала мы определим ширину обводки рамки, затем ее стиль, а затем ее цвет.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-09-css-border-syntax-d8ba17.61c3122e.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: свойство "рамка" (border), показывающее синтаксис размера, стиля и цвета
</small></figcaption>
</figure>

<p>
    Попробуйте добавить рамку вокруг нашего заголовка &lt;h1&gt;, изменив правило
		в файле box-styles.css:
</p><p class="code">
h1 {<br>
<span class="code-green">padding</span>: 50px;<br>
<span class="code-green">border</span>: 1px solid #5D6063;<br>
}
</p><p>
    Это команда браузеру нарисовать тонкую серую линию вокруг нашего заголовка.
		Посмотрите как рамка вплотную примыкает к padding, не оставляя никакого зазора.
		А если уменьшить размеры браузера так, что заголовок будет разделен
		на две строки, то padding и рамка все равно останутся на своих местах.
</p><p>
    Если нарисовать рамку вокруг всего заголовка, то он будет выглядеть как
		вебсайт из 1990-х.
		Так что мы ограничимся только нижней частью заголовка.
		Как и для свойства padding, так и для border существуют четыре свойства:
		-top, -bottom, -left и -right.
</p><p class="code">
<span class="code-green">border-bottom</span>: 1px solid #5D6063;
</p><p>
    Рамки являются обычными элементами дизайна, но они также неоценимы для отладки.
		Когда Вы не уверены в том, как отображается блок, задайте следуещее правило:
		border: 1px solid red;
		Это отчетливо покажет padding, margin и общие размеры блока с помощью всего
		одной строки CSS.
		После того, как Вы выяснили причину сбоя, просто удалите это правило.
</p><p>
    Дополнительную информацию о стилях оформления рамок вы найдете на сайте <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/border-style">
		Mozilla Developer Network</a>.
</p>

<div class="title">внешние отступы<br>margins</div>
<p>
    Margins определяют пространство за рамкой элемента.
		Или, точнее, пространство между блоком и окружающими его блоками.
		Давайте добавим немного свободного пространства к нижней части каждого
		элемента &lt;p&gt;:
</p><p class="code">
<span class="code-strong">p</span> {<br>
<span class="code-green">padding</span>: 20px 0 20px 10px;<br>
<span class="code-green">margin-bottom</span>: 50px;<span class="code-grey"> /* добавьте это */</span><br>
}
</p><p>
    Это демонстрирует специфический для боковых сторон вариант свойства margin,
		и это свойство допускает те же <a href="#shorthand-formats">сокращенные форматы</a>,
		что и padding.
</p><p>
    Свойства margin и padding могут выполнять одну и ту же задачу во многих ситуациях,
		что затрудняет определение того, какой из них является "правильным" выбором.
		Наиболее характерными причины для выбора:
</p>
<ul>
<li>Padding блока имеет фон, в то время как margin всегда прозрачен.</li>
<li>Padding включен в "кликабельную" область элемента, а margin - нет.</li>
<li>Padding НЕ схлопывается по вертикали, в то время как margin схлопывается
	  (мы обсудим это подробнее в следующей секции).</li>
</ul>
<p>
	  Если ни один из этих пунктов не помог вам принять решение в пользу padding или
		margin, то не заморачивайтесь по этому поводу - просто выберите один из них.
		В CSS обычно существует несколько способов решения проблемы.
</p>

<div class="title-under">MARGINS И СТРОЧНЫЕ ЭЛЕМЕНТЫ<br>margins on inline elements</div>

<p>
    Одним из самых заметных отличий между блоковыми и inline-элементами -
		их поведение по отношению к margin.
		Inline-блоки <em>полностью игнорируют</em> верхний и нижний margin элемента.
		Для примера добавим достаточно большой margin к нашему элементу &lt;strong&gt;.
	  Посмотрите, что произойдет.
</p><p class="code">
<span class="code-strong">strong</span> {<br>
<span class="code-green">margin</span>: 50px;<br>
}
</p><p>
    Горизонтальные margin-отступы отображаются так, как ожидалось, но при этом
		вертикальное пространство вокруг нашего &lt;strong&gt; ничуть не изменилось.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-10-margins-on-inline-elements-4c569c.91f5003a.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10: демонстрация отсутствия вертикального пространства у inline-блоков
</small></figcaption>
</figure>

<p>
    Если мы изменим margin на padding, то обнаружим совсем другое поведение у
		padding в блоке.
		Пространство вокруг блока расширилось, однако вертикальное отображение
		окружающих блоков не изменилось.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-11-paddings-on-inline-elements-fb52d0.41e49ee9.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: демонстрация вертикального padding на inline-блоках
</small></figcaption>
</figure>

<p>
    Дело в том, что inline-блоки форматируют фрагменты текста внутри блока и,
		таким образом, оказывают ограниченное влияние на отображение страницы.
		Если хотите поэкспериментировать с вертикальным пространством страницы, вам
		следует использовать элементы блокового уровня (к счастью, мы уже знаем, как
<a href="#changing-box-behavior">изменить тип блока элемента</a>).
</p><p>
    Итак, прежде чем биться головой о стену, пытаясь понять, почему не работает
		верхний или нижний margin, вспомните о проверке свойства display.
		Поверьте, рано или поздно это произойдет.
</p>

<div class="title">вертикальное схлопывание<br>vertical margin collapse</div>
<p>
    Еще одной странностью блоковой модели CSS является "вертикальное схлопывание
		margin".
		Когда два блока с вертикальными margin расположенны друг над другом,
		они схлопываются.
    Казалось бы оба margin должны добавляться друг к другу.
		Однако отображается только самый большой из них.
</p><p>
    Давайте для наглядности добавим к нашему элементу &lt;p&gt; верхний margin
		в 25 пикселей.
</p><p class="code">
<span class="code-strong">p</span> {<br>
<span class="code-green">padding</span>: 20px 0 20px 10px;<br>
<br>
<span class="code-green">margin-top</span>: 25px;<br>
<span class="code-green">margin-bottom</span>: 50px;<br>
}
</p><p>
    Каждый абзац получит по 50 пикселей снизу и 25 сверху.
		Вместе получается 75 пикселей между нашими элементами &lt;p&gt;, верно?
		Неверно!
		Между ними по-прежнему будет только 50px, потому что меньшее верхнее поле
		схлопывается в большее нижнее.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-12-vertical-margin-collapse-bba78e.083d1c6b.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 12: cлева: вертикальное поле без схлопывания [uncollapsed], справа:
		схлопывающееся вертикальное поле [collapsed]
</small></figcaption>
</figure>

<p>
    Такое поведение очень полезно при работе с множеством различных типов элементов
		когда вы хотите определить их <em>минимальное</em> пространство между другими
		элементами.
</p>

<div class="title-under">предотврашение схлопывания<br>preventing margin collapse</div>
<p>
    Эффект схлопывания полей может быть и очень досадным.
		Все таки иногда хотелось бы не допускать этого.
		Все, что нужно сделать, это поместить между ними еще один невидимый элемент:
</p><p class="code">
&lt;p&gt;Paragraphs are blocks, too. &lt;em&gt;However&lt;/em&gt;, &amp;lt;em&amp;gt; and &amp;lt;strong&amp;gt;
<br>
elements are not. They are &lt;strong&gt;inline&lt;/strong&gt; elements.&lt;/p&gt;<br>
<br>
&lt;div style=<span class="code-rust">'padding-top: 1px'</span>&gt;&lt;div&gt;<span class="code-grey"> /* добавьте это */</span><br>
<br>
&lt;p&gt;Block elements define the flow of the HTML document, while inline elements<br>
do not.&lt;/p&gt;<br>
</p><p>
    Подробнее о &lt;div&gt; поговорим в следующей секции.
		Самое важное здесь то, что только <em>следующие друг за другом</em> элементы
		могут схлопываться друг в дружку.
		Помещение элемента с ненулевой высотой (padding-top) между абзацами заставляет
		их отображать оба поля - и верхнее в 25px, и нижнее в 50px.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-13-preventing-margin-collapse-4b96ca.e5b2db6e.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 13: добавление пустого &lt;div&gt; не дает вертикальному полю схлопываться
</small></figcaption>
</figure>

<p>
    Помните, что padding никогда не схлопывается.
		Поэтому в виде альтернативы можно использовать padding
		вместо margin.
		Однако это срабатывает только, если не использовать padding ни для чего другого
		(а в данный момент мы используем, поэтому остановимся на варианте с &lt;div&gt;).
</p><p>
    Третий вариант избежать схлопывания - соблюдение правила для margin "только
		снизу или только сверху*".
		Например, если все наши элементы определяют <em>только</em> bottom-margin,
		они не будут схлопываться.
</p><p>
    И наконец, в схеме компоновки <a href="iih08-flexbox.html">flexbox</a> margin
		не схлопывается, так что для современных сайтов это вообще не проблема.
</p><p class="notetran">
    * - bottom-only or top-only margin convention.
</p>

<div class="title">универсальные блоки<br>generic boxes</div>
<p>
    До сих пор все рассмотренные HTML-элементы придавали дополнительный
		смысл их контенту.
		В этом и заключается смысл HTML, но все же иногда нужен некий
		универсальный блок только для стилизации веб-страницы.
		Для этого и предназначены &lt;div&gt; и &lt;span&gt;.
</p><p>
    И &lt;div&gt;, и &lt;span&gt; являются "контейнерными" элементами, не
		оказывающими никакого влияния на семантическую структуру HTML-документа.
		Однако они позволяют добавлять CSS-стили к любым местам веб-страницы.
		Например, иногда нужно предотвратить добавить margin-схлопывание невидимой рамкой
		или сгруппировать первые абзацы статьи в краткий обзор с иным форматированием.
</p><p>
    На протяжении всего курса мы будем часто использовать &lt;div&gt;.
		А пока давайте создадим простую кнопку, добавив в нижнюю часть нашего файла
		boxes.html следующее:
</p><p class="code">
<span class="code-blue">&lt;div&gt;</span>Button<span class="code-blue">&lt;/div&gt;</span>
</p><p>
    А в файл box-styles.css добавьте стили для нашей кнопочки.
		Большинство из них должны быть знакомы по предыдущей главе, за исключением
		нового <a href="https://developer.mozilla.org/ru/docs/Web/CSS/border-radius">
		свойства border-radius</a>:
</p><p class="code">
	<span class="code-strong">div</span> {<br>
	<span class="code-green">background-color</span>: #5995DA;<br>
	<span class="code-green">font-weight</span>: bold;<br>
	<span class="code-green">padding</span>: 20px;<br>
	<span class="code-green">text-align</span>: center;<br>
	<span class="code-green">border</span>: 2px solid #5D6063;<br>
	<span class="code-green">border-radius</span>: 5px;<br>
	}
</p><p>
    В результате мы получим большую синюю кнопку, занимающую всю ширину браузера:
</p>

<figure>
<img class="pic-pages" src="./images/iih05-14-generic-div-for-button-70dc27.fed38f83.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 14: элементы &lt;div&gt; используемые для кнопки
</small></figcaption>
</figure>

<p>
    Эти стили применяются и к невидимому &lt;div&gt;, которым мы отменили
		margin-схлопывание (см. выше).
		Очевидно, что для практической пользы от отдельных &lt;div&gt;
		необходимо их как-то выделить.
		Для этого и нужны <a href="iih06-css-selectors.html#class-selectors">
		селекторы классов</a> (см. следующ. урок).
		А пока что просто удалим или закомментируем этот невидимый &lt;div&gt;.
</p><p>
    Единственная реальная разница между &lt;div&gt; и &lt;span&gt; заключается в том,
		что &lt;div&gt; предназначен для блоков, а &lt;span&gt; -
		для строк.
</p>

<div class="title" id="explicit-dimensions">явно выраженные размеры<br>explicit dimensions</div>

<p>
    До сих пор мы позволяли нашим HTML-элементам определять свои размеры автоматически.
		Paddings, margins, рамки, с которыми мы экспериментировали,
		обхватывают все внутри блока элемента.
		Если добавить в наш &lt;em&gt; больше текста, то все будет расширяться,
		чтобы вместить его:
</p>

<figure>
<img class="pic-pages" src="./images/iih05-15-auto-content-width-for-em-element-85d5d2.fac0e1bd.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 15: элемент &lt;em&gt; расширяется при добавлении контента
</small></figcaption>
</figure>

<p>
    Но иногда в макете требуется явно выраженный размер, например, боковая
		панель шириной ровно 250 пикселей.
		Для этого в CSS предусмотрены свойства width и height.
		Они имеют приоритет над размером содержимого блока по умолчанию.
</p><p>
    Давайте придадим нашей кнопке фиксированную ширину, добавив в box-styles.css
		следующее свойство:
</p><p class="code">
<span class="code-strong">div</span> {<br>
<span class="code-grey">
	/* уже заданные декларации */</span><br>
<span class="code-green">width</span>: 200px;<br>
	}
</p><p>
    Вместо ширины во все окно браузера, ширина кнопки стала 200px и она прилегает
		к левой стороне страницы:
</p>

<figure>
<img class="pic-pages" src="./images/iih05-16-explicit-width-on-generic-div-78d595.8fed0f85.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 16: демонстрания явного CSS-свойства width для кнопки
</small></figcaption>
</figure>

<p>
    Также заметьте, что сделав заголовок кнопки длиннее, он автоматически перейдет
		на следующую строку, а элемент увеличится по вертикали, чтобы вместить этот
		новый контент.
		Это стандартное поведение можно изменить свойствами <a href="https://developer.mozilla.org/ru/docs/Web/CSS/white-space">
		white-space</a> и <a href="https://developer.mozilla.org/ru/docs/Web/CSS/overflow">
		overflow</a>.
</p>

<div class="title">блоки контента и блоки рамки<br>content boxes and border boxes</div>

<p>
    Свойства width и height в блоке определяют только <em>размер контента</em>.
		Padding и рамка добавляются <em>поверх</em> заданных вами размеров.
		Это объясняет, почему на скриншоте нашей кнопки вы получите изображение
		шириной 244 пикселя, несмотря на то, что заявленная ширина width: 200px.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-17-box-sizing-content-box-09f48a.6fded525.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 17: размеры блока контента, добавляющие padding и рамку к ширине элемента
</small></figcaption>
</figure>

<p>
    Само собой разумеется, это может быть несколько противоречивым, когда вы
		пытаетесь разметить страницу.
		Представьте, что вы пытаетесь заполнить контейнер размером 600px тремя блоками
		шириной: 200px, но они не помещаются, поскольку все они имеют рамку в 1px
		(что делает их фактическую ширину 202px).
</p><p>
    К счастью, CSS позволяет изменить способ расчета ширины блока с помощью
		свойства box-sizing.
		По умолчанию оно имеет значение content-box, что приводит к описанному выше
		поведению.
		Посмотрим, что произойдет, если мы изменим его значение на border-box:
</p><p class="code">
<span class="code-strong">div</span> {<br>
<span class="code-green">color</span>: #FFF;<br>
	<span class="code-green">background-color</span>: #5995DA;<br>
	<span class="code-green">font-weight</span>: bold;<br>
	<span class="code-green">padding</span>: 20px;<br>
<span class="code-green">text-align</span>: center;<br>
	<span class="code-green">border</span>: 2px solid #5D6063;<br>
	<span class="code-green">border-radius</span>: 5px;<br>
	<br>
<span class="code-green">width</span>: 200px;<br>
<span class="code-green">box-sizing</span>: border-box; <span class="code-grey">
	/* добавьте это */</span><br>
}
</p><p>
    В результате фактическая ширина блока будет равна 200px - с учетом padding и рамки.
		Разумеется, ширина контента теперь определяется автоматически:
</p>

<figure>
<img class="pic-pages" src="./images/iih05-18-box-sizing-border-box-ace2be.624b1ea3.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 18: размеры border-box с учетом padding и рамки в сочетании с шириной элемента
</small></figcaption>
</figure>

<p>
    Это гораздо более интуитивно понятно, поэтому border-box для всех блоков
		веб-разработчики сегодня считают оптимальным решением.
</p>

<section>
<div class="title" id="aligning-boxes">выравнивание блоков <br>aligning boxes</div>

<p>
    Выравнивание блоков по горизонтали - распространенная задача для веб-разработчиков,
		и блоковая модель предлагает множество способов ее решения.
		Мы уже рассмотрели <a href="iih04-hello-css.html#text-alignment">свойство
		text-align</a>, которое выравнивает контент и <em>строчные</em> блоки внутри
		элемента блокового уровня.
		Выравнивание <em>блоковых</em> блоков - это совсем другая история.
</p><p>
    Попробуйте добавить в нашу таблицу стилей следующее правило.
		Оно будет выравнивать только контент внутри блоковых блоков, но не сами блоки.
		Наша кнопка &lt;div&gt; все равно будет выровнена по левому краю, независимо
		от выравнивания текста в &lt;body&gt;:
</p><p class="code">
<span class="code-strong">body</span> {<br>
<span class="code-green">text-align</span>: center;<br>
}
</p><p>
    Существует три метода горизонтального выравнивания элементов на уровне блоков:
		центрирование auto-margins, floats для выравнивания по левому/правому краю
		и flexbox для полного контроля над выравниванием.
		Да, к сожалению, выравнивание на уровне блоков совершенно не связано со
		свойством text-align.
</p>

<div class="title-under">ЦЕНТРИРОВАНИЕ С ПОМОЩЬЮ АВТО-ОТСТУПОВ<br>
    centering with auto-margins</div>
<p>
<a href="iih07-floats.html">
    Floats</a> и <a href="iih08-flexbox.html">flexbox</a> - это сложные темы, которым
		мы посвятили отдельные главы-уроки.
		Зато сейчас у нас есть все необходимые знания для работы с auto-margins.
		Устанавливая для левого и правого полей элемента блокового уровня
		значение auto, мы получаем центрирование блока в его родительском элементе.
</p><p>
    Например, мы можем отцентрировать нашу кнопку следующим образом:
</p><p class="code">
<span class="code-strong">div</span> {<br>
<span class="code-green">color</span>: #FFF;<br>
<span class="code-green">background-color</span>: #5995DA;<br>
<span class="code-green">font-weight</span>: bold;<br>
<span class="code-green">padding</span>: 20px;<br>
<span class="code-green">text-align</span>: center;<br>
<br>
<span class="code-green">width</span>: 200px;<br>
<span class="code-green">box-sizing</span>: border-box;<br>
<span class="code-green">margin</span>: 20px auto;<span class="code-grey">
/* вертикально горизонтально */</span><br>
}
</p><p>
    Обратите внимание, что это работает только с блоками, для которых явно
		задана ширина.
		Уберите строку width: 200px, и наша кнопка будет занимать всю ширину браузера,
		что сделает "центрирование" бессмысленным.
</p>

<section>
<div class="title" id="resetting-styles">сброс стилей<br>resetting styles</div>
<p>
    Заметили белую каемку вокруг нашей страницы (см. скриншот ниже)?
		Это marging, padding и поля, добавленные браузером по умолчанию.
		Различные браузеры имеют разные стандартные стили для всех HTML-элементов,
		что затрудняет создание одинаковых таблиц стилей.
</p>

<figure>
<img class="pic-pages" src="./images/iih05-19-resetting-box-sizing-and-margins-72ff64.c2d5ab5e.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 19: слева веб-страница с стандартной белой каемкой из-за margin и padding.
		Справа веб-страница без белой каемки после сброса настроек (with reset)
</small></figcaption>
</figure>

<p>
    В большинстве случаев полезно переопределить стили по умолчанию на предсказуемое
		значение с помощью "универсального" CSS-селектора (*).
		Попробуйте добавить его в верхнюю часть нашего файла box-styles.css:
</p><p class="code">
<span class="code-strong">*</span> {<br>
<span class="code-green">margin</span>: 0;<br>
<span class="code-green">padding</span>: 0;<br>
<span class="code-green">box-sizing</span>: border-box;<br>
}
</p><p>
    Этот селектор соответствует каждому элементу HTML, эффективно сбрасывая
		свойства margin и padding на нашей веб-странице.
		Все наши блоки также были преобразованы в border-box, что, опять же,
		является налучшей практикой.
</p><p>
    Подобный сброс можно найти в верхней части почти каждой таблицы стилей CSS
		в Интернете.
		Все может оказаться гораздо сложнее, но три простых декларации, показанные
		выше, позволяют нам уверенно настраивать блоковую модель CSS для своих целей,
		не опасаясь непредвиденных взаимодействий со стилями браузера по умолчанию.
</p>
</section>
<section>
<div class="title">резюме</div>
<p>
    Более подробно о практическом использовании блоковой модели CSS мы узнаем по
		мере углубления в создание сложных веб-страниц.
		Пока же воспринимайте ее как новый инструмент в вашем арсенале CSS.
		Ознакомившись с несколькими ключевыми понятиями из этой главы, вы ощутите
		себя гораздо более подготовленным к преобразованию дизайнерского эскиза в
		реальную веб-страницу:
</p><ul>
<li>Все состоит из блоков.</li>
<li>Блоки могут быть строчными (inline) или блоковыми (block-level).</li>
<li>Блоки имеют контент, padding, рамку и margin.</li>
<li>Они также имеют, казалось бы, случайные правила взаимодействия.</li>
<li>Овладев блоковой моделью, можно сверстать большинство веб-страниц.</li>
</ul><p>
    Как и на прошлом уроке, только что рассмотренные CSS-свойства могут показаться
		простыми - так оно и есть.
		Но стоит взглянуть на посещаемые сайты через призму блоковой модели, - и вы
		увидите эти свойства буквально повсюду.
</p><p>
    Наше изучение универсальных блоков (&lt;div&gt; и &lt;span&gt;) было
		несколько ограниченным, поскольку у нас не было возможности извлечь отдельный
		HTML-элемент из нашей веб-страницы.
		Мы исправим это на следующем уроке, где более подробно рассмотрим селекторы CSS.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>СЕЛЕКТОРЫ CSS</h2>
<p>УРОК Nº 6.</p>
<p><em>
    Самый понятный учебник веб-разработки о выборке HTML-элементов
</em></p>


<p>
    Еще в главе <a href="iih03-links-and-images.html">Ссылки и картинки</a> мы
		узнали, как связать HTML-документ с другими файлами нашего проекта.
		CSS-селекторы работают аналогично, только вместо навигации по целым файлам
		они позволяют привязать одно CSS-правило к конкретному HTML-элементу.
		Это позволяет выборочно стилизовать отдельные элементы, игнорируя другие.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-01-css-selectors-1f0064.464e0c0e.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: CSS-селектор, связывающий CSS-правило с HTML-элементом
</small></figcaption>
</figure>

<p>
    Если вы не хотите, чтобы все секции вашего сайта выглядели одинаково, к вашим
		услугам очень полезная функциональная особенность.
		С ее помощью мы можем сказать: "Я хочу, чтобы этот абзац был синим, а тот - желтым".
		До сих пор мы могли сделать <em>все</em> абзацы только синими (или желтыми).
</p><p>
    До сих пор мы использовали только один CSS-селектор, так наз. "селектор
		типа" [type selector].
		Он определяет все соответствующие элементы на странице.
		На этом уроке мы рассмотрим более детальные способы стилизации веб-страниц
		с помощью селекторов классов, потомков, псевдоклассов и идентификаторов.
</p>

<div class="title">подготовка<br>setup</div>
<p>
    Для нашего примера к этому уроку нам понадобится только один HTML-файл и
		таблица стилей CSS.
		Создайте новую папку css-selectors и новую веб-страницу selectors.html со
		следующей разметкой:
</p><p class="code">
	<span class="code-green">&lt;!DOCTYPE html&gt;</span><br>
	&lt;html lang='en'&gt;<br>
	&lt;head&gt;<br>
	&lt;meta charset='UTF-8'/&gt;<br>
	&lt;title&gt;CSS Selectors&lt;/title&gt;<br>
	&lt;link rel='stylesheet' href='styles.css'/&gt;<br>
	&lt;/head&gt;<br>
	&lt;body&gt;<br>
	&lt;h1&gt;CSS Selectors&lt;/h1&gt;<br>
	<br>
	&lt;p&gt;CSS selectors let you &lt;em&gt;select&lt;/em&gt;, individual HTML
	elements in an HTML<br>
	document. This is &lt;strong&gt;super&lt;/strong&gt; useful.&lt;/p&gt;<br>
	<br>
	&lt;p&gt;Classes are ridiculously important, since they allow you to select<br>
	arbitrary boxes in your web pages.&lt;/p&gt;<br>
	<br>
	&lt;p&gt;We’ll also be talking about links in this example, so here’s<br>
  &lt;a href='https://internetingishard.com'&gt;Interneting Is Hard&lt;/a&gt;
	for us to<br>
  style.&lt;/p&gt;<br>
<br>
&lt;div&gt;Button One&lt;/div&gt;<br>
<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Создайте в той же папке таблицу стилей styles.css.
		Тогда у нас будет все необходимое для изучения селекторов CSS.
</p><p>
    Если вы только что начали изучать эту серию уроков, обязательно прочтите <a href="iih01-intro.html#atom">
    введение</a>, чтобы освоиться с редактором Atom.
</p>

<div class="title" id="class-selectors">селекторы классов<br>Class Selectors</div>
<p>
    "Селекторы классов" позволяют применять стили CSS к определенному элементу HTML.
		Они позволяют различать HTML-элементы одного типа, как, например, в <a href="iih05-css-box-model.html">
		предыдущей главе</a>, когда у нас было два элемента &lt;div&gt;, но мы хотели
		придать стиль только одному из них.
		Для использования селекторов классов необходимы две вещи:
</p><ul>
<li>Атрибут class у конкретного HTML-элемента.</li>
<li>Соответствующий селектор класса CSS в таблице стилей.</li>
</ul>

<figure>
<img class="pic-pages" src="./images/iih06-02-class-selector-ce3fd0.0b2a2ecd.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2: селектор класса CSS, связывающий правило CSS с атрибутом class
		HTML-элемента
</small></figcaption>
</figure>

<p>
    Мы можем использовать селектор класса для того, чтобы стилизовать первый
		абзац нашего примера страницы иначе, чем остальные.
		Это может быть, например, синопсис [краткий обзор содержания] газетной статьи.
		Сначала добавим атрибут class к нужному абзацу:
</p><p class="code">
	&lt;p class=<span class="code-rust">'synopsis'</span>&gt;CSS selectors let you &lt;em&gt;select&lt;/em&gt;,
	individual HTML<br>
	elements in an HTML document. This is &lt;strong&gt;super&lt;/strong&gt; useful.
	&lt;/p&gt;
</p><p>
    Теперь мы можем выбрать этот элемент &lt;p class='synopsis'&gt; в нашем CSS
		с помощью следующего правила (добавьте его в файл styles.css):
</p><p class="code">
<span class="code-blue">.synopsis</span> {<br>
<span class="code-green">color</span>: #7E8184; <span class="code-grey">
	/* светло-серый */</span><br>
<span class="code-green">font-style</span>: italic;<br>
}
</p><p>
    Это правило применяется <em>только</em> к элементам с соответствующим
		атрибутом class.
		Обратите внимание на точку (.) в префиксе имени класса.
		Это отличает селекторы классов от селекторов типов, с которыми мы работали
		до этого урока.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-03-selecting-a-paragraph-with-class-selector-05f491.4de5fde7.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: выделенный курсивом элемент &lt;p&gt;, стилизованный
		с помощью селектора класса
</small></figcaption>
</figure>

<div class="title-under" id="class-naming-conventions">СТАНДАРТЫ НАИМЕНОВАНИЯ КЛАССОВ<br>
Class Naming Conventions</div>
<p>
    Значение атрибута HTML class может быть (почти) любым, если оно соответствует
		селектору в ваших CSS.
		Стандартный порядок именования классов - все строчные буквы и дефисы для
		пробелов, как в именах файлов и папок.
</p><p>
    Добавление атрибута class не меняет семантического смысла HTML-документа -
		он служит исключительно для подключения к таблице стилей CSS.
		Тем не менее, обычно рекомендуется избегать именования классов по их внешнему виду.
		Если мы назовем наш класс .italic, то в CSS мы не сможем сделать ничего,
		кроме как сделать его курсивным, что приведет к запутанной ситуации.
		Использование смыслового имени, например .synopsis, дает нам больше свободы
		в CSS для настройки отображения синопсиса.
</p>

<div class="title">полезные возможности div<br>More Useful Divs</div>
<p>
    Атрибут class не ограничивается элементами &lt;p&gt; - он может быть определен
		для <em>любого</em> HTML-элемента.
		Вооружившись новоприобретенными селекторами классов CSS, мы получаем гораздо
		больше возможностей применения универсальных контейнеров &lt;div&gt; и &lt;span&gt;
		из предыдущего урока.
		Мы можем использовать их для стилизации как отдельных элементов, так и
		любых секций нашей веб-страницы.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-04-selecting-button-with-class-selector-a32bd4.f5fce952.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: веб-страница, на которой выделен элемент &lt;div&gt; в виде кнопки,
			стилизованный с помощью селектора класса
</small></figcaption>
</figure>

<p>
    Начнем с отдельных элементов, воссоздав нашу кнопку из предыдущей главы.
		На этот раз вместо селектора div мы используем класс.
		Добавьте в файл styles.css следующее:
</p><p class="code">
<span class="code-blue">.button</span> {<br>
<span class="code-green">color</span>: #FFF;<br>
<span class="code-green">background-color</span>: #5995DA;<span class="code-grey">
/* синий */</span><br>
<span class="code-green">font-weight</span>: bold;<br>
<span class="code-green">padding</span>: 20px;<br>
<span class="code-green">text-align</span>: center;<br>
<span class="code-green">border</span>: 2px solid #5D6063; <span class="code-grey">
/* темно-серый */</span><br>
<span class="code-green">border-radius</span>: 5px;<br>
<br>
<span class="code-green">width</span>: 200px;<br>
<span class="code-green">margin</span>: 20px auto;<br>
}
</p><p>
    Разумеется, для этого нам необходим соответствующий атрибут class.
		Измените &lt;div&gt; в файле selectors.html следующим образом:
</p><p class="code">
<span class="code-blue">&lt;div class=</span><span class="code-rust">'button'</span><span class="code-blue">&gt;</span>Button One<span class="code-blue">&lt;/div&gt;</span>.
</p><p>
    В отличие от предыдущего урока, в котором стилизовались <em>все</em>
		элементы &lt;div&gt;, на этом уроке мы можем использовать их не только для
		кнопок.
</p>

<div class="title" id="container-divs">div-контейнеры<br>Container Divs</div>
<p>
    Помните, что &lt;div&gt; не изменяет смысловую структуру веб-страницы.
		Это делает его отличным инструментом для структуры <em>внешнего вида</em>
		страницы.
		Обернув другие HTML-элементы в теги &lt;div&gt;, мы можем разделить наш сайт
		на крупные сегменты, ориентированные на верстку, не испортив при этом восприятия
		поисковиками нашего контента.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-05-container-divs-7d53f6.60e9ae81.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5: люди видят элемент &lt;div&gt; с отступами (margins), веб-роботы
		его не видят
</small></figcaption>
</figure>

<p>
    В качестве примера создадим макет фиксированной ширины с
		использованием <a href="iih05-css-box-model.html#aligning-boxes">
		техники auto-margin</a>, которую мы изучали в предыдущей главе.
		Сначала упакуем весь наш документ в общий &lt;div&gt; и присвоим ему cвой
		собственный класс:
</p><p class="code">
&lt;body&gt;<br>
&lt;div class='page'&gt; <span class="code-grey">&lt;!-- добавьте это --&gt;</span><br>
&lt;h1&gt;CSS Selectors&lt;/h1&gt;<br>
	<br>
&lt;p class='synopsis'&gt;CSS selectors let you &lt;em&gt;select&lt;/em&gt;, individual HTML
	  elements in an HTML<br>
	  document. This is &lt;strong&gt;super&lt;/strong&gt; useful.&lt;/p&gt;<br>
<br>
&lt;p&gt;Classes are ridiculously important, since they allow you to select<br>
	  arbitrary boxes in your web pages.&lt;/p&gt;<br>
<br>
&lt;p&gt;We’ll also be talking about links in this example, so here’s<br>
&lt;a href='https://internetingishard.com'&gt;Interneting Is Hard&lt;a&gt;
	  for us to<br>
	  style.&lt;/p&gt;<br>
<br>
&lt;div class='button'&gt;Button One&lt;/div&gt;<br>
&lt;/div&gt; <span class="code-grey"> &lt;!-- и это добавьте --&gt;</span><br>
&lt;/body&gt;<br>
</p><p>
    Затем в styles.css добавим вот такой код:
</p><p class="code">
<span class="code-blue">.page</span> {<br>
<span class="code-green">width</span>: 600px;<br>
<span class="code-green">margin</span>: 0 auto;<br>
}
</p><p>
    Как бы вы ни изменяли размеры окна браузера, наша веб-страница всегда будет
		иметь ширину 600 пикселей и центрироваться в доступном пространстве.
		Обратите внимание, что точно таким же образом мы центрировали нашу кнопку,
		но теперь мы делаем это для нескольких элементов одновременно, вложив их
		в общий контейнер.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-06-centering-page-with-div-container-e3c8aa.d9b9cf09.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: обертывание всего документа веб-страницы посредством &lt;div&gt;
		с классом .page
</small></figcaption>
</figure>

<p>
    Именно так задаются макеты в более сложных веб-страницах.
		Например, если бы на нашей странице была боковая панель, мы бы вложили все
		элементы боковой панели в <em>другой</em> &lt;div&gt; с классом .sidebar.
		Мы увидим это в действии <a href="iih07-floats.html">на следующем уроке</a>.
		Пока же важно понять, что без селекторов классов, позволяющих отделять
		элементы &lt;div&gt;, ничего этого сделать было бы невозможно.
</p>

<div class="title">многократное использование стилей классов<br>Reusing Class Styles</div>
<p>
	Один и тот же класс можно применять к нескольким элементам в одном HTML-документе.
	Это означает, что теперь мы можем повторно использовать любые CSS-декларации
	в любом месте.
	Чтобы создать еще одну кнопку, достаточно добавить еще один HTML-элемент с тем
	же классом:
</p><p class="code">
&lt;div class='button'&gt;Button One&lt;/div&gt;<br>
&lt;div class='button'&gt;Button Two&lt;/div&gt;
</p><p>
    Таким образом, мы получаем вторую кнопку, которая выглядит так же, как и первая,
		без написания даже одной строки CSS!
		Подобная организация схожих графических элементов в многократно используемые
		правила CSS значительно облегчает жизнь веб-разработчика.
		Если мы захотим, например, изменить цвет кнопки, нам нужно будет сделать это
		только в одном месте, и все наши кнопки автоматически обновятся.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-07-reusing-css-styles-9e43c5.16fefba9.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: две стрелки, идущие от одного правила CSS к двум разным элементам HTML
</small></figcaption>
</figure>

<div class="title">Изменение стилей классов<br>Modifying Class Styles</div>
<p>
    А что если мы захотим немного изменить нашу вторую кнопку?
		К счастью, мы можем применить несколько классов <em>к одному и тому</em> же
		HTML-элементу.
		Стили каждого класса будут применены к элементу, позволяя нам:
<br>а) повторно использовать стили из .button и<br>
    б) переопределить некоторые из стилей в новом классе.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-08-modifying-classes-48bd19.afd60085.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: две стрелки, идущие от <em>двух</em> CSS-правил к <em>одному</em>
		HTML-элементу
</small></figcaption>
</figure>

<p>
    Добавим к нашей второй кнопке еще один класс call-to-action.
		Обратите внимание, что оба класса находятся в одном атрибуте class,
		разделенные пробелом:
</p><p class="code">
<span class="code-blue">&lt;div class=</span><span class="code-rust">'button call-to-action'</span><span class="code-blue">&gt;</span>Button Two<span class="code-blue">&lt;/div&gt;</span>
</p><p>
    Теперь у этого элемента есть два отдельных класса, и мы можем использовать
		любой из них для его стилизации.
		Это открывает некоторые возможности.
		Стили, общие для обеих кнопок, могут находиться в классе .button (как это
		уже сделано), а стили, специфичные для второй кнопки, - в классе .call-to-action
		(не забудьте добавить его <em>после</em> правила .button):
</p><p class="code">
<span class="code-blue">.call-to-action</span> {<br>
<span class="code-green">font-style</span>: italic;<br>
<span class="code-green">background-color</span>: #EEB75A;<span class="code-grey">
	/* желтый */</span><br>
}
</p>

<div class="title-under" id="order-matters">ОЧЕРЕДНОСТЬ ИМЕЕТ ЗНАЧЕНИЕ<br>Order Matters</div>
<p>
    Теперь в нашей второй кнопке происходит несколько важных вещей:
</p><ul>
<li>к исходному правилу .button добавилось <em>новое</em> объявление font-style.</li>
<li><em>переопределился</em> существующий стиль background-color.</li>
</ul>
<p>
    Переопределение [overriding] происходит из-за порядка следования .call-to-action
		и .button в нашей таблице стилей.
		Когда в CSS-файле присутствуют два конфликтующих свойства, всегда применяется последнее.
		Так, если переместить .call-to-action в верхнюю часть styles.css, то последнее
		слово в значении background-color будет за .button, и фон останется синим.
</p><p>
    Отсюда следует, что порядок следования атрибутов class в нашем HTML-элементе
		не влияет на поведение переопределения.
		Несколько классов к одному элементу применяются "одинаково" (за неимением
		лучшего термина), поэтому старшинство определяется исключительно порядком
		следования правил в styles.css.
		Другими словами, следующие элементы фактически эквивалентны:
</p><p class="code">
<span class="code-grey">
&lt;!-- В результате, страница будет отображаться без изменений --&gt;</span><br>
<span class="code-blue">&lt;div class=</span><span class="code-rust">'button call-to-action'</span><span class="code-blue">&gt;</span>Button Two<span class="code-blue">&lt;/div&gt;</span><br>
<span class="code-blue">&lt;div class=</span><span class="code-rust">'call-to-action button'</span><span class="code-blue">&gt;</span>Button Two<span class="code-blue">&lt;/div&gt;</span>

</p><p>
    Однако все усложняется, когда в дело вступает специфика CSS, о которой мы
		поговорим в конце этого урока.
</p>

<div class="title" id="descendant-selectors">селекторы потомков<br>Descendant Selectors</div>
<p>
    Вы, наверное, заметили, что элемент &lt;em&gt; в нашем первом абзаце уже не
		отличим от окружающего текста, поскольку правило .synopsis сделало все курсивом.
</p><p>
    Чтобы изменить этот элемент &lt;em&gt;, мы могли бы добавить другой класс
		непосредственно к нему, но это не приведет к удобству работы с кодом.
		Мы хотим рассматривать .synopsis как свой собственный независимый компонент,
		который мы можем полностью стилизовать с помощью CSS (т.е. без необходимости
		вносить изменения в наш HTML только для того, чтобы что-то стилизовать).
</p>

<figure>
<img class="pic-pages" src="./images/iih06-09-selecting-em-with-descendant-selector-8050a5.44cad9f8.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: веб-страница с текстом span внутри другого элемента, стилизованным
		с помощью селектора-потомка
</small></figcaption>
</figure>

<p>
    Для этого и нужны "селекторы потомков".
		Они позволяют выбрать только те элементы, которые находятся <em>внутри</em>
		другого элемента.
		Например, мы можем извлечь этот &lt;em&gt; в параграфе .synopsis следующим
		образом:
</p><p class="code">
<span class="code-blue">.synopsis</span> <span class="code-strong">em</span> {<br>
<span class="code-green">font-style</span>: normal;<br>
}
</p><p>
    Добавление этого правила в файл styles.css приведет к тому, что &lt;em&gt; будет
		отображаться в виде "обычного" шрифта (т.е. не курсивного), отличаясь тем самым
		от курсива, которым мы выделяем весь текст &lt;p&gt;.
		Остальные элементы &lt;em&gt; на странице не будут затронуты.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-10-descendant-selectors-f52d49.10e0c8d7.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10: единичная стрелка, идущая от составного CSS-правила [CSS rule]
		к HTML-элементу внутри другого HTML-элемента
</small></figcaption>
</figure>

<p>
    Селекторы-потомки не ограничиваются селекторами классов - таким образом можно
		объединять любые другие группы селекторов.
		Например, если мы хотим выбрать только элементы &lt;em&gt; внутри заголовков,
		мы можем использовать что-то вроде этого:
</p><p class="code">
<span class="code-strong">h1 em</span> {<br>
<span class="code-grey">/* некие другие стили */</span><br>
}
</p><p>
    Повторим, цель этого урока - дать возможность применять стили именно к
		тому элементу, который вам нужен.
		Селекторы-потомки - отличный инструмент для достижения этой цели.
		Если еще осталось свободное место в вашем "ящике инструментов", ознакомьтесь
		с селектором дочерних элементов <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Child_combinator">
		на сайте MDN</a>.
</p>

<div class="title-under">НЕ ПЕРЕУСЕРДСТВУЙТЕ<br>Don’t Overdo It</div>

<p>
    Вкладывать селекторы-потомки можно сколь угодно глубоко, но не стоит увлекаться.
		Жизнь становится запутанной и ужасной, когда вы начинаете писать правила,
		которые выглядят примерно так:
</p><p class="code">
<span class="code-grey">/* постарайтесь избежать такого */</span><br>
<span class="code-blue">.article</span>
<span class="code-strong">h2</span>
<span class="code-blue">.subheading</span>
<span class="code-strong">em</span> {<br>
<span class="code-grey">/* особые стили */</span><br>
}
</p><p>
    Это ни в коей мере не пригодно для повторного использования, поскольку
		соответствует только следующей структуре HTML:
</p><p class="code">
&lt;div class=<span class="code-rust">'article'</span>&gt;<br>
&lt;h2&gt;<br>
&lt;span class=<span class="code-rust">'.subheading'</span>&gt;This is &lt;em&gt;really&lt;/em&gt; special text&lt;/span&gt;<br>
&lt;/h2&gt;<br>
&lt;/div&gt;
</p><p>
    Если вы захотите применить эти стили к заголовку &lt;h2&gt;, не обернутому
		в теги &lt;div class='article'&gt;, то будет, как говорится, полный облом.
		То же самое произойдет, если вы захотите применить их к заголовку &lt;h3&gt;
		в любом месте страницы.
		Такой CSS только приведет к кошмару <a href="#css-specificity">специфичности</a>.
</p>

<div class="title" id="pseudo-classes-for-links">псевдоклассы для ссылок<br>Pseudo-Classes for Links</div>
<p>
    До сих пор все рассмотренные CSS-селекторы привязывались непосредственно
		к созданному нами фрагменту HTML-разметки.
		Однако на отображаемой веб-странице присутствует нечто большее, чем просто
		наш HTML-контент.
		Кроме созданного нами контента, там есть "служебная" информация о том, что
		делает пользователь.
</p><p>
    Классический пример - ссылка.
		Как веб-разработчик, вы создаете элемент &lt;a href&gt;.
		После того как браузер отобразит его, пользователь может взаимодействовать
		с этой ссылкой.
		Он может навести на нее курсор, щелкнуть и перейти по URL-адресу.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-11-pseudo-classes-99188b.6d35670a.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: селектор псевдокласса, связывающий CSS-правило с поведением пользователя
		[hover - наведение курсора]
</small></figcaption>
</figure>

<p>
    "Псевдоклассы" CSS это механизм, позволяющий подключаться к такого
		рода временной информации о пользователе.
		Элемент &lt;a href&gt; может находиться в нескольких
		различных состояниях, и вы можете использовать псевдоклассы для стилизации
		каждого из этих состояний в отдельности.
		Считайте, что это селекторы классов, которые не нужно писать самостоятельно,
		ибо они уже встроены в браузер.
</p>

<div class="title-under">ОСНОВНЫЕ СТИЛИ ССЫЛОК<br>Basic Link Styles</div>
<p>
Псевдоклассы начинаются с двоеточия, за которым следует имя нужного класса.
Наиболее распространенными псевдоклассами ссылок являются следующие:
</p><ul>
<li>:link - Ссылка, которую пользователь никогда не посещал.</li>
<li>:visited - Ссылка, которую пользователь уже посещал.</li>
<li>:hover - Ссылка, на которую наведен курсор.</li>
<li>:active - Ссылка, когда ее кликают курсором (или пальцем).</li>
</ul><p>
    Давайте рассмотрим все это, добавив в таблицу стилей CSS следующие правила
		(также обратите внимание на использование <a href="https://developer.mozilla.org/ru/docs/Web/CSS/color_value">
		ключевых цветов</a> вместо привычных hex-кодов [шестнадцатеричных кодов]):
</p><p class="code">
<span class="code-strong">a:</span> link {<br>
<span class="code-green">color</span>: blue;<br>
<span class="code-green">text-decoration</span>: none;<br>
}<br>
<span class="code-strong">a:</span> visited {<br>
<span class="code-green">color</span>: purple;<br>
}<br>
<span class="code-strong">a:</span> hover {<br>
<span class="code-green">color</span>: aqua;<br>
<span class="code-green">text-decoration</span>: underline;<br>
}<br>
<span class="code-strong">a:</span> active {<br>
<span class="code-green">color</span>: red;<br>
}
</p><p>
    Если вы никогда не были на главной странице <a href="https://internetingishard.netlify.app">
		InternetingIsHard.com</a> [веб-страница англоязычного оригинала данного учебника],
		данная ссылка должна быть синего цвета.
		А если уже там были, то цвет ссылки будет фиолетовым.
		При наведении курсора на ссылку ее цвет поменяется на aqua [цвет морской волны],
		а при нажатии на нее - цвет станет красным.
</p>

<div class="title-under">ССЫЛКА КОТ. ПОСЕЩАЛИ ПРИ НАВЕДЕНИИ НА НЕЕ МЫШИ<br>Visited Hover State</div>
<p>
    Приведенный выше фрагмент кода вполне подходит для большинства сайтов, но
		обратите внимание на поведение a:visited, изменив атрибут href на URL,
		который вы уже посещали.
		Наш стиль a:hover применяется как к посещенным, так и к непосещенным ссылкам.
		Можно еще более усовершенствовать наши ссылки, просто добавляя псевдоклассы.
		В конец вышеприведенного кода добавим еще пару строк:
</p><p class="code">
<span class="code-strong">a:</span> visited:hover {<br>
<span class="code-green">color</span>: orange;<br>
}
</p><p>
    Это создаст особый стиль hover для посещаемых ссылок.
		При наведении на непосещаемую ссылку ее цвет уже не будет меняется на aqua.
		А при наведении на посещенную ссылку - ее цвет станет оранжевым.
		Фантастиш!
		За исключением того факта, что это ломает наш стиль a:active из-за некоторых
		сложных CSS-интерфейсов, с которыми вы наверняка никогда не захотите разбираться.
		И еще, когда вы щелкнете на ссылку, она уже не станет красной.
</p>

<div class="title-under">АКТИВНОЕ СОСТОЯНИЕ ПОСЕЩЕННОЙ  ССЫЛКИ <br>VISITED ACTIVE STATE</div>
<p>
    Мы можем исправить это с помощью a:visited:active.
		Добавьте следующее в конец нашей таблицы стилей.
		Помните, что, как и в случае с классом .call-to-action, порядок, в котором
		они определены в styles.css, имеет значение:
</p><p class="code">
<span class="code-strong">a:</span> visited:active {<br>
<span class="code-green">color</span>: red;<br>
}
</p><p>
    Последние два секции объясняют как стилизовать посещенные ссылки отдельно от
		непосещенных.
    Это хорошая возможность, но, опять же, вы можете ограничиться базовыми стилями
		ссылок.
		Может вам их будет достаточно?</p>

<div class="title">псевдоклассы для кнопок<br>Pseudo-Classes for Buttons</div>
<p>
    Помимо стилизации текстовых ссылок псевдоклассы можно применять для стилизации
		любого типа селекторов (не только селекторов типов).
		Вместо стилизации a:link и других ссылок, в этой секции с помощью псевдоклассов
		мы будем модифицировать класс .button.
		Тем самым мы создим кнопки, которые реально работают и куда-то ведут.
</p>

<div class="title-under">ЭЛЕМЕНТЫ ССЫЛОК, ВМЕСТО ЭЛЕМЕНТОВ DIV<br> Link Elements, Not Div Elements</div>
<p>
    Прежде всего, нам нужно изменить наши кнопки так, чтобы они были элементами
&lt;a href&gt;, а не обычными элементами &lt;div&gt;, что показано ниже:
</p><p class="code">
<span class="code-blue">&lt;div class=</span><span class="code-rust">'button'</span> <span class="code-blue">href=</span><span class="code-rust">'nowhere.html'</span><span class="code-blue">&gt;</span>Button One<span class="code-blue">&lt;/a&gt;</span><br>
<span class="code-blue">&lt;div class=</span><span class="code-rust">'button call-to-action'</span> <span class="code-blue">href=</span><span class="code-rust">'nowhere.html'</span><span class="code-blue">&gt;</span>Button Two<span class="code-blue">&lt;/a&gt;</span>
</p><p>
    Добавив этот код и перезагрузив страницу, увидим, что некоторые
		стили потерялись, хотя мы используем все те же классы.
		Причина?
		Это происходит потому, что &lt;a&gt; по умолчанию это <a href="iih05-css-box-model.html#block-and-inline-elements">
		строчный элемент</a> со своим стандартным значением color.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-12-broken-button-styles-0d05d0.3f3182c0.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 12: изображение кнопок на веб-странице с искаженными стилями CSS
</small></figcaption>
</figure>

<p>
    Нам нужно изменить его на блоковый элемент и удалить некоторые стили ссылок
		по умолчанию.
</p>

<div class="title-under">СТИЛИ КНОПОК<br> Button Styles</div>

<p>
    Начнем с :link и :visited.
		Мы используем тот же шаблон, что и в предыдущей секции, но с одним отличием.
		Поскольку мы стилизуем кнопки, желательно сохранить одинаковый цвет для
		непосещенных и уже посещенных.
		Измените существующие правила .button следующим образом:
</p><p class="code">
<span class="code-blue">.button</span>:link,<span class="code-grey">
/* измените это */</span><br>
<span class="code-blue">.button</span>:visited {<span class="code-grey">
/* измените это */</span><br>
<span class="code-green">display</span>: block;<span class="code-grey">
/* добавьте это */</span><br>
<span class="code-green">text-decoration</span>: none;<span class="code-grey">
/* добавьте это */</span><br>
<br>
<span class="code-green">color</span>: #FFF;<span class="code-grey">
/*  остальное без изменений */</span><br>
<span class="code-green">background-color</span>: #5995DA;<br>
<span class="code-green">font-weight</span>: bold;<br>
<span class="code-green">padding</span>: 20px;<br>
<span class="code-green">text-align</span>: center;<br>
<span class="code-green">border</span>: 2px solid #5D6063;<br>
<span class="code-green">border-radius</span>: 5px;<br>
<br>
<span class="code-green">width</span>: 200px;<br>
<span class="code-green">margin</span>: 20px auto;<br>
}
</p><p>
    Обратите внимание на новые псевдоклассы :link и :visited в селекторе.
		Без них наш цвет не будет переопределять стандартный стиль браузера a:link.
<a href="#css-specificity">
		Cпецифичность</a> CSS более подробно объясняет, почему это так.
		Далее давайте займемся состояниями наведения курсора [hover]:
</p><p class="code">
<span class="code-blue">.button</span>:hover,<br>
<span class="code-blue">.button</span>:visited:hover {<br>
<span class="code-green">color</span>: #FFF;<br>
<span class="code-green">background-color</span>: #76AEED;<span class="code-grey">
/*  голубой */</span><br>
}
</p><p>
    При наведении курсора обе кнопки будут становиться светло-голубыми.
		И наконец, сделаем кнопку немного темнее, когда пользователь щелкает мышью.
		В этом нам поможет псевдокласс :active:
</p><p class="code">
<span class="code-blue">.button</span>:active,<br>
<span class="code-blue">.button</span>:visited:active {<br>
<span class="code-green">color</span>: #FFF;<br>
<span class="code-green">background-color</span>: #5995DA;<span class="code-grey">
	/*  синий */</span><br>
}
</p><p>
    Самое чудесное в этом то, что все только что заданные стили, можно
		использовать многократно, то есть сколько угодно.
		Примените класс .button к <em>любому</em> элементу HTML, и вы превратите его
		в интерактивную кнопку.
</p>

<div class="title-under">ВТОРАЯ КНОПКА<br>The Other Button</div>
<p>
    А как насчет второй кнопки?
		Она должна иметь желтый фон, но мы нарушили это правило с помощью кода из
		предыдущей секции.
		Наш селектор .button:link был более "конкретным", чем наше текущее
		правило .call-to-action, поэтому он получил приоритет.
		Опять же, мы рассмотрим это подробнее в конце данного урока.
</p><p>
    А пока давайте исправим это, применив некоторые псевдоклассы к нашему
		правилу .call-to-action.
		Замените существующее правило следующим (убедитесь, что данные изменения
		расположены <em>после</em> кода стилей .button из предыдущей секции):
</p><p class="code">
<span class="code-blue">.call-to-action</span>:link,<br>
<span class="code-blue">.call-to-action</span>:visited {<br>
<span class="code-green">font-style</span>: italic;<br>
<span class="code-green">background-color</span>: #EEB75A;<span class="code-grey">
/* Желтый */</span><br>
}<br>
<br>
<span class="code-blue">.call-to-action</span>:hover,<br>
<span class="code-blue">.call-to-action</span>:visited:hover {<br>
<span class="code-green">background-color</span>: #F5CF8E;<span class="code-grey">
/* Светло-желтый */</span><br>
}<br>
<br>
<span class="code-blue">.call-to-action</span>:active,<br>
<span class="code-blue">.call-to-action</span>:visited:active {<br>
<span class="code-green">background-color</span>: #EEB75A;<span class="code-grey">
/* Желтый */</span><br>
}
</p><p>
    Поскольку мы добавили класс .call-to-action только ко второй кнопке, только
		она станет желтой.
		Конечно, нам все еще нужен класс .button для обоих элементов &lt;a&gt;, потому
		что он определяет общие стили, такие как padding, округление углов рамки и
		жирность шрифта.
</p>

<div class="title" id="pseudo-classes-for-structure">псевдоклассы для структуры<br>
    Pseudo-Classes For Structure</div>
<p>
    Состояния ссылок - это лишь один из аспектов псевдоклассов.
		Существует также <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-classes">
		множество других псевдоклассов</a>, которые предоставляют дополнительную
		информацию об окружении элемента.
		Например, псевдокласс :last-of-type выбирает последний элемент определенного
		типа в его родительском элементе.
		Это дает нам альтернативу селекторам классов для выбора конкретных элементов.
</p><p>
    Например, мы можем использовать :last-of-type, чтобы добавить немного пустого
		пространства после последнего абзаца на нашей странице:
</p><p class="code">
<span class="code-strong">p:</span>last-of-type {<br>
<span class="code-green">margin-bottom</span>: 50px;<br>
}
</p><p>
    Это позволяет избежать селекции первых двух элементов &lt;p&gt;, <em>не требуя</em>
		нового атрибута class для последнего абзаца:
</p>

<figure>
<img class="pic-pages" src="./images/iih06-13-last-of-type-pseudo-class-8232e6.52e844d0.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 13: нижнее поле последнего абзаца на странице, стилизованное с
		помощью псевдокласса-селектора :last-of-type
</small></figcaption>
</figure>

<p>
    Мы даже можем использовать псевдокласс :first-of-type вместо класса .synopsis.
		Заменив существующее правило .synopsis следующим фрагментом, вы получите точно
		такую же страницу.
</p><p class="code">
<span class="code-strong">p:</span>first-of-type {<br>
<span class="code-green">color</span>: #7E8184;<br>
<span class="code-green">font-style</span>: italic;<br>
}
</p><p>
    У этого метода есть свои плюсы и минусы по сравнению с обычными классами.
		Например, он работает <em>только</em> в том случае, если наш синопсис - это
		элемент &lt;p&gt;.
		Если мы захотим создать многопараграфный синопсис, обернув кучу элементов &lt;p&gt;
		в &lt;div class='synopsis'&gt;, нам придется соответствующим образом
		переписать наш CSS.
		С другой стороны, метод псевдоклассов позволяет нам стилизовать определенные
		элементы без необходимости изменять HTML.
		Таким образом, мы получаем очень чистое разделение контента и внешнего вида.
</p>

<div class="title-under">ОГОВОРКИ<br>Caveats</div>
<p>
    На самом деле метод псевдоклассов немного сложнее.
		Но они все равно являются полезным инструментом - при условии, что вы знаете
		их особенности и недостатки.
		Селекторы :first-of-type и :last-of-type действуют только внутри родительского
		элемента.
		То есть p:first-of-type выбирает первый &lt;p&gt; в <em>каждом</em> элементе-контейнере.
</p><p>
    У нас есть один общий &lt;div&gt;, обертывающий наш контент (.page), поэтому для
		нас это не проблема.
		Однако посмотрите, что произойдет, если мы добавим это в нижнюю часть нашего
		элемента .page:
</p><p class="code">
&lt;div class=<span class="code-rust">'sidebar'</span>&gt;<br>
&lt;p&gt;If this page had a sidebar...&lt;/p&gt;<br>
&lt;p&gt;We’d have some problems with pseudo-classes.&lt;/p&gt;<br>
&lt;/div&gt;
</p><p>
    Мы еще не умеем делать настоящую боковую панель (об этом на <a href="iih07-floats.html">
		следующем уроке</a>), но это подчеркивает сложность псевдоклассов для структуры.
		Первый элемент &lt;p&gt; здесь также будет соответствовать p:first-of-type,
		потому что область действия псевдокласса ограничена родительским элементом.
</p><p>
    Если бы мы хотели избежать абзацев боковой панели и выбрать только первый &lt;p&gt;
		в нашем &lt;div class='page'&gt;, нам бы пришлось ограничить его область действия
		с помощью <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Child_combinator">
		дочернего селектора</a>, как показано ниже:
</p><p class="code">
<span class="code-blue">.page</span> > <span class="code-strong">p</span>:first-of-type {<br>
<span class="code-green">color</span>: #7E8184;<br>
<span class="code-green">font-style</span>: italic;<br>
}
</p><p>
    Все это - еще один пример того, что в удивительном мире HTML и CSS существует
		множество способов сделать одну и ту же вещь.
		Разные разработчики придерживаются разных школ и подходов.
		Кому-то нравится семантическая природа псевдоклассов, а кого-то заносит аж
		до использования атрибутов классов для каждого элемента HTML.
</p>

<div class="title" id="id-selectors">id-селекторы<br>ID Selectors</div>
<p>
    "Селекторы ID" - это более жесткая альтернатива селекторам классов.
		Они работают практически так же, за исключением того, что на странице может
		быть только <em>один</em> элемент с одинаковым ID.
		Это означает, что вы не можете повторно использовать стили.
		Вместо атрибута class они требуют атрибут id у HTML-элемента, который вы
		пытаетесь задействовать.
		Попробуйте добавить его к нашей второй кнопке:
</p><p class="code">
<span class="code-blue">&lt;a id=</span><span class="code-rust">'button-2'</span> <span class="code-blue">class=</span><span class="code-rust">'button'</span> <span class="code-blue">href=</span> <span class="code-rust">'nowhere.html'</span><span class="code-blue">&gt;</span>Button Two<span class="code-blue">&lt;/a&gt;</span>

</p><p>
    Соответствующий селектор CSS должен начинаться с знака хеш (#), а не с точки.
		Добавив следующее в файл styles.css, вы измените цвет текста нашей желтой кнопки:
</p><p class="code">
<span class="code-blue">#button-2</span> {<br>
<span class="code-green">color</span>: #5D6063;
<span class="code-grey">/* темно-серый */</span><br>
}
</p><p>
    Проблема в том, что как только мы захотим поделиться этим стилем с другой кнопкой,
		нам придется присвоить ей еще один уникальный атрибут id.
		Очень скоро наш CSS выглядел бы довольно неприглядно:
</p><p class="code">
<span class="code-grey">/* (обслуживать такой код очень напряжно) */</span><br>
<span class="code-blue">#button-2,<br>
#button-2,<br>
#checkout-button,<br>
#menu-bar-call-to-action</span> {<br>
<span class="code-green">color</span>: #5D6063;<br>
}
</p><p>
    По этой причине селекторы ID обычно не одобряются.
		Вместо них используйте селекторы классов.
</p>

<div class="title-under">ФРАГМЕНТЫ URL<br>URL Fragments </div>
<p>
    Атрибуты id должны быть уникальными, потому что они служат целью для
		"фрагментов URL", которые мы вроде как проглядели в нашем обсуждении URL.
		Фрагменты - это способ указать пользователю на определенную часть веб-страницы.
		Они выглядят как селектор ID, вставленный в конец URL.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-14-fragment-url-syntax-d310e8.1896124e.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 14: синтаксис URL - схема, домен, путь, фрагмент.
</small></figcaption>
</figure>

<p>
    Например, если бы мы хотели указать пользователю на нашу вторую кнопку,
		мы могли бы использовать следующее.
		Обратите внимание, что мы можем полностью опустить URL, если мы ссылаемся
		на другую секцию на этой же странице:
</p><p class="code">
<span class="code-grey">
&lt;!-- В случае, когда одна и та же страница --&gt;</span><br>
<span class="code-blue">&lt;a href=</span><span class="code-rust">'#button-2'</span>&gt;Go to Button Two<span class="code-blue">&lt;/a&gt;</span><br>
<br>
<span class="code-grey">
&lt;!-- В случае, когда путь ведет на другую страницу --&gt;</span><br>
<span class="code-blue">&lt;a href=</span><span class="code-rust">'selectors.html#button-2'</span>&gt;Go to Button Two<span class="code-blue">&lt;/a&gt;</span>
</p><p>
    Если вы добавите первый вариант на нашу страницу selectors.html и щелкнете
		по нему, вы увидите, как изменится URL в браузере.
		Чтобы увидеть переход ко второй кнопке, вам придется добавить на
		страницу еще немного фиктивного контента или сделать высоту окна очень маленькой,
		так как браузер ограничит прокрутку экрана видимым пространством страницы.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-15-dependency-between-fragments-and-css-4e4425.3d12288b.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 15: две стрелки от фрагментов URL к двум элементам HTML и две стрелки
		от правил CSS к этим же элементам
</small></figcaption>
</figure>

<p>
    Такая накладывающаяся функциональность - еще одна причина избегать селекторов ID.
		Они создают зависимость между URL-адресами вашего сайта и стилями CSS.
		Представьте, что вы используете кучу атрибутов id в заголовках в качестве
		фрагментов URL и селекторов ID.
		Если бы вы забывали обновлять таблицу стилей каждый раз, когда редактировали
		URL-адрес секции, вы бы фактически сломали свой сайт.
</p>

<div class="title" id="css-specificity">специфичность<br>css specificity</div>
<p>
    Ранее на этом уроке мы говорили о том, что <a href="#order-matters">очередность
		имеет значение</a>, когда речь идет о правилах CSS во внешней таблице стилей.
		При прочих равных условиях правила применяются сверху вниз.
		Это позволило нам переопределять правила предсказуемым образом.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-16-css-rule-order-3edc42.454c984f.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 16: четыре правила CSS с одинаковой спецификой, применяемые по порядку
</small></figcaption>
</figure>

<p>
    К сожалению, не все селекторы CSS созданы одинаковыми.
		"Специфичность CSS - это степень значимости различных категорий селекторов.
		Это означает, что одни селекторы <em>всегда</em> будут преобладать над другими, независимо от того, где они находятся в таблице стилей.
</p><p>
    Для начала давайте посмотрим, где это не нарушается.
		Если вы добавите следующее после существующего правила .call-to-action,
		оно отменит предыдущий цвет фона. Если вы поместите его в начало файла,
		он будет отменен позже, поэтому наша кнопка не станет красной.
		Это ожидаемое поведение.
</p><p class="code">
<span class="code-blue">.call-to-action</span>:link,<br>
<span class="code-blue">.call-to-action</span>:visited {<br>
<span class="code-green">background-color</span>: #D55C5F;<span class="code-grey">
	/* Красный */</span><br>
}
</p><p>
    Теперь посмотрите, что произойдет, если мы попытаемся сделать то же самое
		с селектором ID.
		Сначала удалите предыдущий фрагмент, а затем попробуйте добавить его <em>перед</em>
		существующими правилами .call-to-action:
</p><p class="code">
<span class="code-blue">#button-2</span> {<br>
<span class="code-green">background-color</span>: #D55C5F;<span class="code-grey">
/* Красный */</span><br>
}
</p><p>
    Селекторы ID имеют более высокую специфичность, чем селекторы классов.
		Поэтому наша вторая кнопка <em>будет</em> красной и все тут.
		Даже если мы попытаемся установить цвет фона с помощью .call-to-action:link
		ниже в нашей таблице стилей - это не поможет.
		Вся концепция "порядок имеет значение" работает только тогда, когда все ваши
		правила имеют одинаковую специфику.
</p>

<figure>
<img class="pic-pages" src="./images/iih06-17-css-specificity-and-rule-order-ec25f3.f5b9a7ff.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 17: четыре правила CSS. Третье правило имеет более высокую специфичность,
		поэтому четвертое игнорируется.
</small></figcaption>
</figure>

<p>
    Специфичность селекторов, которые мы рассматривали в этой главе, показана ниже,
		от наибольшего к наименьшему:
</p><ul>
<li>#button-2</li>
<li>.button:link</li>
<li>a:link and .synopsis em (они равноценны)</li>
<li>.button</li>
<li>a</li>
</ul><p>

</p><p>
    Это может привести к большой путанице.
		Это настолько большая проблема, что возникла целая методология под названием
<a href="https://getbem.com/introduction/">
		BEM</a>.
		BEM пытается сделать правила CSS многократно используемыми, превращая <em>все</em>
		в селекторы классов.
		Это полностью устраняет возможность возникновения проблем с определением специфичности.
</p>

<div class="title">РЕЗЮМЕ</div>
<p>
    На этом уроке мы получили практический опыт работы с селекторами классов,
		селекторами потомков, псевдоклассами, стилизацией ссылок и селекторами ID.
		Цель всего этого заключалась в том, чтобы иметь возможность выбирать
		конкретный элемент HTML из вашего CSS.
		Селекторы классов являются наиболее универсальными и имеют наименьшее
		количество недостатков.
		В результате они станут частью вашей повседневной жизни веб-разработчика.
</p><p>
    Нравится вам это или нет, начиная с этого урока все стало намного сложнее.
		Теперь мы можем заставить наш CSS взаимодействовать с HTML-документом
		несколькими разными способами.
		Более того, чем дальше, тем яснее станет взаимодействие между HTML-структурой и
    макетом веб-страницы.
		Из-за этого взаимодействия CSS и HTML бывает трудно понять, с чего начать
		создание новой веб-страницы.
</p><p>
<a href="iih02-basic-web-pages.html#structure-vs-presentation">
    Разделение контента и внешнего вида</a> помогает направить этот процесс.
		Прежде чем подать контент, нужно его разметить.
		Поэтому первым шагом обычно является разметка исходного контента с помощью HTML-тегов.
		После чего можно добавить атрибуты класса к элементам и стилизовать их один
		за другим.
		Если возникает необходимость в дополнительной структуре для создания нужного
		макета (например, превращения группы элементов в боковую панель), то вы
		начинаете помещать содержимое в контейнеры &lt;div&gt;.
</p><p>
    На этом уроке мы рассмотрели почти все селекторы CSS, используемые на реальных
		веб-сайтах.
		Теперь у вас есть инструменты, необходимые для более глубокого изучения
		сложных CSS-макетов.
		На следующем уроке <a href="/">данного учебника</a> мы узнаем, как создавать
		колонки и боковые панели с помощью "обтекающих" элементов CSS.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>FLOATS</h2>
<section>
<p>УРОК Nº 7.</p>
<p><em>
		Добротный учебник классической веб-разработки + user-friendly введение в CSS-верстку
</em></p>
</section>

<p>
    За последние несколько уроков мы научились управлять размером <a href="iih05-css-box-model.html">
		блоков</a> и пространством вокруг них, но в основном мы были привязаны к
		стандартному вертикальному потоку страницы.
		Блоковые элементы всегда располагались вертикально друг под другом, ограничивая
		нас одноколоночным макетом.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-01-vertical-vs-horizontal-stacking-064f76.97b50cda.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: вертикальный поток элементов в сравнении с
		горизонтальным потоком
</small></figcaption>
</figure>

<p id="grid-01">
    "Обтекание" [float] позволяют размещать элементы блокового уровня рядом, а не
		друг под другом.
		Это очень важно.
		С его помощью можно создавать всевозможные макеты, включая боковые колонны,
		многоколоночные страницы, grid-сетки и статьи в журнальном стиле с текстом,
		обтекающим изображение.
		Именно здесь наконец-то мы начнем создавать настоящие веб-страницы.
</p><p>
    В современных веб-сайтах макеты на основе плавающих элементов в основном
		заменены на <a href="iih08-flexbox.html">Flexbox</a>.
		Но это не значит, что этот урок не стоит читать.
		На протяжении более десяти лет плавающие макеты служили основой большинству
		веб-сайтов, а это значит, что в какой-то момент своей карьеры вы
		с ними обязательно столкнетесь.
</p><p>
		Возможно, ограниченная природа обтекающих элементов сделает их более мягким
		введением в верстку CSS, чем Flexbox.
		Вместо того чтобы быть перегруженными всеми возможностями Flexbox, это ваш шанс
		сосредоточиться на <em>процессе</em> создания сложного макета веб-страницы.
</p>

<div class="title">подготовка<br>setup</div>
<p>
    На этом уроке на примере довольно простого проекта мы рассмотрим CSS-понятие
		"обтекание" [float].
		Вместо того чтобы работать с HTML-контентом, как это было в предыдущих главах,
		мы будем стилизовать кучу пустых элементов &lt;div&gt;.
		В итоге мы получим нечто похожее на изображение ниже.
		Это довольно сильно отличается от тех типов веб-страниц, которые мы создавали
		до сих пор, не так ли?
</p>

<figure id="grid-02">
<img class="pic-pages" src="./images/iih07-02-floats-final-example-e0e9f7.a06b11e5.png"
width="45%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2: веб-страница с боковой float-панелью, текстом, обтекающим картинку
		и плавающей сеткой в футере
</small></figcaption>
</figure>

<p>
    Сначала создайте новую папку floats, затем добавьте новую веб-страницу
		floats.html со следующей разметкой:
</p><p class="code">
<span class="code-green">&lt;!DOCTYPE html&gt;</span><br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Floats&lt;/title&gt;<br>
&lt;link rel='stylesheet' href='styles.css'/&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
&lt;div class='page'&gt;<br>
&lt;div class='menu'&gt;Menu&lt;/div&gt;<br>
&lt;div class='sidebar'&gt;Sidebar&lt;/div&gt;<br>
&lt;div class='content'&gt;Content&lt;/div&gt;<br>
&lt;div class='footer'&gt;Footer&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Это дает нам базовую структуру большинства сайтов в Интернете.
		У нас есть место для размещения навигационного меню, боковой панели,
		основного контента и футера.
		Все эти элементы можно считать <a href="iih06-css-selectors.html#container-divs">
		div-контейнерами</a>, в которые помещается HTML-контент.
</p><p>
    Открыв файл floats.html в браузере, вы не увидите ничего особенного, потому
		что у пустых элементов высота равна нулю.
		Мы исправим это в следующей секции.
</p><p class="code">
<span class="code-strong">*</span> {<br>
<span class="code-green">margin</span>: 0;<br>
<span class="code-green">padding</span>: 0;<br>
<span class="code-green">box-sizing</span>: border-box;<br>
}
</p><p>
    Не забудьте создать таблицу стилей styles.css, как показано выше.
		Этот код <a href="iih05-css-box-model.html#resetting-styles">
		сбрасывает стандартное поведение блока</a>,
</p>

<div class="title">стандартная модель поведения html-макета<br>default html layout behavior</div>
<p>
    Плавающие элементы изменяют стандартный макет веб-страницы, поэтому для начала
		нам следует разобраться, что именно является "стандартным" поведением.
		Мы уже говорили об этом в разделе <a href="iih05-css-box-model.html#block-and-inline-elements">
		Блоковые и строчные элементы</a>, но сейчас это приобретает гораздо большее значение.
</p><p>
    Мы можем лучше рассмотреть наш пример страницы, добавив некоторые цвета фона
		и четко выраженную высоту для каждого из наших элементов &lt;div&gt;.
		Добавьте следующее в файл styles.css:
</p><p class="code">
<span class="code-blue">.menu</span> {<br>
<span class="code-green">height</span>: 100px;<br>
<span class="code-green">background-color</span>: #B2D6FF;
<span class="code-grey"> /* умеренно синий */</span><br>
}<br>
<br>
<span class="code-blue">.sidebar</span> {<br>
<span class="code-green">height</span>: 300px;<br>
<span class="code-green">background-color</span>: #F09A9D;
<span class="code-grey"> /* красный */</span><br>
}<br>
<br>
<span class="code-blue">.content</span> {<br>
<span class="code-green">height</span>: 500px;<br>
<span class="code-green">background-color</span>: #F5CF8E;
<span class="code-grey"> /* желтый */</span><br>
}<br>
<br>
<span class="code-blue">.footer</span> {<br>
<span class="code-green">height</span>: 200px;<br>
<span class="code-green">background-color</span>: #D6E9FE;
<span class="code-grey"> /* голубой */</span><br>
}
</p><p>
    В результате мы получаем красивую радугу, но это не совсем то, что нам нужно,
		хотя и демонстрирует некоторые полезные концепции.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-03-default-css-layout-behavior-9b2b1f.0d2b49a4.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: веб-страница с четырьмя цветными блоками, появляющимися
		вертикально один за другим
</small></figcaption>
</figure>

<p>
    Здесь важно то, что каждый элемент уровня блока заполняет 100 % ширины
		родительского элемента (в данном случае &lt;div class='page'&gt;), и они
		отображаются вертикально друг под другом.
		И по-прежнему мы ограничены одноколоночным макетом.
</p><p>
    Обычно высота этих блоков определяется автоматически в зависимости от содержащегося
		в них контента.
		Однако на этом уроке речь идет об управлении макетами, поэтому мы не будем
		иметь дело с реальным контентом.
		Вот почему нам нужны <a href="iih05-css-box-model.html#explicit-dimensions">
		явно выраженные свойства высоты</a>.
</p><p>
    Стоит взглянуть на то, что происходит, когда мы уменьшаем ширину элемента.
		Обновите наше правило .sidebar, изменив его на следующее:
</p><p class="code">
<span class="code-blue">.sidebar</span> {<br>
<span class="code-green">width</span>: 200px;
<span class="code-grey"> /* добавьте это */</span><br>
<span class="code-green">height</span>: 300px;<br>
<span class="code-green">background-color</span>: #F09A9D;<br>
}
</p><p>
    Элемент боковой панели становится более узким, но остальные блоки остаются
		на прежних местах.
		Все блоки по-прежнему отображаются вертикально один за другим.
		Именно такое поведение мы и будем получать с помощью плавающих элементов.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-04-default-css-layout-behavior-explicit-width-97b8ac.9348c1c1.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: веб-страница с красным блоком боковой панели в левой части
		страницы и белым фоном рядом с ним
</small></figcaption>
</figure>

<div class="title">перемещение плавающего элемента<br>floating an element</div>
<p>
    Свойство CSS float дает нам контроль над <em>горизонтальным</em> положением
		элемента.
		Чтобы "сплавить" боковую панель влево, мы командуем браузеру выровнять ее по левой
		стороне страницы.
		Переместите нашу боковую панель влево с помощью следующей строки:
</p><p class="code">
	<span class="code-blue">.sidebar</span> {<br>
	<span class="code-green">float</span>: left;
	<span class="code-grey"> /* добавьте это */</span><br>
	<span class="code-green">width</span>: 200px;<br>
	<span class="code-green">height</span>: 300px;<br>
	<span class="code-green">background-color</span>: #F09A9D;<br>
}
</p><p>
    Однако это не только <em>выравнивает</em> боковую панель, но и сообщает окружающим
		элементам, что они могут <em>обтекать</em> боковую панель, а не начинаться
		под ней.
		Как если бы боковая панель находилась внутри блока .content, так что любая
		HTML-разметка в .content обходила бы блок боковой панели.
		Таким образом, мы получаем макет в стиле журнальной страницы:
</p>

<figure>
<img class="pic-pages" src="./images/iih07-05-floated-sidebar-d926d5.58d46437.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5: веб-страница с красным блоком боковой панели, "плавающим" поверх
		следующего элемента
</small></figcaption>
</figure>

<p>
    Вы также можете перемещать элементы вправо, как показано ниже (однако мы оставим
		нашу боковую панель перемещенной влево).
		Или, если вы переопределяете объявление float, вы можете отменить его с помощью
		значения none.
		Это наиболее распространенные значения для свойства float.
</p><p class="code">
<span class="code-strong">float: right;</span>
<span class="code-grey">/* Выравнивание по правому краю */</span><br>
<span class="code-strong">float: none;</span>
<span class="code-grey">/* Возврат к стандартному потоку */</span>
</p><p>
    Теперь у нас есть все необходимые инструменты для выравнивания элементов
		на уровне блоков: плавающие элементы для выравнивания по левому/правому краю
		и метод auto-margins для выравнивания по центру.
		Помните, что это относится только к <em>блоковым</em> блокам.
		Строчные [inline] блоки выравниваются с помощью свойства text-align, как <a href="iih05-css-box-model.html#aligning-boxes">
		описано ранее</a>.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-06-floats-and-auto-margin-for-alignment-536a81.5e77dde7.png"
width="65%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: float left (блок в левой части контейнера), auto margins (блок
		в центре контейнера), float right (блок в правой части контейнера)

</small></figcaption>
</figure>

<div class="title">перемещение внутри родителей<br>floating inside of parents</div>
<p>
    Плавающие блоки всегда выравниваются по левому или правому краю родительского
		элемента.
		В нашем примере родителем боковой панели является &lt;div class='page'&gt;,
		ширина которого равна ширине окна браузера.
		Поэтому наша боковая панель плавает в крайней левой части страницы.
</p><p>
    Давайте изменим это, придав нашей странице макет фиксированной ширины.
		И снова пригодится метод центрирования auto-margins.
		Добавьте в файл styles.css следующее:
</p><p class="code">
<span class="code-blue">.page</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">margin</span>: auto;<br>
}
</p><p>
    Теперь мы видим, что .sidebar плавает слева от контейнера .page, а не у
		края окна браузера.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-07-floating-in-fixed-width-page-a9c965.2c1c55f4.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: веб-страница с цветными блоками, расположенными по центру браузера
</small></figcaption>
</figure>

<p>
    Подобное позиционирование вложенных div-контейнеров - это способ создания
		сложных макетов веб-сайтов.
		Мы начали с .page, чтобы отцентрировать <em>всю страницу</em>.
		Затем выровняли по левому краю боковую панель <em>внутри</em> этой
		отцентрированной страницы.
		Все может оказаться гораздо сложнее, но наш простой пример демонстрирует
		простую истину верстки CSS: все является блоком внутри блока внутри другого
		блока.
</p>

<div class="title">множественные плавающие элементы<br>multiple floats</div>
<p>
    Давайте рассмотрим наш плавающий элемент "в журнальном стиле", добавив
		четко выраженную ширину в блок .content:
</p><p class="code">
<span class="code-blue">.content</span> {<br>
<span class="code-green">width</span>: 650px;
<span class="code-grey">/* Добавьте это */</span><br>
<span class="code-green">height</span>: 500px;<br>
<span class="code-green">background-color</span>: #F5CF8E;<br>
}
</p><p>
    Это наглядно показывает, что наша боковая панель находится <em>внутри</em>
		блока .content: если вы сделаете их скриншот, то получите изображение шириной
		650 пикселей, а не 850 (ширина нашей боковой панели - 200 пикселей).
</p>

<figure>
<img class="pic-pages" src="./images/iih07-08-floating-inside-another-container-1cfd76.02349b0d.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: на веб-странице показана плавающая слева красная боковая панель
		поверх статично расположенного элемента
</small></figcaption>
</figure>

<p>
    Такое поведение плавающего элемента хорошо для картинок (что мы <a href="#floats-for-content">
		рассмотрим позже</a>), но для макета страницы мы хотим, чтобы блок контента
		находился <em>рядом с</em> боковой панелью, а не обтекал ее.
		Для этого нам нужно указать блоку контента, чтобы он тоже "плавал" слева.
		Добавьте еще одну строку в правило .content:
</p>

<p class="code">
<span class="code-blue">.content</span> {<br>
<span class="code-green">float</span>: left;
<span class="code-grey">/* Добавьте это */</span><br>
<span class="code-green">width</span>: 650px;<br>
<span class="code-green">height</span>: 500px;<br>
<span class="code-green">background-color</span>: #F5CF8E;<br>
}
</p><p>
    Когда вы располагаете несколько плавающих элементов в одном направлении,
		они будут располагаться горизонтально, как в стандартном алгоритме вертикального
		расположения, только повернутые на 90 градусов.
		Приведенный выше код приводит к тому, что весь наш блок контента оказывается
		справа от боковой панели, а не оборачивается вокруг нее.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-09-two-floats-next-to-each-other-37f154.455c9b95.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: веб-страница, показывающая красную боковую панель рядом с плавающим
		элементом, выровненным по левому краю
</small></figcaption>
</figure>

<p>
    Это дает нам полный контроль над горизонтальным выравниванием наших блочных блоков.
		Попробуйте поэкспериментировать со значениями плавающих элементов для .sidebar
		и .content, и вы увидите, что в вашем распоряжении уже есть несколько различных
		макетов:
</p>

<figure>
<img class="pic-pages" src="./images/iih07-10-float-layout-combinations-e52716.fa30c391.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10: четыре потенциальные комбинации левого и правого плавающих
		элементов для двух элементов
</small></figcaption>
</figure>

<p>
    Прежде чем двигаться дальше, убедитесь, что оба элемента плавают слева.
		Это позволит создать макет для боковой панели и блоков контента, но, к сожалению,
		испортит наш элемент .footer.
</p>

<div class="title">после float<br>After a Float</div>
<p>
    Вы, наверное, заметили, что наш футер отображается в правом верхнем углу,
		прямо под .menu.
		Это происходит потому, что плавающие элементы удаляются из нормального
		потока страницы.
		Высота наших плавающих элементов не влияет на вертикальное положение футера,
		поэтому он просто размещается под последним элементом, который <em>не был</em>
		плавающим.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-11-floats-outside-of-normal-flow-5dc559.dc04b315.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: веб-страница с прозрачными блоками, показывающая плавающие
		элементы поверх статично расположенного футера
</small></figcaption>
</figure>

<p>
    Мы можем увидеть это более четко, добавив красную рамку вокруг нашего
		элемента .page:
</p><p class="code">
<span class="code-blue">.page</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">margin</span>: 0 auto;<br>
<span class="code-green">border</span>: 1px solid red;
<span class="code-grey">/* Добавьте это */</span><br>
}
</p><p>
    Обратите внимание, что рамка есть только вокруг элементов .menu и .footer.
		Словно плавающих элементов там вообще не было.
		Есть два способа исправить это: очистить плавающий элемент и скрыть переполнение.
</p>

<div class="title-under">ОЧИСТКА ПЛАВАЮЩИХ ЭЛЕМЕНТОВ<br>Clearing Floats</div>
<p>
	"Очистка" плавающего элемента - это когда мы командуем блоку игнорировать все
	плавающие элементы, которые появляются перед ним.
	Вместо того чтобы обтекать плавающий блок, очищенный элемент всегда появляется
	после всех плавающих элементов.
	Это как бы заставляет блок вернуться в вертикальный поток страницы по умолчанию.
</p><p>
    Мы можем использовать свойство clear, чтобы опустить наш футер в нижнюю
		часть страницы:
</p><p class="code">
	<span class="code-blue">.footer</span> {<br>
	<span class="code-green">clear</span>: both;
	<span class="code-grey">/* Добавьте это */</span><br>
	<span class="code-green">height</span>: 200px;<br>
	<span class="code-green">background-color</span>: #FD6E9FE;<br>
	}
</p><p>
    Обычно нужно очистить и левый, и правый плавающие элементы, как мы сделали
		здесь, но вы можете выбрать очистку только одного или другого элемента,
		указав значения left или right.
		Обратите внимание, что красная рамка теперь проходит по всему футеру,
		указывая на то, что плавающие элементы действительно учитываются при
		определении высоты контейнера .page:
</p>

<figure>
<img class="pic-pages" src="./images/iih07-12-clearing-a-float-44a4d5.3120fe8a.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 12: веб-страница, показывающая, как футер опускается после очистки
		к нижней части плавающих элементов
</small></figcaption>
</figure>

<p>
    В зависимости от типа макета, который вы пытаетесь создать, это вполне
    приемлемое решение.
		На этом можно было бы остановиться, но мы собираемся подробнее изучить
		поведение плавающих элементов, превратив нашу страницу в макет без окружающих полей,
		в котором цвета фона заполняют все окно браузера.
</p><p>
    Посмотрите, что произойдет, если мы уберем меню и футер из элемента .page.
		Измените элемент &lt;body&gt; так, чтобы он соответствовал следующему:
</p><p class="code">
&lt;body&gt;<br>
&lt;div class='menu'&gt;Menu&lt;/div&gt;<br>
<br>
&lt;div class='page'&gt;<br>
&lt;div class='sidebar'&gt;Sidebar&lt;/div&gt;<br>
&lt;div class='content'&gt;Content&lt;/div&gt;<br>
&lt;/div&gt;<br>
<br>
&lt;div class='footer'&gt;Footer&lt;/div&gt;<br>
&lt;/body&gt;<br>
</p><p>
    Поскольку .menu и .footer находятся за пределами фиксированной ширины .page,
		они занимают всю ширину окна.
		И это именно то, что нам нужно.
		Однако обратите внимание, что у .page снова нулевая высота, несмотря на то,
		что футер по-прежнему освобождает боковую панель и блоки контента.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-13-full-bleed-layout-broken-clear-58057f.fed0b0ab.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 13: веб-страница, выделяющая нулевую высоту .page &lt;div&gt;
		с плавающими элементами
</small></figcaption>
</figure>

<p>
    И снова единственные элементы в .page - плавающие элементы, поэтому они не
		учитываются при определении высоты.
		Другими словами, перемещение футера за пределы контейнера .page нарушило наше
		исправление с помощью свойства clear.
</p>

<div class="title-under">СКРЫТИЕ ПЕРЕПОЛНЕНИЯ<br>Hiding Overflow</div>
<p>
    Очистка плавающих элементов решает проблему высоты только в том случае,
		если <em>внутри</em> элемента-контейнера есть элемент, к которому можно добавить
		свойство clear.
		Теперь, когда наш футер находится за пределами .page, нам нужен новый способ
		заставить плавающие элементы учитывать высоту их контейнера.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-14-methods-for-clearing-floats-6429d9.ec231f81.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 14: слева: очистка с помощью дочернего элемента. Справа: очистка
		с помощью родительского элемента
</small></figcaption>
</figure>

<p>
    Решением является <a href="https://developer.mozilla.org/ru/docs/Web/CSS/overflow">
		свойство overflow</a>.
		Добавляя overflow: hidden к контейнеру div, мы указываем ему на необходимость
		распознавать высоту всех плавающих элементов, которые он содержит.
		Вот как мы можем добавить цвет фона к элементу .page и добиться того,
		чтобы он действительно отображался:
</p><p class="code">
<span class="code-blue">.page</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">margin</span>: 0 auto;<br>
<span class="code-green">overflow</span>: hidden;
<span class="code-grey">/* Добавьте это */</span><br>
<span class="code-green">background-color</span>: #EAEDF0;
<span class="code-grey">/* Добавьте это */</span><br>
}
</p><p>
    Теперь вы увидите светло-серый фон на странице .page вместо белого, задаваемого
		по умолчанию.
		Это еще не полноценный фон (мы рассмотрим его в следующей секции).
		Важным моментом здесь является поведение этого самого overflow: hidden.
		Без него мы бы не смогли увидеть фон контейнера .page, потому что его высота
		была бы нулевой.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-15-full-bleed-layout-overflow-hidden-826f9e.15d9dbed.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 15: серый фон, заполняющий всю высоту контейнера .page &lt;div&gt;
</small></figcaption>
</figure>

<p>
    Подводя итог, можно сказать, что если у вас есть избыточный элемент HTML
		в нижней части контейнера div, используйте прозрачное решение.
		В прочих случаях добавьте объявление overflow: hidden к элементу контейнера.
		Суть обоих вариантов заключается в том, что вам нужен способ указать браузеру
		на необходимость включения плавающих элементов в высоту их контейнерного
		элемента, чтобы их фон отображался.
</p>

<div class="title">макеты во всю ширину окна<br>Full-Bleed Layouts</div>
<p>
    Далее мы хотим сделать так, чтобы фон нашей .page заполнял все окно браузера,
		не изменяя выравнивания боковых панелей и блоков контента.
		Проблема в том, что наш .page занят центрированием всего, и мы не можем
		использовать его для полноцветного фона, поскольку центрирование требует
		явно выраженного свойства width.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-16-full-bleed-layout-with-container-85a6d1.dea28519.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 16: веб-страница, на которой виден серый фон, заполняющий всю
		высоту .page &lt;div&gt;, вплоть до левого и правого краев
</small></figcaption>
</figure>

<p>
    Пора сделать <em>еще один</em> контейнер div.
		Поместив блок вокруг .page, мы продолжаем центрировать материал, одновременно
		предоставляя место для определения свойства background-color.
		Измените &lt;body&gt; как показано ниже:
</p><p class="code">
	&lt;body&gt;<br>
	&lt;div class='menu'&gt;Menu&lt;/div&gt;<br>
	<br>
&lt;div class='container'&gt; <span class="code-grey">&lt;!-- Добавьте это --&gt;</span><br>
&lt;div class='page'&gt;<br>
&lt;div class='sidebar'&gt;Sidebar&lt;/div&gt;<br>
&lt;div class='content'&gt;Content&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt; <span class="code-grey">&lt;!-- Добавьте это --&gt;</span><br>
<br>
&lt;div class='footer'&gt;Footer&lt;/div&gt;<br>
&lt;/body&gt;<br>
</p><p>
    Помните, что при стандартном отображении блоков [default block-rendering behavior]
		элементы заполняют ширину своего контейнера.
		Поэтому мы можем перенести объявление фонового цвета в правило .container,
		чтобы получить фон на всю щирину страницы:
</p><p class="code">
<span class="code-blue">.page</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">margin</span>: 0 auto;<br>
}<br>
<br>
<span class="code-blue">.container</span> {<br>
<span class="code-green">overflow</span>: hidden;<br>
<span class="code-green">background-color</span>: #EAEDF0;<br>
}
</p><p>
    Как и в предыдущей секции, нам по-прежнему нужна строка overflow: hidden,
		чтобы заставить .container обращать внимание на высоту плавающих элементов.
		Без нее мы бы не увидели цвет фона, потому что высота .container была бы нулевой.
</p><p>
    Таким образом, мы получаем три вложенных элемента &lt;div&gt; для оформления
		нашей страницы: обертку .container для заполнения всего окна браузера, страницу
		фиксированной ширины .page для выравнивания по центру и, наконец, блоки .sidebar
		и .content, выровненные по левому краю.
		Подобное вложение и выравнивание довольно типично для большинства макетов
		веб-сайтов.
</p>

<div class="title">обтекание для колонок одной ширины<br>Floats for Equal-Width Columns</div>
<p>
    Мы уже рассмотрели макет страницы с боковой панелью, макет с фиксированной
		шириной и макет с заполнением всего окна браузера.
		Float-элементы также можно использовать для создания многоколоночных макетов.
		Это работает так же, как и плавающие элементы .sidebar и .content - просто их
		будет больше.
</p><p>
    Следующий шаг - добавить три колонки одинаковой ширины в наш футер.
		Обновите элемент &lt;footer&gt; следующим образом:
</p><p class="code">
&lt;div class='footer'&gt;<br>
&lt;div class='column'&gt;&lt;/div&gt;<br>
&lt;div class='column'&gt;&lt;/div&gt;<br>
&lt;div class='column'&gt;&lt;/div&gt;<br>
&lt;/div&gt;
</p><p>
    Мы можем оформить каждую из этих колонок так же, как и остальную часть нашей
		страницы.
		Добавьте новое правило в styles.css:
</p><p class="code">
<span class="code-blue">.column</span> {<br>
<span class="code-green">float</span>: left;<br>
<span class="code-green">width</span>: 31%;<br>
<span class="code-green">margin</span>: 20px 1.15%;<br>
<span class="code-green">height</span>: 160px;<br>
<span class="code-green">background-color</span>: #B2D6FF;
<span class="code-grey"> /* умеренно синий */</span><br>
}
</p><p>
    Впервые мы используем процентные значения вместо пиксельных.
		Проценты в CSS относятся к ширине родительского элемента.
		В результате мы получаем три колонки, размер которых автоматически изменяется
		на одну треть окна браузера.
		Измените размер окна браузера, и вы увидите, как наши колонки увеличиваются
		и уменьшаются соответственно.
		Это начало <a href="iih10-responsive-design.html">адаптивного дизайна</a>.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-17-floats-for-columns-8a52b0.246a8ba6.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 17: веб-страница с футером, состоящим из трех дочерних элементов
		одинаковой ширины
</small></figcaption>
</figure>

<p>
    Однако давайте не будем упускать из виду главный тезис этого урока: плавающие
		элементы позволяют располагать элементы горизонтально, а не вертикально.
		Изменяя ширину плавающих элементов, получаем всевозможные варианты
		компоновки, от боковых панелей до нескольких колонок и сеток.
</p>

<div class="title" id="floats-for-grids">обтекание для сеток<br>Floats for Grids</div>
<p>
    Хотите сетку [grid] в футере вместо 3 колонок?
		Запросто!
		Когда не хватает места для горизонтальной укладки плавающего элемента, он
		опускается на следующую строку.
		Все, что нам нужно сделать, это добавить еще несколько элементов .column:
</p><p class="code">
&lt;div class='footer'&gt;<br>
&lt;div class='column'&gt;&lt;/div&gt;<br>
&lt;div class='column'&gt;&lt;/div&gt;<br>
&lt;div class='column'&gt;&lt;/div&gt;<br>
&lt;div class='column'&gt;&lt;/div&gt;<br>
&lt;div class='column'&gt;&lt;/div&gt;<br>
&lt;div class='column'&gt;&lt;/div&gt;<br>
&lt;/div&gt;
</p><p>
    Вуаля! Сетка! Ну, почти...
</p>

<figure>
<img class="pic-pages" src="./images/iih07-18-floats-for-grids-7ed8b0.b6737f70.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 18: веб-страница с футером, имеющим 3 колонки и 2 строки дочерних
		элементов
</small></figcaption>
</figure>

<p id="grid-03">
    Наш фон футера слишком короток.
		К счастью, мы уже знаем, как это исправить.
		Давайте заменим явную высоту футера на другую - overflow: hidden, чтобы он
		мог вместить любое количество элементов сетки:
</p><p class="code">
<span class="code-blue">.footer</span> {<br>
<span class="code-green">overflow</span>: hidden;<br>
<span class="code-green">background-color</span>: #D6E9FE;<br>
}
</p><p>
    С помощью этой же техники можно создавать сетки любого размера.
		Например, для создания фотогалереи с кучей миниатюр достаточно поместить
		элементы сетки в .page, а не в футер, и добавить к ним элементы &lt;img/&gt;.
		Но, опять же, помните, что <a href="iih08-flexbox.html">flexbox</a> - это
		более современный способ создания подобных макетов.
</p>

<div class="title-under">О СТАНДАРТАХ НАИМЕНОВАНИЯ ФАЙЛОВ<br>
    A Brief Note on Naming Conventions </div>
<p>
    Название класса .column уже не совсем корректно.
		Этот сценарий - хороший пример того, почему мы хотим избегать имен классов,
<a href="iih06-css-selectors.html#class-naming-conventions">которые ссылаются
	  на внешний вид</a>.
		"Column" не очень подходит, потому что содержащийся в ней контент не обязательно
		должен отображаться в нескольких колонках (например, в мобильном макете,
		скорее всего, будет только одна колонка).
		Лучшим названием было бы что-нибудь вроде .footer-item, но мы оставим это на
		ваше усмотрение.
</p>

<div class="title" id="floats-for-content">обтекание для контента<br>Floats for Content</div>
<p>
    Существует два аспекта определения макета веб-страницы.
		У вас есть общая структура страницы, над которой мы работали на протяжении
		всей этой главы.
		Это такие вещи, как расположение боковой панели, размер навигационного меню и т. д.
		Другой аспект макетов - это стилизация отдельных HTML-компонентов (вашего
		фактического контента), которые находятся внутри общей структуры страницы.
</p><p>
    Процесс работы с последними такой же, просто они вложены внутрь первых.
		Давайте добавим немного фиктивного контента в наш элемент .content, чтобы
		было с чем экспериментировать:
</p><p class="code">
&lt;div class='container'&gt;<br>
&lt;div class='page'&gt;<br>
&lt;div class='sidebar'&gt;&lt;/div&gt;<br>
&lt;div class='content'&gt;<br>
<br>
&lt;p&gt;Ad netus sagittis velit orci est non ut urna taciti metus donec magnis<br>
hendrerit adipiscing mauris sit a proin ultrices nibh.&lt;/p&gt;<br>
<br>
&lt;p&gt;Enim suspendisse ac scelerisque nascetur vestibulum parturient sed mi<br>
dolor eu non adipiscing non neque scelerisque netus ullamcorper sed<br>
parturient integer.Eros dui risus non sodales ullamcorper libero a dis<br>
cubilia a orci iaculis cursus.&lt;/p&gt;<br>
<br>
&lt;p&gt;Egestas at aliquam a egestas accumsan cum elementum consectetur conubia<br>
tristique eu et vitae condimentum in ante consectetur suscipit a a duis<br>
vestibulum gravida morbi sagittis.Parturient scelerisque facilisis<br>
ullamcorper a a pretium a nisl parturient semper senectus accumsan ipsum<br>
mus scelerisque eget ridiculus.Accumsan dolor a.&lt;/p&gt;<br>
<br>
&lt;p&gt;Ligula taciti vel primis sit a tincidunt habitant parturient parturient<br>
in parturient ante nulla consectetur sem.Facilisis parturient litora.&lt;/p&gt;<br>
<br>
&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;
</p><p>
    У нас есть изображение и несколько абзацев, которые мы можем стилизовать
		так же, как и наши структурные div'ы.
		Например, давайте создадим макет в журнальном стиле, плавающий элемент
		изображения и текст вокруг него.
		Для этого в таблицу стилей нужно добавить еще несколько правил:
</p><p class="code">
<span class="code-blue">.content</span> {<br>
<span class="code-green">padding</span>: 20px;<br>
}<br>
<br>
<span class="code-blue">.article-image</span> {<br>
<span class="code-green">float</span>: left;<br>
<span class="code-green">width</span>: 300px;<br>
<span class="code-green">height</span>: 200px;<br>
<span class="code-green">margin-right</span>: 20px;<br>
<span class="code-green">margin-bottom</span>: 20px;<br>
}<br>
<br>
<span class="code-strong">p</span> {<br>
<span class="code-green">margin-bottom</span>: 20px;<br>
}
</p><p>
    Обратите внимание, что у нас есть плавающий элемент внутри плавающего элемента,
		и все работает просто замечательно.
		Создание сайта - это рекурсивный процесс: вы создаете высокоуровневую структуру
		для работы, а затем заполняете ее реальным контентом.
		Более сложные макеты могут потребовать еще один или два уровня вложенности,
		но идея та же.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-19-floats-final-example-e0e9f7.a06b11e5.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 19: веб-страница, показывающая плавающий элемент с обтекающим его
		текстовым контентом
</small></figcaption>
</figure>

<div class="title-under">СКРЫТИЕ ПЕРЕПОЛНЕНИЯ (ДЛЯ КОНТЕНТА)<br>Hiding Overflow (For Content)</div>
<p>
    Примеры вложенных макетов можно встретить повсюду.
		В качестве последнего примера рассмотрим базовую тему комментариев пользователя.
		У вас есть изображение, плавающий элемент слева от заголовка и текст рядом с ним:
</p>

<figure>
<img class="pic-pages" src="./images/iih07-20-overflow-hidden-for-content-735981.e4516a8e.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 20: веб-страница, показывающая футер с иконкой и текстом рядом с
		ней, но не обтекающая его из-за overflow: hidden
</small></figcaption>
</figure>

<p>
    Давайте попробуем создать это в нашем футере.
		В ваш любимый элемент .column добавьте следующее:
</p><p class="code">
&lt;div class='column'&gt;<br>
&lt;div class='avatar'&gt;&lt;/div&gt;<br>
&lt;h3 class='username'&gt;Bob Smith&lt;/h3&gt;<br>
&lt;p class='comment'&gt;Aptent vel egestas vestibulum aliquam ullamcorper volutpat<br>
ullamcorper pharetra hac posuere a rhoncus purus molestie torquent. Scelerisque<br>
purus cursus dictum ornare a phasellus. A augue venenatis adipiscing.&lt;/p&gt;<br>
&lt;/div&gt;<br>
</p><p>
    А также соответствующие правила CSS:
</p><p class="code">
<span class="code-blue">.avatar</span> {<br>
<span class="code-green">float</span>: left;<br>
<span class="code-green">width</span>: 60px;<br>
<span class="code-green">height</span>: 60px;<br>
<span class="code-green">margin</span>: 25px;<br>
<span class="code-green">border-radius</span>: 40px;<br>
<span class="code-green">background-color</span>: #D6E9FE;<br>
}<br>
<br>
<span class="code-blue">.username</span> {<br>
<span class="code-green">margin-top</span>: 30px;<br>
}<br>
<br>
<span class="code-blue">.comment</span> {<br>
<span class="code-green">margin</span>: 10px;<br>
<span class="code-green">overflow</span>: hidden;
<span class="code-grey"> /* это важно */</span><br>
}
</p><p>
    Это показывает еще один случай использования нашего трюка с overflow: hidden.
		Наклеив его на наш блок .comment, мы убедились, что текст "горизонтально очищен"
		(это не технический термин) от плавающего элемента.
		Без этого последняя строка текста .comment оказалась бы под изображением.
</p>

<figure>
<img class="pic-pages" src="./images/iih07-21-no-overflow-hidden-for-content-1cb097.455f0920.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 21: веб-страницы со скрытым переполнением (with hidden overflow:
		текст выровнен по левому краю) и без скрытого переполнения (without...: текст обтекает иконку)
</small></figcaption>
</figure>

<p>
    Другими словами, overflow: hidden ломает макет в журнальном стиле из предыдущей
		секции, но очень полезным образом.
</p>

<div class="title">РЕЗЮМЕ</div>
<p>
    В этой главе мы впервые познакомились с максимально реалистичными макетами
		веб-страниц.
		Мы узнали, как размещать плавающие элементы слева и справа, как работать с
		контентом после плавающего элемента и как сочетать плавающие элементы с
		техникой центрирования "auto-margin" из урока <a href="iih05-css-box-model.html">
		Блоковая модель в CSS</a>.
		Эти инструменты нужны нам для создания боковых панелей, сеток и макетов в
		стиле журнала.
</p><p>
    Важно чтоб вы помнили вашу роль в процессе создания сайта.
		Ваша работа как веб-разработчика заключается в том, чтобы получив красивый
		дизайнерский эскиз, превратить его в HTML и CSS, которые браузеры могут
		отобразить конечным пользователям.
		Плавающие элементы - большой шаг вперед в этом направлении, но эта технология
		уже устаревает.
		Ей на смену приходит верстка flexbox.
</p><p>
    На следующем уроке мы узнаем дополнительные способы компоновки сложных
		сайтов с помощью flexbox.
		Свойства CSS будут новыми, но <em>процесс</em> будет таким же, как и сегодня:
		мы по-прежнему будем выравнивать блоки внутри других блоков, внутри других блоков
		и так далее, пока не добьемся желаемого макета.
</p>
<hr>

<h1><a href="/iih" title="RUS EDITION of Interneting is Hard">МУДРЕНЫЙ HTML&CSS</a></h1>
<h2>FLEXBOX</h2>
<p>УРОК Nº 8.</p>
<p><em>
    Самый понятный учебник современной CSS-верстки
</em></p>


<p>
    Режим макета Flexbox ["Гибкий блок"] предлагает альтернативу плавающим
		элементам <a href="iih07-floats.html">Floats</a> для создания общего вида
		веб-страницы.
		В то время как плавающие элементы позволяют нам только горизонтально
		располагать наши блоки, flexbox дает нам <em>полный</em> контроль над
		выравниванием, направлением, порядком и размером наших блоков.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-01-flexbox-layouts-7abd58.f93fcbe3.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: сравнение свойств выравнивания (alignment), направления (direction),
		порядка (order) и размера (size) flexbox
</small></figcaption>
</figure>
<p>
    В настоящее время веб переживает серьезные изменения, поэтому стоит немного
		поговорить о состоянии отрасли.
		В последнее десятилетие плавающие элементы Floats были единственным вариантом
		для создания сложной веб-страницы.
		В результате они хорошо поддерживаются даже в устаревших браузерах, а
		разработчики используют их для создания миллионов веб-страниц.
		Это означает, что вы неизбежно столкнетесь с плавающими элементами во время
		своей карьеры веб-разработчика (так что предыдущий урок не был пустой
		тратой времени).
</p><p>
    Изначально плавающие элементы предназначались для макетов в журнальном
		стиле (см. статью <a href="iih07-floats.html#floats-for-content">Floats для
		контента</a>).
		Несмотря на все изученное на прошлом уроке, виды макетов, создаваемых с помощью
		плавающих элементов, несколько ограничены.
		Даже простой макет боковой панели, с технической точки зрения, является
		немного хаком.
		Чтобы избавиться от этих ограничений, был изобретен Flexbox.
</p><p>
		Наконец-то мы достигли того момента, когда поддержка браузерами достигла
		критической массы и разработчики могут начать создавать полноценные сайты с
		использованием flexbox.
		Мы рекомендуем использовать flexbox для компоновки веб-страниц как можно чаще,
		оставляя плавающие элементы для тех случаев, когда вам нужно, чтобы поток
		страницы <em>обтекал</em> блок (например, при верстке в журнальном стиле),
		или для поддержки устаревших веб-браузеров.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-02-flexbox-vs-floats-418bf3.44fa853b.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2: плавающие элементы Floats для обтекания текста вокруг блока
		("журнальная" структура) и Flexbox для остальной части макета (основная
		структура страницы)
</small></figcaption>
</figure>

<p>
    На этом уроке мы шаг за шагом рассмотрим всю модель макета flexbox.
		Вы научитесь создавать практически любой макет, который предложит
		веб-дизайнер.
</p>

<div class="title">подготовка<br>setup</div>
<p>
	Пример для этого урока относительно прост, но он наглядно демонстрирует все
	важные свойства flexbox.
	В итоге мы получим что-то похожее на это:
</p>

<figure>
<img class="pic-pages" src="./images/iih08-03-footer-flexible-items-static-widths-af0a32.2dfc1aff.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: веб-страница с макетом на основе flexbox
</small></figcaption>
</figure>

<p>
    Для начала нам нужен пустой HTML-документ, в котором нет ничего, кроме строки меню.
		Создайте новый <a href="iih01-intro.html#atom">Atom-проект</a> под названием
		flexbox, в котором будут храниться все файлы примеров для этого урока.
		Затем создайте файл flexbox.html и добавьте в него следующую разметку:
</p><p class="code">
	<span class="code-green">&lt;!DOCTYPE html&gt;</span><br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Some Web Page&lt;/title&gt;<br>
&lt;link rel='stylesheet' href='styles.css'/&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
&lt;div class='menu-container'&gt;<br>
&lt;div class='menu'&gt;<br>

&lt;div class='date'&gt;Aug 14, 2016&lt;/div&gt;<br>
&lt;div class='signup'&gt;Sign Up&lt;/div&gt;<br>
&lt;div class='login'&gt;Login&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Далее нужно создать таблицу стилей styles.css.
		Выглядеть это будет не очень презентабельно: просто синяя полоса меню во всю ширину
		с белым блоком в ней.
		Обратите внимание, что для центрирования меню мы будем использовать flexbox
		вместо уже привычной техники auto-margin.
</p><p class="code">
<span class="code-strong">*</span> {<br>
<span class="code-green">margin</span>: 0;<br>
<span class="code-green">padding</span>: 0;<br>
<span class="code-green">box-sizing</span>: border-box;<br>
}<br>
<br>
<span class="code-blue">.menu-container</span> {<br>
<span class="code-green">color</span>: #fff;<br>
<span class="code-green">background-color</span>: #5995DA;
<span class="code-grey">/* синий */</span>
<br>
<span class="code-green">padding</span>: 20px 0;<br>
}<br>
<br>
<span class="code-blue">.menu</span> {<br>
<span class="code-green">border</span>: 1px solid #fff;
<span class="code-grey">/* для отладки */</span><br>
<span class="code-green">width</span>: 900px;<br>
}
</p><p>
    Напоследок <a href="docs/iih08-flexbox-images-449705.zip">скачайте несколько
		изображений</a> для нашего примера веб-страницы.
		Распакуйте их в проект flexbox, сохранив родительский каталог images.
		Ваш проект должен выглядеть примерно так:
</p>

<figure>
<img class="pic-pages" src="./images/iih08-04-project-files-5cb6e0.e9e7714c.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: скриншот файлов проекта
</small></figcaption>
</figure>

<div class="title">обзор<br>flexbox overview</div>
<p>
    Flexbox использует два типа блоков, которые мы никогда не видели раньше:
		"flex контейнеры" [flex containers] и "flex элементы" [flex items].
		Задача flex контейнера - сгруппировать несколько flex элементов и определить,
		как они будут располагаться.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-05-flex-container-and-flex-items-6234bb.7ffe361a.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5: flex-контейнер в виде выделенного контейнера, обертывающего
		серые элементы, и flex-элементы в виде выделенных блоков внутри контейнера
</small></figcaption>
</figure>

<p>
    Каждый HTML-элемент, являющийся прямым дочерним элементом flex контейнера,
		представляет собой "элемент" [flex item].
		Flex элементами можно манипулировать по отдельности, но в основном их
		расположение определяет контейнер.
		Основная задача flex элементов - сообщить контейнеру, сколько элементов ему
		нужно расположить.
</p><p>
    Как и в случае с макетами на основе плавающих элементов [floats], создание
		сложных веб-страниц с помощью flexbox сводится к созданию вложенных блоков.
		Вы выравниваете кучу flex элементов внутри контейнера, и, в свою очередь,
		эти элементы могут служить flex контейнерами для своих собственных элементов.
		Работая с примерами этого урока, помните, что основная задача компоновки страницы
		не изменилась: мы по-прежнему просто перемещаем группу вложенных блоков.
</p>

<div class="title">флекс-контейнеры<br>flex containers</div>
<p>
    Первый шаг в использовании flexbox - превращение одного из наших HTML-элементов
		в flex-контейнер.
		Для этого мы используем свойство display, которое должно быть знакомо нам по
		уроку <a href="iih05-css-box-model.html#changing-box-behavior">Блочная модель в CSS</a>.
		Значение flex сообщает браузеру, что все в блоке должно отображаться
		с помощью flexbox, а не блоковой модели, как это делается по умолчанию.
</p><p>
    Добавьте следующую строку в наше правило .menu-container, чтобы превратить
		его в flex контейнер:
</p><p class="code">
<span class="code-blue">.menu-container</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">display</span>: flex;<br>
}
</p><p>
    Это <em>активирует</em> режим верстки flexbox - без него браузер будет
		игнорировать все свойства flexbox, которые мы сейчас рассмотрим.
		Явное определение flex-контейнеров означает, что вы можете смешивать и сочетать
		flexbox с другими моделями верстки (например, с плавающими элементами и всем
		тем, что мы будем изучать в разделе <a href="iih09-advanced-positioning.html">
		Продвинутое позиционирование</a>).
</p>

<figure>
<img class="pic-pages" src="./images/iih08-06-enabling-flexbox-dd3b59.cb39abcd.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: смешивание и сочетание макета flexbox с блочными блоками и
		плавающими элементами
</small></figcaption>
</figure>

<p>
    Ура!
		У нас есть flex контейнер с одним flex элементом в нем.
		Однако наша страница будет выглядеть точно так же, как и раньше, потому что
		мы не указали контейнеру, как отображать его элемент.
</p>

<div class="title">Выравнивание элемента<br>aligning a flex item</div>
<p>
    После того как вы создали flex-контейнер, нужно задать горизонтальное
		выравнивание его элементов.
		Для этого предназначено свойство justify-content.
		Мы можем использовать его, чтобы выровнять по центру наше .menu, как
		показано ниже:
</p><p class="code">
<span class="code-blue">.menu-container</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;
<span class="code-grey">/* добавьте это */</span><br>
}
</p><p>
    Это имеет тот же эффект, что и добавление объявления margin: 0 auto к элементу .menu.
		Но обратите внимание, что мы добавили свойство к <em>родительскому</em> элементу
		(flex-контейнеру), а не непосредственно к элементу, который мы хотим выровнять
		по центру (flex-элементу).
		Управление элементами через их контейнеры является общей темой в flexbox,
		и это немного отличается от того, как мы позиционировали блоки до сих пор.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-07-flex-justify-content-alignment-ea129c.f7d754ab.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: flex-start (3 блока с выравниванием по левому краю), center
		(3 блока с выравниванием по центру), flex-end (3 блока с выравниванием по
		правому краю)
</small></figcaption>
</figure>

<p>
    Другие значения для justify-content показаны ниже:
</p><ul>
<li>center</li>
<li>flex-start</li>
<li>flex-end</li>
<li>space-around</li>
<li>space-between</li>
</ul><p>
    Попробуйте изменить justify-content на flex-start и flex-end.
		Это позволит выровнять меню по левой и правой стороне окна браузера соответственно.
		Не забудьте изменить его обратно на center, прежде чем двигаться дальше.
		Последние две опции полезны только когда в контейнере находятся несколько
		flex-элементов.
</p>

<div class="title">Распределение нескольких элементов<br>distributing multiple flex items</div>
<p>
    "Подумаешь! Мы уже умеем выравнивать влево/вправо с помощью плавающих элементов
		и центрировать с помощью auto-margins" - скажете вы.
		Верно.
		Но Flexbox не проявляет себя по-настоящему, пока в контейнере всего один элемент.
		Свойство justify-content также позволяет равномерно распределить элементы
		внутри контейнера.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-08-flex-justify-content-distribution-b0ee9c.3c71bf1f.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: space-around (3 блока с одинаковым пространством между ними и
		их контейнером), space-between (3 блока с пробелами между ними, но не между
		их контейнером)
</small></figcaption>
</figure>

<p>
    Измените наше правило .menu следующим образом:
</p><p class="code">
<span class="code-blue">.menu</span> {<br>
<span class="code-green">border</span>: 1px solid #fff;<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: space-around;<br>
}
</p><p>
    Это превращает наше .menu во вложенный flex контейнер, а значение space-around
		распределяет его элементы по всей ширине.
		Вы должны увидеть что-то вроде этого:
</p>

<figure>
<img class="pic-pages" src="./images/iih08-09-menu-bar-flex-space-around-e4b5a5.144eb729.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: веб-страница, на которой элементы &lt;li&gt; строки меню размещены
		с использованием пространства между ними
</small></figcaption>
</figure>

<p>
    Flex-контейнер автоматически распределяет дополнительное горизонтальное
		пространство по обе стороны от каждого элемента.
		Значение space-between аналогично, но оно только добавляет дополнительное
		пространство <em>между</em> элементами.
		Это именно то, что требуется для нашей страницы.
		Поэтому обновите строку justify-content:
</p><p class="code">
<span class="code-strong">justify-content</span>: space-between;
</p><p>
    Конечно, вы также можете использовать здесь center, flex-start, flex-end,
		если хотите сдвинуть все элементы в ту или иную сторону.
		Но давайте оставим значение space-between.
</p>

<div class="title" id="grouping-flex-items">группировка элементов<br>grouping flex items</div>
<p>
    Flex контейнеры умеют позиционировать только элементы, находящиеся уровнем
		ниже (то есть свои дочерние элементы).
		Их нисколько не волнует, что находится внутри тех flex элементов.
		Это означает, что группировка flex элементов - еще одно оружие в вашем арсенале
		для создания HTML-макета.
		Если обернуть множество элементов в дополнительный &lt;div&gt;, получится
		совершенно другая веб-страница.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-10-grouping-flex-items-1bb642.c1c54766.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10: обертывание двух flex-элементов в &lt;div&gt; для устранения
		одного из flex-элементов
</small></figcaption>
</figure>

<p>
    Предположим, вы хотите, поместить ссылки <strong>Sign Up</strong>
		и <strong>Login</strong> в правую часть страницы (см. скриншот ниже).
		Для этого достаточно поместить их в другой &lt;div&gt;:
</p>

<p class="code">
&lt;div class='menu'&gt;<br>
&lt;div class='date'&gt;Aug 14, 2016&lt;/div&gt;<br>
&lt;div class='links'&gt;<br>
&lt;div class='signup'&gt;Sign Up&lt;/div&gt;
<span class="code-grey">&lt;!-- это вложено --&gt;</span><br>
&lt;div class='login'&gt;Login&lt;/div&gt;
<span class="code-grey">&lt;!-- и это вложено --&gt;</span><br>
&lt;/div&gt;<br>
&lt;/div&gt;<br>
</p><p>
    Вместо трех элементов в нашем flex-контейнере .menu теперь только два
		(.date и .links).
		В соответствии с существующим поведением пространства между ними, они будут
		привязаны к левой и правой стороне страницы.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-11-menu-bar-grouped-items-1-31c157.2b3287bf.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: веб-страница, c двумя полями меню, внутри контейнеров &lt;div&gt;
</small></figcaption>
</figure>

<p>
    Но теперь нам нужно разместить элемент .links, поскольку он использует
		стандартный режим блокового размещения.
		Решение: больше вложенных flex-контейнеров!
		Добавьте новое правило в наш файл styles.css, которое превратит элемент
		.links в flex-контейнер:
</p><p class="code">
<span class="code-blue">.links</span> {<br>
<span class="code-green">border</span>: 1px solid #fff;
<span class="code-grey">/* для отладки */</span><br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: flex-end;<br>
}<br>
<br>
<span class="code-blue">.login</span> {<br>
<span class="code-green">margin-left</span>: 20px;<br>
}
</p><p>
    Это позволит разместить наши ссылки именно там, где мы хотим.
		Обратите внимание, что поля по-прежнему работают так же, как и в <a href="iih05-css-box-model.html">
		блоковой модели CSS</a>.
		Как и в обычной блоковой модели, в flexbox особое значение имеют auto отступы
		(подробнее об этом  <a href="#flex-items-and-auto-margins">в конце урока</a>).
</p>

<figure>
<img class="pic-pages" src="./images/iih08-12-menu-bar-grouped-items-2-50cec0.7c36b832.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 12: поля меню, размещенные с помощью вложенных контейнеров flexbox
</small></figcaption>
</figure>

<p>
    Белые рамки нам больше не понадобятся.
		Можно их смело удалить.
</p>

<div class="title">выравнивание по оси (вертикальное)<br>cross-axis (vertical) alignment</div>
<p>
    До сих пор мы манипулировали горизонтальным выравниванием, но flex-контейнеры
		могут также определять вертикальное выравнивание своих элементов.
		Это то, что просто невозможно сделать с плавающими элементами.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-13-align-items-vs-justify-content-4d380e.ab784eaa.png"
width="55%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 13: justify-content (слева и справа), align-items (сверху и снизу)
</small></figcaption>
</figure>

<p>
    Чтобы изучить это, нам нужно добавить заголовок под нашим меню.
		Добавьте следующую разметку в файл flexbox.html после элемента .menu-container:
</p><p class="code">
&lt;div class='header-container'&gt;<br>
&lt;div class='header'&gt;<br>
&lt;div class='subscribe'&gt;Subscribe &#9662;&lt;/div&gt;<br>
&lt;div class='logo'&gt;&lt;img src='images/awesome-logo.svg'/&gt;&lt;/div&gt;<br>
&lt;div class='social'&gt;&lt;img src='images/social-icons.svg'/&gt;&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;
</p><p>
    Затем добавьте несколько базовых стилей, чтобы выровнять его по элементу .menu:
</p><p class="code">
<span class="code-blue">.header-container</span> {<br>
<span class="code-green">color</span>: #5995DA;<br>
<span class="code-green">background-color</span>: #D6E9FE;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;<br>
}<br>
<br>
<span class="code-blue">.header</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">height</span>: 300px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: space-between;<br>
}
</p><p>
    Все это должно быть знакомо, однако сценарий немного отличается от нашего меню.
		Так как .header имеет явную высоту, элементы могут быть расположены вертикально
		внутри него.
		В официальной спецификации это называется "выравнивание по оси" [cross-axis]
		- вскоре узнаете, почему. Но для наших целей это можно назвать "вертикальным"
		выравниванием.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-14-header-align-items-c53758.f10d1f7c.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 14: вертикальное выравниванием в контейнере заголовка с помощью
		свойства align-items
</small></figcaption>
</figure>

<p>
    Вертикальное выравнивание определяется добавлением свойства align-items
		к flex-контейнеру.
		Чтобы наша страница-пример соответствовала приведенному выше скриншоту,
		добавьте следующую строку:
</p><p class="code">
<span class="code-blue">.header</span> {<br>
/* ... */<br>
<span class="code-green">align-items</span>: center;
<span class="code-grey">/* добавьте это */</span><br>
}
</p><p>
    Варианты свойства align-items аналогичны justify-content:
</p><ul>
<li>center</li>
<li>flex-start (top)</li>
<li>flex-end (bottom)</li>
<li>stretch</li>
<li>baseline</li>
</ul>

<figure>
<img class="pic-pages" src="./images/iih08-15-flex-align-items-26abfd.9d4b350a.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 15: flex-start (блоки в верху контейнера), center (блоки в центре
		контейнера), flex-end (блоки в низу контейнера, stretch (блоки, заполняющие
		высоту контейнера)
</small></figcaption>
</figure>

<p>
    Большинство из вышеназванных вариантов довольно просты.
		С вариантом stretch стоит немного поэкспериментировать, потому что stretch
		позволяет отобразить фон каждого элемента.
		Давайте рассмотрим это ближе, добавив в файл styles.css следующее:
</p><p class="code">
.header {<br>
 /* ... */<br>
align-items: stretch;    /* Измените это */<br>
}<br>
<br>
.social,<br>
.logo,<br>
.subscribe {<br>
border: 1px solid <span class="code-green">#5995DA;</span><br>
}
</p><p>
    Блок для каждого элемента расширяется на всю высоту flex-контейнера,
		независимо от того, сколько контента он содержит.
		Чаще всего такое поведение используется для создания колонок одинаковой высоты
		с переменным количеством контента в каждой из них - что очень сложно сделать
		с плавающими элементами.
</p><p>
    Перед тем как двигаться дальше, обязательно удалите вышеуказанные изменения
		и вертикально отцентрируйте наш контент внутри .header.
</p>

<div class="title" id="wrapping-flex-items">обертывание элементов<br>wrapping flex items</div>
<p id="grid-01">
    Flexbox - это более мощная альтернатива <a href="iih07-floats.html#floats-for-grids">
		grid-сеткам на основе плавающих элементов</a>.
		Он может не только отображать элементы в виде сетки, но и изменять их выравнивание,
		направление, порядок и размер.
		Для создания сетки нам понадобится свойство flex-wrap.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-16-flex-wrap-b960c1.73a3247a.png"
width="55%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 16: без обертывания (блоки выходят за пределы контейнера), с
		обертыванием (блоки переходят на следующую строку в контейнере)
</small></figcaption>
</figure>

<p>
    Добавьте ряд фотографий в файл flexbox.html, чтобы нам было с чем работать.
		Поместите их внутрь &lt;body&gt;, под элементом .header-container:
</p><p class="code" id="grid-02">
&lt;div class='photo-grid-container'&gt;<br>
&lt;div class='photo-grid'&gt;<br>
&lt;div class='photo-grid-item first-item'&gt;<br>
&lt;img src='images/one.svg'/&gt;<br>
&lt;/div&gt;<br>
&lt;div class='photo-grid-item'&gt;<br>
&lt;img src='images/two.svg'/&gt;<br>
&lt;/div&gt;<br>
&lt;div class='photo-grid-item'&gt;<br>
&lt;img src='images/three.svg'/&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;
</p><p>
    Опять же, соответствующие CSS должны быть вам знакомы по предыдущим секциям:
</p><p class="code" id="grid-03">
<span class="code-blue">.photo-grid-container</span> {<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;<br>
}<br>
<br>
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: flex-start;<br>
}<br>
<br>
<span class="code-blue">.photo-grid-item</span> {<br>
<span class="code-green">border</span>: 1px solid #fff;<br>
<span class="code-green">width</span>: 300px;<br>
<span class="code-green">height</span>: 300px;<br>
}
</p><p id="grid-04">
    Все должно работать, как и ожидалось, но посмотрите, что произойдет,
		если мы добавим больше элементов, чем поместится в flex-контейнер.
		Вставьте две дополнительные фотографии в .photo-grid:
</p><p class="code" id="grid-05">
&lt;div class='photo-grid-item'&gt;<br>
&lt;img src='images/four.svg'/&gt;<br>
&lt;/div&gt;<br>
&lt;div class='photo-grid-item last-item'&gt;<br>
&lt;img src='images/five.svg'/&gt;<br>
&lt;/div&gt;
</p><p>
    По умолчанию они вытекают за край страницы:
</p>

<figure id="grid-06">
<img class="pic-pages" src="./images/iih08-17-grid-no-flex-wrap-66c396.5dd84e4f.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 17: веб-страница с неправильной версткой из-за отсутствия обертывания flexbox
</small></figcaption>
</figure>

<p>
    Такое вытекание за край еще можно оправдать, если вы пытаетесь создать баннер
		с горизонтальной прокруткой кучи фотографий, но это совсем, совсем не то,
		чего мы хотим.
		Мы хотим, чтобы не помещающиеся элементы смещались в следующий ряд.
		Для этого воспользуемся свойством flex-wrap:
</p><p class="code" id="grid-07">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">flex-wrap</span>: wrap;<br>
}
</p><p>
    Теперь наши flex-элементы ведут себя так же, как плавающие элементы, только
		flexbox дает нам больше контроля над тем, как "лишние" элементы выравниваются
		в последней строке с помощью свойства justify-content.
		Например, последняя строка сейчас выровнена по левому краю.
		Попробуйте выровнять ее по центру, обновив наше правило .photo-grid,
		например, так:
</p><p class="code" id="grid-08">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;
<span class="code-grey">/* Измените это */</span><br>
<span class="code-green">flex-wrap</span>: wrap;<br>
	}
</p><p>
    Добиться этого с макетами на основе плавающих элементов невероятно сложно.
</p>

<figure id="grid-09">
<img class="pic-pages" src="./images/iih08-18-grid-with-flex-wrap-1da4da.f85376b4.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 18: веб-страница, с корректной grid-сеткой, созданной с помощью
		правильного обертывания flexbox
</small></figcaption>
</figure>

<div class="title" id="flex-container-direction">направление контейнера<br>flex container direction</div>
<p>
    "Направление" означает, в каком направлении контейнер отображает свои элементы
		- горизонтально или вертикально.
		До сих пор все контейнеры, которые мы видели, использовали горизонтальное
		направление по умолчанию, что означает, что элементы рисуются один за другим
		в одной строке, а затем переходят в следующий столбец, когда заканчивается место.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-19-flex-direction-9acadf.b054ca57.png"
width="55%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 19: ряд (ROW - 3 горизонтальных блока), столбец (COLUMN - 3
		вертикальных блока)
</small></figcaption>
</figure>

<p id="grid-10">
    Одна из самых удивительных вещей в flexbox - его способность преобразовывать
		ряды в столбцы с помощью всего одной строки CSS.
		Попробуйте добавить следующее объявление flex-direction в наше правило .photo-grid:
</p><p class="code">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">flex-direction</span>: column;<br>
}
</p><p id="grid-11">
    Это изменит направление контейнера по сравнению со стандартным значением
		ряда [row value].
		Вместо сетки наша страница теперь имеет одну вертикальную колонку:
</p>

<figure>
<img class="pic-pages" src="./images/iih08-20-flex-direction-column-1bb8a0.209267d3.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 20: веб-страница с сеткой, превращенная в вертикальный столбец ячеек
</small></figcaption>
</figure>

<p>
    Ключевым условием адаптивного дизайна является одна HTML-разметка как для
		мобильных, так и ноутбуков/ПК.
		Небольшая проблема состоит в том, что большинство мобильных макетов имеют
		одну колонку, в то время как большинство макетов для ноутбуков/ПК располагают
		элементы горизонтально.
		Только представьте, насколько полезным станет flex-direction, когда мы начнем
		создавать <a href="iih10-responsive-design.html">адаптивные макеты</a>.
</p>

<div class="title-under">АСПЕКТЫ ВЫРАВНИВАНИЯ<br>alignment considerations</div>
<p>
    Обратите внимание, что колонка прижимается к левой стороне своего flex-контейнера,
		несмотря на наше объявление justify-content: center;.
		Когда вы меняете направление контейнера, вы также меняете направление свойства
		justify-content.
		Теперь оно относится к вертикальному выравниванию контейнера, а не к горизонтальному.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-21-flex-direction-axes-b30e85.d1bca75a.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 21: оси перевернуты, когда flex-direction равно column
</small></figcaption>
</figure>

<p id="grid-12">
    Чтобы горизонтально выровнять колонку, нам нужно задать свойство align-items
		для нашей .photo-grid:
</p><p class="code">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">flex-direction</span>: column;<br>
<span class="code-green">align-items</span>: center;
<span class="code-grey">/* Добавьте это */</span><br>
}
</p>

<div class="title">порядок контейнеров<br>flex container order</div>
<p>
    До сих пор существовала тесная взаимосвязь между порядком расположения HTML-элементов
		и тем, как блоки отображаются на веб-странице.
		С помощью плавающих элементов или техники flexbox, которую мы сейчас изучаем,
		единственный способ заставить блок отображаться перед или после
		другого блока - это перемещение по HTML-разметке.
		Однако скоро все изменится.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-22-flex-direction-reverse-532d8f.d1f2fbd3.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 22: ряд (ROW - слева направо), обратный ряд (ROW-REVERSE - справа
		налево), столбец (COLUMN - сверху вниз), обратный столбец (COLUMN-REVERSE - снизу вверх)
</small></figcaption>
</figure>

<p id="grid-13">
    Свойство flex-direction тоже позволяет контролировать порядок отображения
		элементов с помощью свойств row-reverse и column-reverse.
		Чтобы увидеть это в действии, преобразуем наш столбец обратно в сетку,
		но на этот раз мы изменим порядок отображения:
</p><p class="code">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;<br>
<span class="code-green"> flex-wrap</span>: wrap;<br>
<span class="code-green">flex-direction</span>: row-reverse;
<span class="code-grey">/* <--- Реально офигенно круто! */</span><br>
<span class="code-green">align-items</span>: center;<br>
}
</p><p>
    Теперь оба ряда отображаются справа налево, а не слева направо.
		Но обратите внимание, что порядок меняется только для каждой строки: первый
		ряд начинается не с 5, а с 3.
		Это полезное поведение для многих распространенных паттернов дизайна (в частности,
		обратный порядок колонок открывает много возможностей для мобильных макетов).
		В следующем разделе вы научитесь еще большей детализации.
</p>

<figure id="grid-14">
<img class="pic-pages" src="./images/iih08-23-grid-direction-row-reverse-78cc12.f79ada41.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 23: веб-страница, на которой строки сетки отображаются в обратном
		порядке (3, 2, 1 в первом ряду и 5, 4 во втором)
</small></figcaption>
</figure>

<p>
    Переупорядочивание элементов внутри таблицы стилей - это серьезное дело.
		До появления flexbox для этого приходилось прибегать к хакам JavaScript.
		Однако не стоит злоупотреблять своими новыми возможностями.
		Как уже говорилось в начале учебника, всегда следует <a href="iih02-basic-web-pages.html#structure-vs-presentation">
		отделять структуру от презентации</a>.
		Изменение порядка является чисто визуальным - ваш HTML должен быть
		понятен и без применения этих стилей.
</p>

<div class="title" id="flex-item-order">порядок элементов<br>flex item order</div>
<p>
    Весь этот урок до сего момента был посвящен позиционированию flex элементов
<em>через их родительские контейнеры</em>.
		Однако также существует возможность управлять отдельными элементами.
		В оставшейся части урока мы сместим фокус с flex контейнеров на элементы,
		которые в них содержатся.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-24-flex-direction-vs-order-021cee.7a3e129a.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 24: настройка порядка отдельных flex элементов через свойство order
</small></figcaption>
</figure>

<p>
    Добавление свойства order к flex элементу определяет его порядок в контейнере,
		не затрагивая окружающие элементы.
		По умолчанию его значение равно 0, а увеличение или уменьшение этого значения
		перемещает элемент вправо или влево соответственно.
</p><p id="grid-15">
    Это можно использовать, например, чтобы поменять местами порядок элементов
		.first-item и .last-item в нашей сетке.
		Мы также должны изменить значение row-reverse из предыдущего раздела обратно
		на row, потому что так будет немного легче распознать наши исправления:
</p><p class="code" id="grid-16">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">flex-direction</span>: row;
<span class="code-grey">/* Обновите это */</span><br>
<span class="code-green">align-items</span>: center;<br>
}<br>
<br>
<span class="code-blue">.first-item</span> {<br>
<span class="code-green">order</span>: 1;<br>
}<br>
<br>
<span class="code-blue">.last-item</span> {<br>
<span class="code-green">order</span>: -1;<br>
}
</p><p>
    В отличие от настроек row-reverse и column-reverse в flex контейнере, порядок
		действует вне границ рядов/колонок.
		Приведенный выше фрагмент поменяет местами первый и последний элементы, даже
		если они находятся в разных рядах.
</p>

<div class="title">выравнивание элементов<br>flex item alignment</div>
<p>
    То же самое мы можем сделать с вертикальным выравниванием.
		Что если мы хотим, чтобы ссылка "Подписаться" [<strong>Subscribe</strong>]
		и иконки соцсетей находились внизу заголовка, а не в центре?
		Выровняйте их по отдельности!
		Здесь на помощь приходит свойство align-self.
		Добавление этого свойства к элементу flex отменяет значение align-items из
		его контейнера:
</p><p class="code">
<span class="code-blue">.social</span><br>
<span class="code-blue">.subscribe</span> {<br>
<span class="code-green">align-self</span>: flex-end;<br>
<span class="code-green"> margin-bottom</span>: 20px;<br>
}
</p><p>
    Это должно отправить их в нижнюю часть .header.
		Обратите внимание, что и margin и padding действуют так, как от них ожидается.
</p>

<figure id="grid-17">
<img class="pic-pages" src="./images/iih08-25-grid-align-self-4302c2.85d0fc6c.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 25: веб-страница, показывающая иконки, с помощью свойства align-self
		выровненные по нижнему краю [bottom-aligned]
</small></figcaption>
</figure>

<p>
    Элементы можно выравнивать и другими способами, используя те же значения,
		что и свойство align-items, перечисленные ниже для удобства.
</p><ul>
<li>center</li>
<li>flex-start (top)</li>
<li>flex-end (bottom)</li>
<li>stretch</li>
<li>baseline</li>
</ul>

<div class="title">гибкие элементы<br>flexible items</div>
<p>
    Все наши примеры были связаны с элементами с фиксированной шириной или определяемой
		контентом шириной.
		Это позволило нам сосредоточиться на аспектах позиционирования flexbox, но
		это также означает, что мы игнорировали природу "гибкого блока".
		Flex элементы являются <em>гибкими</em>: они могут сжиматься и растягиваться в
		соответствии с шириной своих контейнеров.
</p><p>
    Свойство flex определяет ширину отдельных элементов в flex контейнере.
		Точнее, оно позволяет им иметь гибкую ширину.
		Оно работает как некий коэффициент веса [weight], указывающий flex контейнеру,
		как распределить дополнительное пространство между элементами.
		Например, элемент со значением flex, равным 2, будет увеличиваться в два раза
		быстрее, чем элементы с стандартным значением, равным 1.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-26-flexible-items-cfe7a3.e3584961.png"
width="65%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 26: отсутствие flex (3 квадратных блока), равный flex (3 прямоугольных
		блока), неравный flex (2 меньших блока, один вытянутый)
</small></figcaption>
</figure>

<p>
    Для дальнейших экспериментов нам нужен футер.
		Вставьте его после элемента .photo-grid-container:
</p><p class="code">
&lt;div class='footer'&gt;<br>
&lt;div class='footer-item footer-one'&gt;&lt;/div&gt;<br>
&lt;div class='footer-item footer-two'&gt;&lt;/div&gt;<br>
&lt;div class='footer-item footer-three'&gt;&lt;/div&gt;<br>
&lt;/div&gt;<br>
</p><p>
    Затем, немного CSS:
</p><p class="code">
<span class="code-blue">.footer</span> {<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: space-between;<br>
}<br>
<br>
<span class="code-blue">.footer-item</span> {<br>
<span class="code-green">border</span>: 1px solid #fff;<br>
<span class="code-green">background-color</span>: #D6E9FE;<br>
<span class="code-green">height</span>: 200px;<br>
<span class="code-green">flex</span>: 1;<br>
}
</p><p>
    Этот flex: 1; велит элементам растягиваться в соответствии с
		шириной .footer.
	  Поскольку все они имеют одинаковый вес [weight], они будут растягиваться
		одинаково:
</p>

<figure>
<img class="pic-pages" src="./images/iih08-27-footer-flexible-items-220ac8.02046562.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 27: три одинаковых голубых блока, растянутые по всей ширине футера
</small></figcaption>
</figure>

<p>
    Если увеличить вес одного из элементов, он будет расти быстрее остальных.
		Например, мы можем заставить третий элемент расти в два раза быстрее, чем
		два других, с помощью следующего правила:
</p><p class="code">
<span class="code-blue">.footer-three</span> {<br>
<span class="code-green">flex</span>: 2;<br>
}
</p><p>
    Сравните это со свойством justify-content, которое распределяет дополнительное
		пространство <em>между</em> элементами.
		Это выглядит похоже, но теперь мы распределяем это пространство в самих элементах.
		В результате мы полностью контролируем размещение гибких элементов в своих
		контейнерах.
</p>

<div class="title-under">ЭЛЕМЕНТЫ ФИКСИРОВАННОЙ ШИРИНЫ<br>static item widths</div>
<p>
    Мы даже можем сочетать гибкие блоки с блоками фиксированной ширины.
		В flex: initial происходит возврат к конкретному свойству ширины элемента.
		Это позволяет нам по-разному комбинировать статические и гибкие блоки.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-28-combining-flexible-and-static-items-52aacb.64fa3f5b.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 28: блок фиксированной ширины (flex: initial), гибкий блок (flex: 1)
</small></figcaption>
</figure>

<p>
    Мы хотим, чтобы наш футер вел себя так, как на скриншоте выше.
		Гибкий блок в центре, а те, что по обе стороны, фиксированной ширины.
		Все, что для этого нужно сделать - добавить следующее правило в нашу таблицу
		стилей:
</p><p class="code">
<span class="code-blue">.footer-one</span><br>
<span class="code-blue">.footer-three</span> {<br>
<span class="code-green">background-color</span>: #5995DA;<br>
<span class="code-green">flex</span>: initial;<br>
<span class="code-green">width</span>: 300px;<br>
}
</p><p>
    Без этого flex: initial; объявление flex: 1; было бы унаследовано от правила
		.footer-item, в результате чего свойства ширины игнорировались бы.
    initial исправляет это, и мы получаем гибкий макет, который также содержит
		элементы фиксированной ширины.
		Измененяя размер окна браузера, мы увидим, что в футере изменяется только
		размер среднего блока.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-29-footer-flexible-items-static-widths-af0a32.2dfc1aff.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 29: два блока фиксированной ширины по обе стороны
		от гибкого блока. Все три полностью заполняют весь футер.
</small></figcaption>
</figure>

<p>
    Это довольно распространенная компоновка, и не только в футерах.
		Например, на многих сайтах есть боковая панель фиксированной ширины (или
		несколько боковых панелей) и гибкий блок контента, содержащий основной текст
		страницы.
		По сути, это более насыщенная версия футера, который мы только что создали.
</p>

<div class="title" id="flex-items-and-auto-margins">элементы и отступы<br>
    flex items and auto-margins</div>
<p>
    Auto отступы [auto-margins] в flexbox - это нечто особенное.
		Они могут использоваться как альтернатива <a href="#grouping-flex-items">
		дополнительному &lt;div&gt;</a> при попытке выровнять группу элементов по
		левому/правому краю контейнера.
		Воспринимайте auto-margin как "разделитель" для flex элементов в одном контейнере.
</p><p>
    Давайте посмотрим, как выровнять наши элементы в .menu, чтобы получилось следующее:
</p><p class="code">
&lt;div class='menu-container'&gt;<br>
&lt;div class='menu'&gt;<br>
&lt;div class='date'&gt;Aug 14, 2016&lt;/div&gt;<br>
&lt;div class='signup'&gt;Sign Up&lt;/div&gt;<br>
&lt;div class='login'&gt;Login&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;
</p><p>
    При перезагрузке страницы пункты должны равномерно распределиться по нашему
		меню, как в начале главы.
		Мы можем воспроизвести желаемый макет, вставив auto-margin между пунктами,
		которые мы хотим отделить, как показано ниже:
</p><p class="code">
<span class="code-blue">.signup</span> {<br>
<span class="code-green">margin-left</span>: auto;<br>
}
</p><p>
    auto-margin съедает <em>все</em> лишнее пространство в flex-контейнере,
		поэтому вместо равномерного распределения элементов, мы перемещаем .signup
		и все следующие элементы (.login) в правую часть контейнера.
		Получится точно такой же макет, как и раньше, но без лишнего вложенного &lt;div&gt;
		для группировки.
		Иногда приятнее оставить HTML более простым.
</p>


<div class="title">резюме</div>
<p>
    Flexbox дал нам тонну потрясающих новых инструментов для верстки веб-страниц.
		Сравните эти приемы с тем, что мы могли сделать с <a href="iih07-floats.html">
		float элементами</a>, и станет ясно, что flexbox - это более совершенный способ
		компоновки современных веб-сайтов:
</p><ul>
<li>Используйте display: flex; для создания flex-контейнера.</li>
<li>Используйте justify-content, чтобы задать горизонтальное выравнивание элементов.</li>
<li>Используйте align-items, чтобы задать вертикальное выравнивание элементов.</li>
<li>Используйте flex-direction, если вам нужны столбцы, а не ряды.</li>
<li>Используйте значения row-reverse или column-reverse, чтобы изменить порядок элементов.</li>
<li>Используйте order, чтобы настроить порядок отдельных элементов.</li>
<li>Используйте align-self, чтобы выровнять отдельные элементы по вертикали.</li>
<li>Используйте flex для создания гибких блоков, которые могут растягиваться и сжиматься.</li>
</ul><p>
    Помните, что эти свойства flexbox - всего лишь язык, позволяющий указывать
		браузерам, как расположить множество HTML-элементов.
		Самое сложное - это не написание HTML- и CSS-кода, а концептуальное (на листе
		бумаги) определение поведения всех необходимых блоков для создания желаемого
		макета.
</p><p>
    Когда дизайнер передает вам эскиз для воплощения, ваша первая задача - нарисовать
		на нем кучу блоков и определить, как они должны складываться, растягиваться и
		сжиматься, чтобы добиться желаемого дизайна.
		Как только вы это сделаете, вам будет довольно легко создать код, используя
		новые техники flexbox.
</p><p>
    Режим верстки flexbox должен использоваться для большинства ваших веб-страниц,
		но есть некоторые вещи, с которыми он не очень хорошо справляется, например,
		мягкая настройка положения элементов и предотвращение их взаимодействия с
		остальной частью страницы.
		После того как на следующем уроке мы рассмотрим эти виды продвинутых техник
		позиционирования, вы станете экспертом по позиционированию в HTML и CSS.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>ПРОДВИНУТОЕ ПОЗИЦИОНИРОВАНИЕ</h2>
<p>УРОК Nº 9.</p>
<p><em>
    Самое понятное руководство по статическому, относительному, абсолютному и
		фиксированному позиционированию
</em></p>


<p>
    Под "статическим позиционированием" подразумевается нормальный поток страницы,
		с которым мы работали до сих пор.
<a href="iih05-css-box-model.html">
		Блоковая модель CSS</a>, <a href="iih07-floats.html">float элементы</a>
		и схемы верстки <a href="iih08-flexbox.html">flexbox</a> работают в этом
		"статическом" потоке, но это не единственная схема позиционирования,
		доступная в CSS.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-01-css-positioning-schemes-790d5b.3d581d20.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: сравнение схем статического, относительного, абсолютного и
		фиксированного позиционирования
</small></figcaption>
</figure>

<p>
    Три других типа позиционирования - "относительное", "абсолютное" и "фиксированное".
		Каждый из них позволяет вручную позиционировать элементы по определенным
		координатам, в отличие от более семантических вариантов flexbox и floats.
		Вместо того чтобы сказать: "Этот блок поместить в центр его контейнера",
		продвинутое позиционирование позволяет сказать нечто-то вроде: "Этот блок
		поместить на 20 пикселей выше и на 50 пикселей правее от начала координат
		его родителя".
</p><p>
    Подавляющее большинство элементов на веб-странице должно быть расположено в
		соответствии со статическим потоком страницы.
		Другие схемы позиционирования появляются, когда вы хотите сделать более сложные
		вещи, например, изменить положение определенного элемента или анимировать
		компонент пользовательского интерфейса, не испортив окружающие элементы.
</p><p>
    Эта глава состоит из двух частей.
		Мы начнем с изучения относительного, абсолютного и фиксированного
    позиционирования по отдельности, а затем применим все, что узнали, к созданию
		шикарного выпадающего меню.
</p>

<div class="title">подготовка<br>setup</div>
<p>
    Начните с создания нового <a href="iih01-intro.html#atom">проекта Atom</a>
		под названием advanced-positioning и нового файла schemes.html со следующей
		разметкой:
</p><p class="code">
<span class="code-green">&lt;!DOCTYPE html&gt;</span><br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Positioning Is Easy!&lt;/title&gt;<br>
&lt;link rel='stylesheet' href='styles.css'/&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
<br>
&lt;div class='container'&gt;<br>
&lt;div class='example relative'&gt;<br>
&lt;div class='item'&gt;&lt;img src='images/static.svg' /&gt;&lt;/div&gt;<br>
&lt;div class='item item-relative'&gt;&lt;img src='images/static.svg' /&gt;&lt;/div&gt;<br>
&lt;div class='item'&gt;&lt;img src='images/static.svg' /&gt;&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;<br>
<br>
&lt;div class='container'&gt;<br>
&lt;div class='example absolute'&gt;<br>
&lt;div class='item'&gt;&lt;img src='images/static.svg' /&gt;&lt;/div&gt;<br>
&lt;div class='item item-absolute'&gt;&lt;img src='images/absolute.svg' /&gt;&lt;/div&gt;<br>
&lt;div class='item'&gt;&lt;img src='images/static.svg' /&gt;&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;<br>
<br>
&lt;div class='container'&gt;<br>
&lt;div class='example fixed'&gt;<br>
&lt;div class='item'&gt;&lt;img src='images/static.svg' /&gt;&lt;/div&gt;<br>
&lt;div class='item item-fixed'&gt;&lt;img src='images/fixed.svg' /&gt;&lt;/div&gt;<br>
&lt;div class='item'&gt;&lt;img src='images/static.svg' /&gt;&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;<br>
<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    У нас есть три примера для работы, все с одинаковой HTML-структурой.
		Изменение поведения позиционирования в каждом из них будет иметь кардинально
		разные эффекты.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-02-project-files-714b6b.98c25e29.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2: файлы в проекте примера
</small></figcaption>
</figure>

<p>
    На этой странице используются <a href="docs/iih09-images-89bc45.zip">изображения</a>,
		чтобы сделать наш пример немного нагляднее.
		При распаковке файлов в проект сохраняйте родительскую папку images, как
		показано выше.
    Не забудьте также создать файл styles.css и заполнить его необходимыми
		базовыми стилями:
</p><p class="code">
<span class="code-strong">*</span> {<br>
<span class="code-green">margin</span>: 0;<br>
<span class="code-green">padding</span>: 0;<br>
<span class="code-green">box-sizing</span>: border-box;<br>
}<br>
<br>
<span class="code-strong">body</span> {<br>
<span class="code-green">height</span>: 1200px;<br>
}<br>
<br>
<span class="code-blue">.container</span> {<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;<br>
}<br>
<br>
<span class="code-blue">.example</span> {<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: space-around;<br>
}<br>
<br>
<span class="code-green">width</span>: 800px;<br>
<span class="code-green">margin</span>: 50px 0;<br>
<span class="code-green">background-color</span>: #D6E9FE;<br>
}<br>
<br>
<span class="code-blue">.item</span> <span class="code-strong">img</span> {<br>
<span class="code-green">display</span>: block;<br>
}
</p><p id="grid">
    Здесь нет ничего нового, просто знакомые приемы <a href="iih08-flexbox.html">
		flexbox</a> для создания сетки элементов.
		Единственная особенность - четко указанная высота элемента &lt;body&gt;, которая
		позволит нам прокручивать страницу вверх и вниз, чтобы продемонстрировать
		различные варианты позиционирования.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-03-initial-project-screenshot-8ebe66.48084c00.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: веб-страница со статичными, относительными [relative], абсолютными
		и фиксированными блоками разных цветов
</small></figcaption>
</figure>

<div class="title">позиционированные элементы<br>positioned elements</div>
<p>
    Свойство CSS position позволяет изменять схему позиционирования конкретного
		элемента.
		Его значение по умолчанию, как можно догадаться, статично.
		Если свойство position элемента <em>не имеет</em> значения static, он
		называется "позиционированным элементом".
		Именно позиционированным элементам посвящен весь этот урок.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-04-positioned-elements-terminology-861fca.a9f6aa7d.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: относительные, абсолютные и фиксированные элементы, обозначаемые
		как позиционированные элементы
</small></figcaption>
</figure>

<p>
    Можно смешивать и сочетать различные схемы позиционирования.
		Опять же, большая часть вашей веб-страницы должна быть статически позиционирована,
		но часто можно встретить относительно и абсолютно позиционированные элементы
		внутри других элементов, которые являются частью нормального потока страницы.
</p>

<div class="title">относительное позиционирование<br>relative positioning</div>
<p>
    "Относительное позиционирование" перемещает элементы <em>относительно</em>
		того места, где они обычно появляются в статическом потоке страницы.
		Это полезно для перемещения блоков, когда стандартный поток немного смещен.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-05-css-relative-positioning-26842e.5977eeb5.png"
width="33%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5: относительно позиционированный блок смещен относительно левого
		верхнего угла своей статической позиции
</small></figcaption>
</figure>

<p>
    Давайте превратим элемент .item-relative в файле schemes.html в относительно
		позиционированный элемент.
		Добавьте следующее правило в styles.css:
</p><p class="code">
<span class="code-blue">.item-relative</span> {<br>
<span class="code-green">position</span>: relative;<br>
<span class="code-green">top</span>: 30px;<br>
<span class="code-green">left</span>: 30px;<br>
}
</p><p>
    Благодаря position: relative; он становится позиционированным элементом,
		а свойства top и left позволяют определить, насколько он смещен от своего
		статического положения.
		Это похоже на задание координат (x, y) для элемента.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-06-relative-positioning-screenshot-4c23c2.385135e6.png"
width="45%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: веб-страница с относительно (relative) позиционированным элементом
</small></figcaption>
</figure>

<p>
    Относительное позиционирование работает аналогично отступам margin, с одним
		очень важным отличием: значения top и left не влияют ни на окружающие элементы,
		ни на родительский элемент.
		Все остальное отображается так, как если бы .item-relative находился в своем
		исходном положении.
		Смещение можно рассматривать как действие, применяемое <em>после того</em>,
		как браузер завершит компоновку страницы.
</p><p>
    Свойства top и left отмеряются от верхнего и левого краев исходного блока.
		С помощью свойств bottom и right мы можем задать смещение относительно других
		краев.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-07-relative-positioning-offsets-494268.06d72664.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: верхнее, левое, нижнее и правое смещение относительно
		позиционированного элемента
</small></figcaption>
</figure>

<p>
    Например, следующий код сдвинет блок в противоположном направлении:
</p><p class="code">
<span class="code-blue">.item-relative</span> {<br>
<span class="code-green">position</span>: relative;<br>
<span class="code-green">bottom</span>: 30px;<br>
<span class="code-green">right</span>: 30px;<br>
}
</p><p>
    Обратите внимание, что эти свойства принимают отрицательные значения, что
		означает два способа задать одно и то же смещение.
		Мы могли бы с тем же успехом использовать top: -30px; вместо объявленного ранее
		bottom: 30px;.
</p>

<div class="title">абсолютное позиционирование<br>absolute positioning</div>
<p>
    "Абсолютное позиционирование" - это то же самое, что и относительное
		позиционирование, но смещение происходит относительно всего окна браузера,
		а не исходной позиции элемента.
		Поскольку в этом случае нет никакой связи со статическим потоком страницы.
		Считайте, что это самый ручной способ размещения элемента.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-08-css-absolute-positioning-228ce0.6d62d6e4.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: абсолютно позиционированный элемент, смещенный от левого верхнего
		края окна браузера
</small></figcaption>
</figure>

<p>
    Давайте рассмотрим это, добавив следующее правило в нашу таблицу стилей:
</p><p class="code">
<span class="code-blue">.item-absolute</span> {<br>
<span class="code-green">position</span>: absolute;<br>
<span class="code-green">top</span>: 10px;<br>
<span class="code-green">left</span>: 10px;<br>
}
</p><p>
    Наша HTML-структура точно такая же, как и в предыдущем примере, но в этом случае
		фиолетовое изображение будет помещено в левый верхний угол окна браузера.
		Вы также можете попробовать задать значение bottom или right, чтобы получить
		более четкое представление о происходящем.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-09-absolute-positioning-screenshot-641ad7.2f18f4f2.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: веб-страница с абсолютно позиционированным элементом
</small></figcaption>
</figure>

<p>
    Другой интересный эффект абсолютного позиционирования заключается в том, что
		оно полностью удаляет элемент из нормального потока страницы.
		Это легче увидеть на примере элементов, выровненных по левому краю, поэтому
		давайте временно изменим свойство justify-content в нашем правиле .example:
</p><p class="code">
<span class="code-blue">.example</span> {<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: flex-start;
<span class="code-grey">/* Обновите это */</span><br>
<span class="code-grey">/* ... */</span><br>
}
</p><p>
    В нашем примере с относительным позиционированием (первый ряд) на месте
		позиционируемого элемента все еще остается пространство, а при абсолютном
		позиционировании это пространство исчезает.
		Как будто .item-absolute даже не существует для своего родителя и окружающих
		элементов.
		Перед тем как двигаться дальше, обязательно измените justify-content обратно
		на space-around.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-10-absolute-positioning-flex-start-screenshot-d4b627.62dc0552.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10: веб-страница, выделяющая пустое пространство, оставленное
		абсолютно позиционированным элементом
</small></figcaption>
</figure>

<p>
    В большинстве случаев такое поведение не слишком полезно, поскольку в этом
		случае <em>все на вашей странице</em> должно быть абсолютно позиционировано - иначе
		мы получим непредсказуемые наложения статических элементов на абсолютные.
		Итак, зачем вообще существует absolute?
</p>

<div class="title-under">(ОТНОСИТЕЛЬНО) АБСОЛЮТНОЕ ПОЗИЦИОНИРОВАНИЕ<br>
    (RELATIVELY) ABSOLUTE POSITIONING</div>
<p>
    Абсолютное позиционирование становится гораздо более практичным, когда оно
		осуществляется относительно какого-либо другого элемента, <em>находящегося</em>
		в статическом потоке страницы.
		К счастью, существует способ изменить систему координат абсолютно позиционированного
		элемента.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-11-css-relatively-absolute-positioning-1ba963.bdf038c3.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: абсолютный элемент, позиционированный относительно родительского
		позиционированного элемента
</small></figcaption>
</figure>

<p>
    Координаты абсолютных элементов всегда относительны к ближайшему контейнеру,
		который является позиционированным элементом. Он становится относительным по
		отношению к браузеру только тогда, когда ни один из его родителей не позиционирован.
		Так, если мы изменим родительский элемент .item-absolute на относительно
		позиционированный, он должен появиться в левом верхнем углу <em>этого</em> элемента,
		а не в окне браузера.
</p><p class="code">
<span class="code-blue">.absolute</span> {<br>
<span class="code-green">position</span>: relative;<br>
}
</p><p>
    div-контейнер .absolute располагается в соответствии с нормальным потоком
		страницы, и мы можем вручную перемещать наш .item-absolute, куда нам нужно.
		Это великолепно, потому что если мы захотим изменить нормальный поток контейнера,
		скажем, для мобильного макета, любые абсолютно позиционированные элементы
		автоматически передвинутся вместе с ним.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-12-relatively-absolute-positioning-screenshot-98bcce.4a0c68d2.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 12: веб-страница с абсолютно позиционированным элементом внутри
		другого элемента, который позиционирован относительно
</small></figcaption>
</figure>

<p>
    Обратите внимание, что мы не указали никаких координат смещения для .absolute.
		Мы используем относительное позиционирование только для того, чтобы позволить
		нашему абсолютному элементу вернуться в нормальный поток страницы.
		Так мы безопасно сочетаем абсолютное позиционирование со статическим позиционированием.
</p>

<div class="title">фиксированное позиционирование<br>fixed positioning</div>
<p>
    У "фиксированного позиционирования" много общего с абсолютным: оно очень "ручное",
		элемент удален от нормального течения страницы, а система координат относительна
		ко всему окну браузера.
		Ключевое отличие заключается в том, что фиксированные элементы не прокручиваются
		вместе с остальной частью страницы.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-13-css-fixed-positioning-342eff.bf560e17.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 13:  фиксированный элемент, расположенный относительно окна браузера,
		но с отключенной прокруткой
</small></figcaption>
</figure>

<p>
    Перейдем к обновлению нашего третьего примера, чтобы использовать фиксированное
		позиционирование:
</p><p class="code">
<span class="code-blue">.item-fixed</span> {<br>
<span class="code-green">position</span>: fixed;<br>
<span class="code-green">bottom</span>: 0;<br>
<span class="code-green">right</span>: 0;<br>
}
</p><p>
    В результате красная картинка окажется в правом нижнем углу экрана.
		Попробуйте прокрутить страницу, и вы обнаружите, что она не перемещается
		вместе с остальными элементами на странице, в то время как абсолютно
		позиционированная фиолетовая картинка перемещается.
</p><p>
    Так создаются навигационные панели, которые всегда остаются на экране,
		а также назойливые всплывающие и упорно не исчезающие pop-up баннеры.
</p>

<div class="title">позиционированные элементы для анимации<br>
    positioned elements for animation</div>
<p>
    Это немного выходит за рамки данного руководства, поскольку речь идет о HTML
		и CSS, а не о JavaScript.
		Однако анимация - это один из основных вариантов использования относительного
		и абсолютного позиционирования, поэтому давайте заглянем в будущее, анимировав
		один из наших элементов.
</p><p>
    Эти усовершенствованные схемы позиционирования позволяют JavaScript перемещать
		элементы, избегая при этом какого-либо взаимодействия с окружающими элементами.
		Например, попробуйте скопировать и вставить следующее в файл schemes.html
		после третьего элемента .container.
		Элемент &lt;script&gt; должен быть последним внутри &lt;body&gt;.
</p><p class="code">
<span class="code-blue">&lt;script&gt;</span><br>
<span class="code-strong">var</span> left = 0;<br>
<br>
<span class="code-strong">function</span> <span class="code-blue">frame</span>() {<br>
<span class="code-strong">var</span> element = document.querySelector('.item-relative');<br>
	    left += 2;<br>
	    element.style.left = left + 'px';<br>
<span class="code-strong">if</span> (left &gt;= 300) {<br>
	      clearInterval(id)<br>
}<br>
}<br>
<br>
<span class="code-strong">var</span> id = setInterval(frame, 10)<br>
<span class="code-blue">&lt;/script&gt;</span>
</p><p>
    Этот код JavaScript создает простую анимацию, которая постоянно обновляет
		свойство left в .item-relative.
		При перезагрузке страницы вы должны увидеть, что синее изображение плавает
		по правому краю своего контейнера.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-14-animated-relative-positioning-193400.2bdf3e0d.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 14: веб-страница, показывающая простую анимацию относительно
		позиционированного элемента
</small></figcaption>
</figure>

<p>
    Это довольно примитивный пример, но вы, надеюсь, видите, как он применим к
		причудливым анимациям пользовательского интерфейса.
		Если бы вы попытались добиться того же эффекта, манипулируя свойствами margin
		или padding, вы бы невольно переместили статически расположенные блоки и/или
		содержащий их элемент .example.
</p>

<div class="title">позиционированные элементы для меню<br>positioned elements for menus</div>
<p>
    Итак, это основные приемы.
		Давайте сделаем с их помощью что-нибудь <em>продвинутое</em>!
		В оставшейся части урока мы применим полученные навыки для создания
		замечательного навигационного меню с интерактивным выпадающим подменю для
		одной из ссылок.
		Мы создадим <a href="https://internetingishard.netlify.app/html-and-css/advanced-positioning/example/menu">
		эту страницу</a> с самого нуля.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-15-submenu-with-z-index-f458d3.4bdcee44.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 15: веб-страница с выпадающим меню
</small></figcaption>
</figure>

<p>
    Фиксированное позиционирование позволит сделать меню прикрепленным к верхней
		части страницы, а относительное позиционирование создаст якорь для абсолютно
		позиционированного выпадающего меню.
		Мы также поговорим о методиках создания навигационных меню и рассмотрим
		практическое применение <a href="iih06-css-selectors.html#pseudo-classes-for-links">
		псевдоклассов</a>, о которых мы говорили на уроке <em>Селекторы CSS</em>.
</p><p>
    Для начала нам нужна новая веб-страница под названием menu.html, которая имеет
		заголовок и простое меню верхнего уровня:
</p><p class="code">
<span class="code-green">&lt;!DOCTYPE html&gt;</span><br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Awesome!&lt;/title&gt;<br>
&lt;link href='menu.css' rel='stylesheet'/&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
<br>
&lt;div class='header'&gt;<br>
&lt;div class='logo'&gt;&lt;img src='images/awesome-logo.svg'/&gt;&lt;/div&gt;<br>
&lt;ul class='menu'&gt;<br>
&lt;li class='dropdown'&gt;&lt;span&gt;Features ▾&lt;/span&gt;&lt;/li&gt;<br>
&lt;li&gt;&lt;a href='#'&gt;Blog&lt;/a&gt;&lt;/li&gt;<br>
&lt;li&gt;&lt;a href='#'&gt;Subscribe&lt;/a&gt;&lt;/li&gt;<br>
&lt;li&gt;&lt;a href='#'&gt;About&lt;/a&gt;&lt;/li&gt;<br>
&lt;/ul&gt;<br>
&lt;/div&gt;<br>
<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Навигационные меню почти всегда должны быть оформлены в виде списка &lt;ul&gt;,
		а не кучи элементов &lt;div&gt;.
		Такая семантика делает навигацию вашего сайта гораздо более доступной для
		поисковых систем.
		Также обратите внимание, как мы готовимся к созданию нашего выпадающего меню,
		добавляя атрибут class к первому &lt;li&gt; в списке.
		Этот &lt;span&gt; позволит нам отличить ярлык от подменю, которое он открывает.
</p><p>
    Далее нам понадобится новая таблица стилей menu.css, которая, помимо прочего,
		сделает наш .header более похожим на заголовок:
</p><p class="code">
<span class="code-strong">*</span> {<br>
<span class="code-green">margin</span>: 0;<br>
<span class="code-green">padding</span>: 0;<br>
<span class="code-green">box-sizing</span>: border-box;<br>
}<br>
<br>
<span class="code-strong">body</span> {<br>
<span class="code-green">height</span>: 1200px;<br>
<span class="code-green">font-size</span>: 18px;<br>
<span class="code-green">font-family</span>: sans-serif;<br>
<span class="code-green">color</span>: #5D6063;<br>
}<br>
<br>
<span class="code-strong">a</span>:link,<br>
<span class="code-strong">a</span>:visited {<br>
<span class="code-green">color</span>: #5D6063;<br>
<span class="code-green">text-decoration</span>: none;<br>
}<br>
<span class="code-strong">a</span>:hover {<br>
<span class="code-green">text-decoration</span>: underline;<br>
}<br>
<br>
<span class="code-blue">.header</span> {<br>
<span class="code-green">position</span>: fixed;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: space-between;<br>
<br>
<span class="code-green">width</span>: 100%;<br>
<span class="code-green">padding</span>: 50px;<br>
<span class="code-green">background</span>: #D6E9FE;<br>
}
</p><p>
    Все это должно быть вам знакомо.
		Однако обратите внимание на фиксированное положение .header, благодаря которому
		наше меню навигации находится поверх любого контента, размещенного на странице.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-16-menu-block-list-items-c1ac6a.3d13722f.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 16: веб-страница с меню, составленным из блоков &lt;li&gt; (без позиционирования)
</small></figcaption>
</figure>

<div class="title">строчные элементы меню<br>inline menu items</div>
<p>
    Хотя навигационные меню на большинстве сайтов размечены как неупорядоченные
		списки, на самом деле они не выглядят как списки.
		Мы можем исправить это.
		С помощью свойства display, мы сделаем элементы списка <a href="iih05-css-box-model.html#block-and-inline-elements">
		строчными блоками</a> вместо блоковых блоков.
		Добавьте в menu.css следующее:
</p><p class="code">
<span class="code-blue">.menu</span> {<br>
<span class="code-green">margin-top</span>: 15px;<br>
}<br>
<br>
<span class="code-blue">.menu</span> > <span class="code-strong">li</span> {<br>
<span class="code-green">display</span>: inline;<br>
<span class="code-green">margin-right</span>: 50px;<br>
}<br>
<br>
<span class="code-blue">.menu</span> > <span class="code-strong">li</span>: last-of-type {<br>
<span class="code-green">margin-right</span>: 0;<br>
}
</p><p>
    Мы используем <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Child_combinator">
		селекторы дочерних элементов</a>, вместо <a href="iih06-css-selectors.html#descendant-selectors">
		селекторов потомков</a>.
		Все потому, что мы хотим выбрать только элементы &lt;li&gt;, находящиеся как раз
		внутри .menu.
		Это станет особенно важным, когда мы добавим подменю, имеющее свои собственные
		элементы &lt;li&gt;, которые мы не хотим стилизовать с помощью этого правила.
		Также мы добавили отступы margins ко всем элементам списка, но удалили их из
		последнего &lt;li&gt; псевдоклассом :last-of-type.
		Отступы margins <em>между</em> элементами - довольно распространенная практика.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-17-menu-inline-list-items-1e8d70.8efcd10b.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 17:  меню, состоящее из строчных элементов &lt;li&gt; (без позиционирования)
</small></figcaption>
</figure>

<div class="title">подменю<br>submenus</div>
<p>
    Наше подменю будет выглядеть так же, как и меню верхнего уровня, за исключением
		того, что все оно будет вложено в cписок [list].
		Измените элемент .menu следующим образом, чтобы весь список .features-menu был
		завернут в первый &lt;li&gt; элемента .menu.
</p><p class="code">
&lt;ul class='menu'&gt;<br>
&lt;li class='dropdown'&gt;&lt;span&gt;Features &amp;#9662;&lt;/span&gt;<br>
&lt;ul class='features-menu'&gt;           &lt;!-- Start of submenu --&gt;<br>
&lt;li&gt;&lt;a href='#'&lt;Harder&lt;/a&gt;&lt;/li&gt;<br>
&lt;li&gt;&lt;a href='#'&lt;Better&lt;/a&gt;&lt;/li&gt;<br>
&lt;li&gt;&lt;a href='#'&lt;Faster&lt;/a&gt;&lt;/li&gt;<br>
&lt;li&gt;&lt;a href='#'&lt;Stronger&lt;/a&gt;&lt;/li&gt;<br>
&lt;/ul&gt;                               &lt;!-- End of submenu --&gt;<br>
&lt;/li&gt;<br>
&lt;li>&lt;a href='#'&lt;Blog&lt;/a&gt;&lt;/li&gt;          &lt;!-- These are the same --&gt;<br>
&lt;li>&lt;a href='#'&lt;Subscribe&lt;/a&gt;&lt;/li&gt;<br>
&lt;li>&lt;a href='#'&lt;About&lt;/a&gt;&lt;/li&gt;<br>
&lt;/ul&gt;
</p><p>
    Это дает много важной информации для поисковых систем.
		Google увидит, что все эти новые элементы связаны с меткой Features и что
		они образуют отдельную секцию нашего сайта.
		Рекомендуем размечать сложные навигационные меню именно таким образом.
</p><p>
    Что касается CSS, то с интерактивным выпадающим меню мы разберемся позже.
		Сейчас же давайте просто приведем наше подменю в нужный вид.
		Добавьте несколько простых стилей, чтобы было видно блок, который мы пытаемся
		позиционировать:
</p><p class="code">
<span class="code-blue">.features-menu</span> {<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">flex-direction</span>: column;<br>
<span class="code-green">background</span>: #B2D6FF;<br>
<span class="code-green">border-radius</span>: 5px;<br>
<span class="code-green">padding-top</span>: 60px;<br>
}<br>
<br>
<span class="code-blue">.features-menu</span> <span class="code-strong">li</span> {<br>
<span class="code-green">list-style</span>: none;<br>
<span class="code-green">border-bottom</span>: 1px solid #FFF;<br>
<br>
<span class="code-green">padding</span>: flex;<br>
<span class="code-green">margin</span>: flex;<br>
}<br>
<br>
<span class="code-blue">.features-menu</span> <span class="code-strong">li</span>:last-of-type {<br>
<span class="code-green">border-bottom</span>: none;<br>
}
</p><p>
    Само подменю оформлено правильно, но оно отображается в неправильном месте и
		сильно портит остальные элементы меню верхнего уровня.
		Этого следовало ожидать, поскольку оно все еще статически позиционировано,
		а значит, взаимодействует со своим родителем и окружающими элементами.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-18-submenu-no-css-positioning-04280e.95686f50.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 18: веб-страница с нестилизованным подменю (только HTML)
</small></figcaption>
</figure>

<p>
    Для создания желаемой верстки используйте ваши новые навыки позиционирования CSS.
</p>

<div class="title">(Относительно) абсолютные подменю<br>(relatively) absolute submenus</div>
<p>
    Мы хотим, чтобы остальные элементы меню верхнего уровня отображались так же,
		как и до добавления подменю, как будто подменю вообще не было.
		Да это как раз то, как себя ведут абсолютно позиционированные элементы.
		Давайте попробуем?
		Добавьте несколько строк в правило .features-menu:
</p><p class="code">
<span class="code-blue">.features-menu</span> {<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">flex-direction</span>: column;<br>
<span class="code-green">background</span>: #B2D6FF;<br>
<span class="code-green">border-radius</span>: 5px;<br>
<span class="code-green">padding-top</span>: 60px;<br>
<br>
<span class="code-green">position</span>: absolute;      /* Добавьте эти строки */<br>
<span class="code-green">top</span>: -25px;<br>
<span class="code-green">left</span>: -30px;<br>
}
</p><p>
    Отлично!
		Подменю больше не является частью статического потока страницы, поэтому наши
		элементы меню верхнего уровня вернулись в нормальное состояние.
		Однако подменю должно появиться ниже ярлыка <strong>Features</strong>, а
		не в углу окна браузера.
		Какое совпадение... мы только что узнали, как это делается!
</p><p>
    Подменю находится в &lt;li class='dropdown'&gt;.
		Превращение его в позиционированный элемент должно изменить систему координат,
		используемую нашим абсолютно позиционированным .features-menu:
</p><p class="code">
<span class="code-blue">.dropdown</span> {<br>
<span class="code-green">position</span>: relative;<br>
}
</p><p>
    Однако есть одна проблема.
		Хотя подменю находится в правильном месте, но теперь оно закрывает ярлык <strong>
		Features</strong>.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-19-submenu-relative-and-absolute-positioning-9fe8a5.24ba19dd.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 19: веб-страница с абсолютно позиционированным подменю внутри
		относительного элемента
</small></figcaption>
</figure>

<div class="title">z-index</div>
<p>
    Ранее мы не сталкивались с проблемой "глубины".
		До сих пор все наши HTML-элементы отображались друг над другом или друг под
		другом интуитивно понятным образом.
		Но поскольку мы занимаемся продвинутыми вещами, полагаться на то, что браузер
		сам определит, какие элементы отображаются поверх других, не стоит.
</p><p>
    Свойство z-index позволяет управлять глубиной расположения элементов на странице.
		Если представить экран как трехмерное пространство, то отрицательные
		значения z-index уходят дальше вглубь страницы, а положительные - выходят
		за ее пределы.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-20-css-z-index-c87ef0.83043c0c.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 20: положительный z-index при выходе со страницы и отрицательный
		z-index при входе на страницу
</small></figcaption>
</figure>

<p>
    Другими словами, элемент .features-menu должен иметь меньший z-index, чем
		ярлык <strong>Features</strong>.
		По умолчанию значение z-index равно 0, поэтому давайте сделаем их оба выше
		этого значения.
		Мы удобно обернули ярлык Features в &lt;span&gt;, что позволяет нам стилизовать
		его с помощью дочернего селектора, как показано ниже:
</p><p class="code">
<span class="code-blue">.dropdown</span> > <span class="code-strong">span</span> {<br>
<span class="code-green">z-index</span>: 2;<br>
<span class="code-green">position</span>: relative;      /* Это важно! */<br>
<span class="code-green">cursor</span>: pointer;<br>
}<br>
<br>
<span class="code-blue">.features-menu</span> {<br>
<span class="code-grey"> /* ... */</span><br>
<span class="code-green">z-index</span>: 1;<br>
}
</p><p>
    Теперь ярлык <strong>Features</strong> должен появиться в верхней части подменю.
		Обратите внимание на строку position: relative;.
		Она <em>необходима</em>, потому что только позиционированные элементы обращают
		внимание на свойство z-index.
		Об этом легко забыть, поэтому сделайте заметку на следующий раз, на случай,
		если у вас возникнут проблемы с глубиной, а ваши правила CSS не будут иметь
		никакого результата.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-21-submenu-with-z-index-f458d3.4bdcee44.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 21: подменю после добавления положительного z-индекса
</small></figcaption>
</figure>

<p>
    Мы добавили пример использования свойства cursor, чтобы при наведении курсора
		на ярлык он выглядел как ссылка.
		Подробнее об этом можно прочитать на сайте <a href="https://developer.mozilla.org/ru/docs/Web/CSS/cursor">
		Mozilla Developer Network</a>.
</p>

<div class="title">псевдоклассы для выпадающих меню<br>pseudo-classes for dropdown menus</div>
<p>
    Отлично!
		Подменю готово!
		Наша последняя задача - скрыть его, пока пользователь не наведет на него курсор.
		Помните <a href="iih06-css-selectors.html#pseudo-classes-for-links">
		псевдокласс :hover</a> из главы "Селекторы CSS"?
		Мы используем его, чтобы превратить наше подменю в интерактивное выпадающее
		меню.
</p><p>
    Сначала нам нужно изменить существующее правило .features-menu, добавив
		селектор-потомок :hover.
		Тогда подменю будет видно только когда пользователь наведет на него курсор.
		Обновите селектор .features-menu следующим образом:
</p><p class="code">
<span class="code-blue">.dropdown</span>:<span class="code-grey">hover</span>
<span class="code-blue">.features-menu</span> {    /* Раньше это было `.features-menu` */<br>
<span class="code-green">display</span>: flex;     /* Оставьте все остальное в прежнем виде */<br>
<span class="code-green">flex-direction</span>: column;<br>
<span class="code-green">background</span>: #B2D6FF;<br>
  /* ... */<br>
}
</p><p>
    Затем нам нужно будет скрыть подменю с помощью свойства display.
		Добавьте новое правило в menu.css:
</p><p class="code">
<span class="code-blue">.features-menu</span> { <span class="code-grey">
/* Это новое правило. Добавьте его. */</span><br>
<span class="code-green">display</span>: none;<br>
}
</p><p>
    Установка display в none заставляет элемент полностью исчезнуть.
		Переопределив это значение с помощью flex в правиле :hover, мы фактически
		говорим браузеру снова показать .features-menu.
		Эта хитрая комбинация селекторов-потомков и псевдоклассов позволяет нам по
		условию скрывать или показывать элемент.
</p>

<div class="title">резюме</div>

<p>
    В этой главе мы рассмотрели четыре новые схемы верстки CSS:
</p><ul>
<li>Relative - относительное</li>
<li>Absolute - абсолютное</li>
<li>Relatively absolute - относительно-абсолютное</li>
<li>Fixed - фиксированное</li>
</ul><p>
    Относительное позиционирование изменяло положение элемента, не затрагивая
		окружающие его блоки.
		Абсолютное позиционирование выводило элементы из статического потока страницы
		и размещало их относительно окна браузера.
		Относительно абсолютное позиционирование позволяло вернуться в статический
		поток страницы.
		Наконец, фиксированное позиционирование позволяло нам создавать элементы,
		которые не прокручивались вместе с остальной частью страницы.
</p>

<figure>
<img class="pic-pages" src="./images/iih09-22-css-positioning-schemes-summary-d7f831.d62ebdc4.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 22: сравнение схем относительного, абсолютного, относительно
		абсолютного и фиксированного позиционирования
</small></figcaption>
</figure>

<p>
    Мы использовали эти новые методы позиционирования для создания довольно
		сложного навигационного меню.
		Если оно показалось вам сложным, значит, так оно и было.
		Но не волнуйтесь, вам не нужно <em>заучивать</em> HTML и CSS, на которых
		основано наше меню.
		Ваша цель должна заключаться в том, чтобы месяца через три вы могли вернуться
		к этому примеру и понять, что делают все эти декларации position: relative;
		и position: absolute;.
</p><p>
    Это меню также является хорошим примером того, как начало работы с HTML-разметкой
		значительно упрощает жизнь.
		Сначала мы создали нужную нам смысловую структуру [semantic structure].
<em>Затем</em> мы написали несколько замысловатых CSS, чтобы расположить блоки
    именно там, где нам нужно.
		Если вы смотрите на сложный эскиз и не уверены, с чего начать, то это отличный
		способ начать решать поставленную задачу.
</p><p>
    У нашего меню все еще есть одна большая недоработка: оно не создано для
		мобильных устройств.
		Во-первых, в смартфонах и планшетах отсутствует курсор.
		Во-вторых, наш макет не отображается хорошо, если размер браузера менее 960
		пикселей.
		Первое требует немного магии JavaScript (или <em>очень</em> продвинутого CSS),
		поэтому мы оставим это для другого курса.
		Но второе мы сможем решить с помощью адаптивного дизайна на следующем
		уроке.
</p>
<hr>
<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>АДАПТИВНЫЙ ДИЗАЙН</h2>
<p>УРОК Nº 10.</p>
<p><em>
    Учебник веб-разработки для начинающих по созданию сайтов, адаптированных под
		мобильные устройства
</em></p>


<p>
    В основе "адаптивного дизайна" заложена идея одинаково хорошего отображения
		сайта на всех устройствах - от широкоформатных мониторов до смартфонов.
		Это подход к веб-дизайну, который устраняет различие между мобильной версией
		сайта и его десктопным аналогом.
		В случае с адаптивным дизайном это одно и то же.
</p><p>
    Адаптивный дизайн осуществляется на основе CSS "медиавыражений" [media queries].
		Медиавыражения - это способ условного применения правил CSS.
		Они указывают браузеру игнорировать или применять определенные правила в зависимости
		от устройства пользователя.
</p>

<figure>
<img class="pic-pages" src="./images/iih10-01-how-responsive-websites-work-5f0a33.6f90539d.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: HTML-контент, указывающий на медиа-запросы, которые направлены на
		мобильные, планшетные и настольные компьютеры
</small></figcaption>
</figure>

<p>
    Медиавыражения позволяют представить один и тот же HTML-контент в виде разных
		CSS-версток.
		Так, вместо того чтобы поддерживать один сайт для смартфонов и другой,
		не связанный с ним, для ноутбуков/ПК, можно использовать одну и ту же HTML-разметку
		(и веб-сервер) для них обоих.
		Всякий раз, когда мы добавляем новую статью или исправляем опечатку в HTML,
		эти изменения автоматически отражаются как в мобильном, так и в широкоэкранном
		макете.
		Именно <em>по этой</em> причине мы <a href="iih02-basic-web-pages.html#structure-vs-presentation">
		отделяем контент от внешнего вида</a>.
</p><p>
    На этом уроке вы узнаете, что медиавыражения - это всего лишь тонкая обертка
		вокруг старого доброго CSS, с которым мы работали до сих пор.
		Также вы узнаете, что реализовать адаптивный макет на самом деле довольно просто.
		А вот <a href="iih11-responsive-images.html">адаптивные изображения</a> - это
		совсем другая история).
</p>

<div class="title">подготовка<br>setup</div>
<p>
    Создайте <a href="iih01-intro.html#atom">новый проект</a>, назвав его responsive-design
		и новый файл - responsive.html.
		Это самая пустая веб-страница, которую вы видели на этом курсе, но вскоре
		она продемонстрирует нечто очень важное.
</p><p class="code">
<span class="code-green">&lt;!DOCTYPE html&gt;</span><br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Responsive Design&lt;/title&gt;<br>
&lt;link rel='stylesheet' href='styles.css'/&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
&lt;!--  Здесь ничего нет! --&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Также для этого урока загрузите <a href="docs/iih10-images-e9877a.zip">
		несколько изображений</a>.
		Распакуйте их в ту же папку, что и responsive.html, сохранив родительскую
		папку images.
		Ваш проект должен выглядеть примерно так:
</p>

<figure>
<img class="pic-pages" src="./images/iih10-02-project-files-76223b.dd1bc205.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2: файловый браузер Atom с файлами проекта в нем
</small></figcaption>
</figure>

<div class="title" id="media-queries">медиавыражения<br>css media queries</div>
<p>
    Мы начнем с малого - обновим цвет фона элемента &lt;body&gt; в зависимости
		от ширины устройства.
		Это хороший способ убедиться, что наши медиавыражения действительно работают,
		прежде чем перейдем к сложным макетам.
</p>

<figure>
<img class="pic-pages" src="./images/iih10-03-simple-responsive-media-queries-703f8b.73c5a09a.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: цвета фона для настройки с помощью медиавыражений: смартфон - красный
		фон, планшет - желтый, десктоп - синий.
</small></figcaption>
</figure>

<p>
    Давайте разграничим узкую, среднюю и широкую верстки CSS, создав новую
		таблицу стилей styles.css и добавив в нее следующее:
</p><p class="code">
* {<br>
<span class="code-green">margin</span>: 0;<br>
<span class="code-green">padding</span>: 0;<br>
<span class="code-green">box-sizing</span>: border-box;<br>
}<br>
<br>
<span class="code-grey"> /* Стили для смарфонов */</span><br>
<span class="code-strong">@media</span> only screen and (max-width: 400px) {<br>
<span class="code-strong">body</span> {<br>
<span class="code-green">background-color</span>: #F09A9D; /* Красный */ <br>
}<br>
}<br>
<br>
<span class="code-grey"> /* Стили для планшетов */</span><br>
<span class="code-strong">@media</span> only screen and (min-width: 401px) and (max-width: 960px) {<br>
<span class="code-strong">body</span> {<br>
<span class="code-green">background-color</span>: #F5CF8E; /* Желтый */ <br>
}<br>
}<br>
<br>
<span class="code-grey"> /* Стили для ноутбуков и ПК */</span><br>
<span class="code-strong">@media</span> only screen and (min-width: 961px) {<br>
<span class="code-strong">body</span> {<br>
<span class="code-green">background-color</span>: #B2D6FF; /* Синий */ <br>
}<br>
}
</p><p>
    При изменении размера браузера вы должны увидеть три разных цвета фона:
		синий, если ширина больше 960px, желтый, если от 401px до 960px, и красный,
		если меньше 400px.
</p><p>
    Медиавыражения всегда начинаются с @media.
		Это "at-правило".
		За ним следует какое-то условное выражение, а затем фигурные скобки.
		Внутри фигурных скобок помещается куча обычных правил CSS.
		Браузер воспринимает эти правила только когда выполняется условие.
</p>

<figure>
<img class="pic-pages" src="./images/iih10-04-media-query-terms-137d06.b9b92eca.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: медиавыражение [media query], состоящее из правила @media at-rule, типа
		[media type], функции [media feature] и нескольких обычных CSS-правил
</small></figcaption>
</figure>

<p>
    only screen это "медиа тип", означающий, что содержащиеся в нем стили
		должны применяться только к устройствам с экранами (в отличие от распечатываемых
		документов, например, когда вы в браузере нажимаете комбинацию клавиш <strong>
		Cmd+P</strong>*).
		Значения min-width и max-width называются "медиафункциями" [media features].
		Они указывают размеры устройств, на которые вы ориентируетесь.
</p><p>
    Вышеперечисленные медиавыражения являются наиболее распространенными, но
		существует множество <a href="https://developer.mozilla.org/ru/docs/Web/CSS/@media">
		других условий</a>, которые можно проверить, включая портретный или ландшафтный**
		режим, разрешение экрана, наличие или отсутствие мыши.
</p><p class="notetran">
	  * - в Windows: Ctrl+P;<br>
		** - portrait / landscape mode - расхожее обозначения вертикального и
		горизонтального режима отображения.
</p>

<div class="title" id="few-notes-on-design">немного о дизайне<br>a few notes on design</div>
<p>
    Итак, @media - это то, как мы определяем различные макеты для определенной
		ширины устройства.
		Но какие макеты мы на самом деле пытаемся реализовать?
		Пример веб-страницы для этой главы будет выглядеть примерно так:
</p>

<figure>
<img class="pic-pages" src="./images/iih10-05-mobile-first-design-be30e4.8ea67e2a.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5: эскизы веб-страниц для смартфонов, планшетов и настольных ПК
</small></figcaption>
</figure>

<p>
    В реальном мире именно ваш веб-дизайнер должен предоставить вам такие макеты.
		Ваша задача как разработчика - воплотить отдельные верстки CSS с помощью медиавыражений,
		чтобы разделить различные правила CSS, применимые к каждой из них.
</p><p>
    Существует несколько <a href="https://web.dev/learn/design/?hl=en">
		четко определенных шаблонов</a> того, как макет для ноутбуков/ПК превращается
		в макет для мобильных устройств.
		Мы используем так. наз. "перевертыш" (layout shifter).
		Многие из этих решений относятся к области дизайна, что выходит за рамки данного
		учебника, ориентированного на код.
		Однако есть две концепции, которые вы как разработчик должны хорошо для себя уяснить:
</p><ul>
<li>"Жидкий" макет - он растягивается и сжимается, заполняя ширину экрана,
	  подобно <a href="iih08-flexbox.html#">гибким блокам</a> [flexible boxes],
		мы рассматривали их несколько уроков назад.</li>
<li>Макет "фиксированной ширины" [fixed-width] наоборот: он имеет одинаковую ширину независимо
	  от размеров экрана (мы создали один из таких макетов на уроке <a href="iih06-css-selectors.html#container-divs">
		Селекторы CSS</a>).</li>
</ul>

<figure>
<img class="pic-pages" src="./images/iih10-06-fixed-width-vs-fluid-layouts-258df9.e0ad9d98.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: жидкий макет расширяется, заполняя всю ширину браузера, макет с
		фиксированной шириной остается неизменным, даже если браузер становится шире
</small></figcaption>
</figure>

<p>
    В нашем примере веб-страница для мобильных устройств и планшетов жидкая, а
		для настольных ПК - фиксированной ширины.
</p>

<div class="title-under">ВЫБОР ТОЧЕК ОСТАНОВА<br>choosing breakpoints</div>
<p>
    Большинство <a href="https://web.dev/learn/design/?hl=en">шаблонов адаптивного
		дизайна</a> имеют схожее поведение, используя жидкие макеты для смартфонов и
		планшетов и макеты фиксированной ширины для более широких экранов.
		На это есть своя причина.
</p><p>
    Жидкие макеты позволяют ориентироваться не на определенные мобильные устройства,
		а на <em>диапазон</em> ширины экрана.
		Это очень важно для веб-дизайнеров.
		Когда они создают мобильный макет, они не пытаются сделать что-то, что будет
		хорошо смотреться на iPhone 6s, Galaxy S7 или iPad mini - они разрабатывают
		жидкий макет, который будет хорошо смотреться <em>в диапазоне</em> от 300 до
		500 пикселей (или любом другом).
</p><p>
    Иными словами, точные значения пикселей для параметров min-width и max-width
		в медиавыражении (в совокупности известные как "точки останова"* для адаптивного
		сайта) на самом деле не имеют значения.
		Нашему сайту все равно, с какого устройства его просматривает пользователь.
		Все, что ему нужно знать, - это то, чтобы отображаемый макет выглядел красиво
		на ширине 400 пикселей (или любой другой).
</p><p class="notetran">
	  * - точку останова также называют "брейкпоинт". Это прямое заимствование исходного
		термина breakpoint.
</p>

<div class="title" id="mobile-first-developement">сначала мобильные устройства<br>mobile-first development</div>
<p>
    Давайте сразу же приступим к воплощению приведенных выше скриншотов.
		Всегда стоит начинать с мобильного макета и затем переходить к десктопной версии.
		Макеты для настольных ПК обычно сложнее их мобильных аналогов.
		Подход "mobile-first" максимально увеличивает объем CSS, который потом можно
		использовать в последующей верстке.
</p><p>
    Сначала в responsive.html заполним элемент &lt;body&gt; несколькими пустыми блоками.
		Чтобы было проще различать блоки, в каждом из них есть картинка.
</p><p class="code">
&lt;div class='page'&gt;<br>
&lt;div class='section menu'&gt;&lt;/div&gt;<br>
&lt;div class='section header'&gt;<br>
&lt;img src='images/header.svg'/&gt;<br>
&lt;/div&gt;<br>

&lt;div class='section content'&gt;<br>
&lt;img src='images/content.svg'/&gt;<br>
&lt;/div&gt;<br>

&lt;div class='section sign-up'&gt;<br>
&lt;img src='images/sign-up.svg'/&gt;<br>
&lt;/div&gt;<br>

&lt;div class='section feature-1'&gt;<br>
&lt;img src='images/feature.svg'/&gt;<br>
&lt;/div&gt;<br>

&lt;div class='section feature-2'&gt;<br>
&lt;img src='images/feature.svg'/&gt;<br>
&lt;/div&gt;<br>

&lt;div class='section feature-3'&gt;<br>
&lt;img src='images/feature.svg'/&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;
</p><p>
    А теперь наши базовые стили, которые должны применяться ко <em>всем</em>
		макетам (мобильным, планшетным и десктопным).
		Убедитесь, что они добавлены выше ранее созданных правил @media, но при этом
		ниже правила <a href="iih05-css-box-model.html#resetting-styles">
		универсального селектора</a>, которое сбрасывает наши отступы margins и paddings:
</p><p class="code">
	<span class="code-blue">.page</span> {<br>
	<span class="code-green">display</span>: flex;<br>
	<span class="code-green">flex-wrap</span>: wrap;<br>
	}<br>
	<br>
	<span class="code-blue">.section</span> {<br>
	<span class="code-green">width</span>: 100%;<br>
	<span class="code-green">height</span>: 300px;<br>
	<span class="code-green">display</span>: flex;<br>
	<span class="code-green">justify-content</span>: center;<br>
	<span class="code-green">align-items</span>: center;<br>
	}<br>
	<br>
	<span class="code-blue">.menu</span> {<br>
	<span class="code-green">background-color</span>: 
	<span class="code-grey">/* синий */</span><br>
	<br>
	<span class="code-green">height</span>: 80px;<br>
	}<br>
	<br>
	<span class="code-blue">.header</span> {<br>
	
	<span class="code-green">background-color</span>: #B2D6FF;
	<span class="code-grey">/* голубой */</span><br>
	}<br>
	<br>
	<span class="code-blue">.content</span> {<br>
	<span class="code-green">background-color</span>: #EAEDF0;<br>
	<span class="code-grey">/* светлый серый */</span><br>
	
	<span class="code-green">height</span>: 600px;<br>
	}<br>
	<br>
	<span class="code-blue">.sign-up</span> {<br>
	<span class="code-green">background-color</span>: #D6E9FE;
	<span class="code-grey">/* серо-голубой  */</span><br>
	}<br>
	<br>
	<span class="code-blue">.feature-1</span> {<br>
	<span class="code-green">background-color</span>: #F5CF8E;
	<span class="code-grey">/* желтовато-оранжевый */</span><br>
	}<br>
	<br>
	<span class="code-blue">.feature-2</span> {<br>
	<span class="code-green">background-color</span>: #F09A9D;
	<span class="code-grey">/* розоватый */</span><br>
	}<br>
	<br>
	<span class="code-blue">.feature-3</span> {<br>
	<span class="code-green">background-color</span>: #C8C6FA;
	<span class="code-grey">/* лавандовый */</span><br>
	}
	</p><p>
    Уменьшая окно браузера, увидим, что таким образом получается
		весь наш мобильный макет.
		Довольно просто, да?
		Никаких медиавыражений не требуется.
		Вот почему это называется "mobile-first" - мобильная версия не требует никакой
		специальной обработки.
		Также обратите внимание на <a href="iih08-flexbox.html#wrapping-flex-items">
		свойство flex-wrap</a> в содержащем .page div.
		Оно легко позволит применить наши макеты для отображения на планшетах
		и ПК.
</p>

<figure>
<img class="pic-pages" src="./images/iih10-07-mobile-layout-55fdad.a510b5bc.png"
width="20%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: Mobile-first CSS-версия для смартфонов (без медиавыражений)
</small></figcaption>
</figure>

<p>
    Сохраняя эти базовые стили вне медиавыражений, можно дополнять и переопределять
		их по мере реализации наших конкретных макетов.
		Это очень удобно, если, например, ваш дизайнер захочет изменить цветовую схему
		для всего сайта.
		Вместо того чтобы искать лишние объявления о цвете фона в нескольких правилах
		@media, достаточно обновить его здесь.
		Это изменение автоматически применяется к макетам для смартфонов, планшетов
		и ноутбуков/ПК.
</p>

<div class="title">макет для планшета<br>tablet layout</div>
<p id="grid-01">
    Переходим к макету для планшета.
		Единственное различие между мобильным и планшетным макетами заключается в том,
		что разделы <strong>Sign Up</strong> и <strong>Feature</strong> формируют
		сетку 2×2, а не одну колонку.
</p><p>
    Flexbox позволяет сделать это довольно легко.
		Достаточно установить ширину flex-элементов на половину экрана, и flex-wrap
		позаботится об остальном.
		Конечно, мы хотим, чтобы это поведение применялось только к экранам размером
		с планшет, поэтому его нужно включить в правило @media.
		Замените существующий медиазапрос /* Стили для планшета */ следующим:
</p><p class="code">
<span class="code-grey">/* Стили для планшета */</span><br>
<span class="code-strong">@media</span> only screen and (min-width: 401px) and (max-width: 960px) {<br>
<span class="code-blue">.sign-up</span>,<br>
<span class="code-blue">.feature-1</span>,<br>
<span class="code-blue">.feature-2</span>,<br>
<span class="code-blue">.feature-3</span> {<br>
<span class="code-green">width</span>: 50%;<br>
}<br>
}
</p><p id="grid-02">
    Чтобы увидеть эти изменения, убедитесь, что ширина окна вашего браузера
		составляет от 400 до 960 пикселей, затем прокрутите страницу вниз.
		Вы должны увидеть разноцветную сетку:
</p>

<figure>
<img class="pic-pages" src="./images/iih10-08-tablet-layout-081d9e.57525f07.png"
width="20%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: веб-страница, показывающая сетку, созданную с помощью медиазапроса
		для планшета
</small></figcaption>
</figure>

<p>
    Опять же, не имеет значения точная ширина экрана: этот макет будет плавно
		реагировать на любую ширину в диапазоне медиазапроса.
		Наш мобильный макет жидкий, так что теперь у нас есть сайт, который
		выглядит красиво (хотя и несколько пустым) на любом устройстве с шириной
		экрана менее 960px.
</p>

<div class="title">макет для ПК<br>desktop layout</div>
<p>
    Вот тут-то и пригодится наш макет для десктопа.
	  Мы не хотим, чтобы наша веб-страница бесконечно расширялась, поэтому зададим
    ей фиксированную ширину и <a href="iih05-css-box-model.html#aligning-boxes">
	  выровняем по центру с помощью auto-margins</a>.
	  Как и в случае со стилями для планшетов, это нужно сделать в медиазапросе.
	  Замените существующий медиазапрос /* Стили для ноутбуков и ПК */ следующим:
</p><p class="code">
<span class="code-grey">/* Стили для ноутбуков и ПК */</span><br>
<span class="code-strong">@media</span> only screen and (min-width: 961px) {<br>
<span class="code-blue">.page</span>,<br>
<span class="code-green">width</span>: 960 px;<br>
<span class="code-green">margin</span>: 0 auto;<br>
}<br>
<span class="code-blue">.feature-1</span>,<br>
<span class="code-blue">.feature-2</span>,<br>
<span class="code-blue">.feature-3</span> {<br>
<span class="code-green">width</span>: 33.3%;<br>
}<br>
<span class="code-blue">.header</span> {<br>
<span class="code-green">height</span>: 400 px;<br>
}<br>
}
</p><p>
    Это дает нам правильную ширину для всего.
		Теперь у нас есть больше возможностей поэкспериментировать.
		Для удобства наших экспериментов мы немного увеличили размер заголовка.
		Почти готово, но наш макет для ноутбуков/ПК требует некоторого
		переупорядочивания: блоки <strong>Sign Up</strong> и <strong>Content</strong>
		должны отображаться <em>ниже</em> блоков <strong>Features</strong>.
</p>

<figure>
<img class="pic-pages" src="./images/iih10-09-desktop-layout-8479d0.ddfe3b63.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: макет веб-страницы для ноутбуков и ПК до [before] и после [after]
		переупорядочивания с помощью flexbox
</small></figcaption>
</figure>

<p>
    Вот где флексбокс действительно блистает.
		Попытка создать такую комбинацию макетов для смартфонов и ноутбуков/ПК была
		бы очень сложной при использовании <a href="iih07-floats.html">плавающих
		элементов floats</a>.
		С помощью flexbox-<a href="iih08-flexbox.html#flex-item-order">свойства order</a>
		это можно сделать всего парой строк CSS.
		Добавьте в медиазапрос для ноутбуков и ПК следующие правила :
</p><p class="code">
<span class="code-blue">.sign-up</span> {<br>
<span class="code-green">height</span>: 200 px;<br>
<span class="code-green">order</span>: 1;<br>
}<br>
<span class="code-blue">.content</span> {<br>
<span class="code-green">order</span>: 2;<br>
}
</p><p>
    Ура! Адаптивный сайт!
		Весьма неплохо, учитывая то, что нам потребовалось менее сотни строк CSS.
		Что еще более важно, чтобы приспособить макеты для смартфонов, планшетов,
		ноутбуков и настольных ПК, не пришлось изменять ни одной строки HTML.
</p><p>
    Это был лишь один пример создания адаптивного (отзывчивого) сайта.
		Вы можете использовать эти же приемы для реализации любого другого дизайна.
		Начните с базовых стилей, применяющихся ко всему сайту, затем подстройте их
		под ширину различных устройств, выборочно применяя правила CSS с помощью @media.
		Можно добавить еще одно медиавыражение, создающее особый макет для
		сверхширокоформатных мониторов.
</p>

<div class="title">отключение зум-режима<br>disabling viewport zooming</div>

<p>
    Для закрытия темы создания адаптивной веб-страницы, осталось решить
		последнюю задачу.
		До появления адаптивного дизайна мобильные устройства могли работать только
		с версией для ноутбуков/ПК.
		При этом мобильное устройство тупо уменьшало масштаб, чтобы вместить в ширину
		своего экрана весь макет для ноутбука/ПК.
		Пользователю приходилось просто увеличивать масштаб.
</p>

<figure>
<img class="pic-pages" src="./images/iih10-10-html-viewport-zooming-5c4be6.7a6a88c7.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10: слева - включенный zoom (отображается макет для ноутбуков/ПК)
		и справа - отключенный zoom (отображается мобильная версия)
</small></figcaption>
</figure>

<p>
    Такое поведение по умолчанию не позволит мобильным устройствам использовать
		наш мобильный макет, что, разумеется, очень плохо.
		Чтобы отключить его, добавьте следующий элемент в &lt;head&gt; нашего документа.
		Как и <a href="iih03-links-and-images.html#more-html-attributes">&lt;meta charset='UTF-8'/&gt;</a>,
		это критически важный элемент, который должен присутствовать на каждой
		созданной вами веб-странице:
</p><p class="code">
&lt;meta name='viewport' <br>
content='width=device-width, initial-scale=1.0, maximum-scale=1.0' /&gt;
</p><p>
    Чтобы увидеть это в действии, нам нужно <em>смоделировать</em> мобильное
		устройство в браузере ПК.
		Это немного сложно, учитывая ваш начальный уровень, но можно попробовать.
		В Google Chrome откройте файл responsive.html, затем в строке меню выберите
<strong>
		View > Developer > Developer Tools</strong>.
		Чтобы смоделировать мобильное устройство, нажмите на иконку <strong>
		Toggle Device Toolbar</strong> (см. скриншот ниже).
</p>

<figure>
<img class="pic-pages" src="./images/iih10-11-chrome-device-toolbar-bb030a.c860ac2c.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: значок responsive в панели инструментов разработчика браузера Chrome
</small></figcaption>
</figure>

<p>
    В браузере должна появиться версия приведенного выше скриншота с отключенным
		масштабированием, поскольку теперь он прикидывается мобильным устройством.
		(Мы оставим подробное обсуждение инструментария Chrome dev tools для одного
		из следующих учебников).
</p><p>
    Если вы читаете эти строки на смартфоне, вы можете сравнить обе версии нашего проекта - это
		<a href="https://internetingishard.netlify.app/html-and-css/responsive-design/example/default-viewport-zoom/responsive">"до"</a>, а это
		<a href="https://internetingishard.netlify.app/html-and-css/responsive-design/example/disabled-viewport-zoom/responsive">"после"</a>.
		Как говорится - "почувствовуйте разницу!"
</p>

<div class="title">резюме</div>
<p>
    Хотите верьте, хотите нет, но это все, что нужно знать для создания
		адаптивных сайтов.
		Попросту говоря, нас заботят только три вещи:
</p><ul>
<li>Адаптивный <em>дизайн</em> (эскизы для каждого макета)</li>
<li>Правила CSS для воплощения каждого из этих макетов</li>
<li>Медиавыражения для условного применения этих правил CSS</li>
</ul><p>
    В начале этого урока вы узнали разницу между жидкими макетами и макетами с
		фиксированной шириной.
		Затем мы создали стили, ориентированные на мобильные устройства.
		На основе общего набора базовых стилей там использовались медиавыражения
		для создания макетов для планшетов и ноутбуков/ПК.
		И наконец, мы отключили у мобильных браузеров стандартное масштабирование окна
		просмотра.
</p><p>
    Итак, это была простая часть адаптивного дизайна.
		На следующем уроке мы изучим сложную часть - изображения.
		Создание различных CSS для определенных (мобильных) устройств не так уж сложно,
		в то время как оптимизация изображений для этих устройств требует более
		тщательного планирования.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>АДАПТИВНЫЕ КАРТИНКИ</h2>
<div class="chapter">УРОК Nº 11.</div>
<p><em>
    Адаптивные изображения - это сложно. Точнее, очень сложно. Но не пугайтесь.
</em></p>


<p>
    На уроке <a href="iih10-responsive-design.html">адаптивный дизайн</a> мы узнали,
		как использовать медиавыражения для создания версий для смартфонов,
		планшетов и настольных ПК.
		Теперь настала очередь картинок.
		Точно так же, как медиавыражения позволяют нам условно представлять различные
		правила CSS, мы хотим отображать различные изображения в зависимости от устройства
		пользователя.
</p>

<figure>
<img class="pic-pages" src="./images/iih11-01-responsive-images-overview-890631.fd4f8299.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: низкопиксельное изображение, передаваемое на ноутбук/ПК со стандартным
		экраном и мобильные устройства, в сравнении с высокопиксельным изображением,
		передаваемым на ноутбуки/ПК с ретина-экраном
</small></figcaption>
</figure>

<p>
    Проблема в том, что изображения имеют свои размеры.
		Мы не можем растянуть фотографию размером 500×250 пикселей до размера,
		превышающего 500 пикселей в ширину, потому что она будет расплываться.
		Дисплеи Retina и мобильные устройства усложняют ситуацию еще более.
		Чтобы сделать наши изображения адаптивными, мы должны учитывать три фактора:
</p><ul>
<li>Размеры устройства</li>
<li>Размеры изображения</li>
<li>Разрешение экрана устройства.</li>
</ul><p>
    Это будет сложнее, чем медиавыражения, которые учитывали только ширину устройства.
		Но не волнуйтесь, существуют стандартные способы решения всех этих проблем,
		и мы пройдемся по ним шаг за шагом.
</p>

<div class="title">подготовка<br>setup</div>

<p>
    Для экспериментов с адаптивными изображениями, нам нужен адаптивный
		веб-сайт для работы.
		На этом уроке мы рассмотрим пример веб-страницы, которую мы создали в <a href="iih10-responsive-design.html">
		предыдущей главе</a>.
		Мы добавим на страницу две картинки, чтобы она выглядела как на скриншоте ниже.
		Эта подготовка может показаться слишком простой, зато эти картинки будут
		меняться в зависимости от устройства пользователя (что <em>реально</em> круто).
</p>

<figure>
<img class="pic-pages" src="./images/iih11-02-site-with-responsive-images-1f0431.a7c6150b.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2: веб-страница с большой фотографией в заголовке и линейной
		иллюстрацией в контенте
</small></figcaption>
</figure>

<p>
    Если вы продолжаете работу с предыдущего урока, вам просто нужно <a href="docs/iih11-responsive-images-5e8a2c.zip">
		скачать эти изображения</a> и добавить их в папку images/ вашего проекта.
</p><p>
    Если вы только присоединились к нам, скачайте <a href="docs/iih11-example-7be588.zip">
		полный пример проекта</a>, распакуйте его и откройте с помощью Atom.
		Если вы не знакомы с текстовым редактором Atom, обязательно прочитайте <a href="iih01-intro.html#atom">
		введение</a> к этому учебнику.
</p>

<figure>
<img class="pic-pages" src="./images/iih11-03-project-files-d6d457.1e68de40.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: файловый браузер Atom после распаковки проекта
</small></figcaption>
</figure>

<p>
    В итоге файлы вашего проекта должны выглядеть как на скриншоте выше.
		Обратите внимание, что у нас есть несколько копий изображений PNG и JPG
		(например, illustration-big.png и illustration-small.png).
		Мы будем позволять браузеру выбирать, какое из них загружать, в зависимости
		от размера и разрешения экрана устройства.
</p>

<div class="title">ретина-экраны<br>retina screens</div>
<p>
    Раз уж речь пошла о "ретиновых" устройствах, давайте немного поговорим о
		разрешении экрана.
		Ретина-экраны имеют в два раза больше пикселей на дюйм, чем экраны стандартного
		разрешения.
		То есть каждый пиксель Retina эквивалентен 4 стандартным пикселям.
		Это сильно влияет на то, как изображения отображаются в веб-браузере.
</p>

<figure>
<img class="pic-pages" src="./images/iih11-04-standard-vs-retina-resolution-64f6b6.472e6170.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: экран стандартного разрешения с 4 пикселями и экран высокого
		разрешения (retina resolution) с 16 пикселями
</small></figcaption>
</figure>

<p>
    Для корректного отображения картинки на ретина-устройстве, она должна
		быть в два раза больше, чем ее конечные размеры на экране.
		Например, при добавлении на страницу картинки 500×250 пикселей, соответствующий
		файл картинки должен иметь размер 1000×500 пикселей.
</p>

<figure>
<img class="pic-pages" src="./images/iih10-05-retina-2x-image-dimensions-5a4673.878707e3.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5:  картинка высокого разрешения, уменьшенная до половины размера
		на ретина-экране
</small></figcaption>
</figure>

<p>
    На самом деле это некоторое упрощение - не все ретина-экраны созданы одинаковыми.
		Например, у iPhone 6 Plus в <em>три раза</em> больше пикселей на дюйм, чем
		у стандартного экрана.
		Здесь мы рассматриваем использование экрана 2x, но те же приемы применимы и
		к ретина-экранам 3x.
</p><p>
    Более того, стандартным дисплеям и небольшим устройствам не нужны все эти
		дополнительные пиксели в изображениях высокого разрешения, а отправка такого
		количества ненужных данных обычно приводит к недовольству пользователя.
</p>

<div class="title">адаптивные svg-изображения<br>responsive svg images</div>
<p>
    Самый простой способ решить все эти проблемы - использовать картинки <a href="iih03-links-and-images.html#svg-images">
		формата SVG</a>.
		Картинки этого формата "работают на пятерочку".
		Поскольку они векторные, SVG-картинки позволяют избежать проблемы разрешения
		экрана (см. ниже).
		Хотите узнать, как добавить картинку на нашу страницу responsive.html?
		Замените существующую картинку в div .content так, чтобы она соответствовала
		следующему:
</p><p class="code">
<span class="code-blue">&lt;div class=</span><span class="code-rust">'section content'</span><span class="code-blue">&gt;</span><br>
<span class="code-blue">&lt;img class=</span><span class="code-rust">'illustration'</span> <span class="code-blue">src=</span><span class="code-rust">'images/illustration.svg'</span> <span class="code-blue"> /&gt;</span><br>
<span class="code-blue">&lt;/div&gt;</span>
</p><p>
    Браузеры автоматически масштабируют SVG для ретина-устройств, поэтому SVG 500×250
		пикселей будет четко отображаться и на стандартных и на ретина-устройствах.
</p><p>
    SVG поможет забыть о проблемах с разрешением экрана, но чтобы картинка вписалась
		в жидкие макеты [fluid layouts] для планшетов и смартфонов, ее нужно уменьшить.
		Firefox сделает это автоматически, но если вы откроете эту страницу в Chrome
		и сделаете окно узким, вы увидите, что картинка осталось того же размера.
</p><p>
    Чтобы получить жидкое изображение в Chrome, нужно приказать картинке
		всегда заполнять ширину своего контейнера.
		В styles.css вместе с остальными базовыми стилями (вне медиавыражений!)
		поместите следующее правило:
</p><p class="code">
<span class="code-blue">.illustration</span> {<br>
<span class="code-green">width</span>: 100%;<br>
}
</p><p>
    Задавая ширину картинки 100 %, высота задается автоматически.
	  Предполагается, что мы хотим сохранить соотношение сторон.
		Это исправляет ситуацию с мобильным макетом, но теперь версия для ноутбуков/ПК
		становится <em>огромной</em>:
</p>

<figure>
<img class="pic-pages" src="./images/iih10-06-responsive-svg-image-bfa291.61196938.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: SVG-картинка уменьшается до ширины смартфонов и планшетов, но
		становится огромной на ноутбуках/ПК
</small></figcaption>
</figure>

<p>
    Такое поведение идеально для некоторых случаев дизайна, например для фото на
		всю ширину экрана (об этом чуть ниже).
		Сейчас же мы хотим ограничить ширину картинки до ее собственной, - в 500 пикселей.
		В этом нам поможет <a href="iih04-hello-css.html#inline-styles">встроенный стиль</a>:
</p><p class="code">
<span class="code-blue">&lt;div class=</span><span class="code-rust">'section content'</span><span class="code-blue">&gt;</span><br>
<span class="code-blue">&lt;img class=</span><span class="code-rust">'illustration'</span> <span class="code-blue">src=</span><span class="code-rust">'images/illustration.svg'</span>
<span class="code-blue">style=</span><span class="code-rust">'max-width: 500px'</span><span class="code-blue"> /&gt;</span><br>
<span class="code-blue">&lt;/div&gt;</span>
</p><p>
    Это один из редких случаев, когда встроенный стиль допустим, поскольку он
		описывает врожденное свойство изображения.
		Физические размеры изображения - это скорее контент, чем внешний вид, поэтому
		имеет смысл указывать их в HTML, а не в таблице стилей.
</p>

<figure>
<img class="pic-pages" src="./images/iih11-07-max-width-inline-style-073cc7.94921eae.png"
width="33%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: добавление встроенного стиля для ограничения размера SVG-изображения
</small></figcaption>
</figure>

<div class="title">адаптивные PNG, GIF, JPG<br>responsive png, gif, and
jpg images</div>
<p>
    Конечно, не все изображения в Интернете являются SVG.
		Иногда необходимо включить фотографию.
		Картинки PNG, GIF и JPG - это "растровые изображения", они определяются попиксельно,
		а не с помощью векторов.
		Поэтому они гораздо более чувствительны к разрешению экрана, чем SVG.
</p><p>
    Если вы не беспокоитесь об оптимизации, адаптивные растровые изображения
		действительно ненамного сложнее, чем SVG.
		Попробуйте заменить наш существующий файл illustration.svg на PNG-файл:
</p><p class="code">
<span class="code-blue">&lt;div class=</span><span class="code-rust">'section content'</span><span class="code-blue">&gt;</span><br>
<span class="code-blue">&lt;img class=</span><span class="code-rust">'illustration'</span> <span class="code-blue">/&gt;</span><br>
<span class="code-blue">&lt;img src=</span><span class="code-rust">'images/illustration-big.png'</span> <span class="code-blue">style=</span><span class="code-rust">'max-width: 500px'</span><span class="code-blue"> /&gt;</span><br>
<span class="code-blue">&lt;/div&gt;</span><br>
<span class="code-blue">&lt;/div&gt;</span>
</p><p>
    Мы немного изменили структуру HTML, вложив наш тег &lt;img/&gt; в другой контейнер.
		Без него изображение исказилось бы, потому что flexbox попытался бы установить
		его высоту равной высоте контейнера .content.
		Это также требует небольшого изменения нашего CSS-правила .illustration:
</p><p class="code">
<span class="code-blue">.illustration</span> <span class="code-strong">img</span> {<br>
<span class="code-green">width</span>: 100%;<br>
<span class="code-green">display</span>: block;<br>
}
</p><p>
    Также обратите внимание на суффикс -big в имени файла изображения.
		Это версия PNG с высоким разрешением и размером 1000×500.
		Ретина-устройствам для четкого отображегния необходим такой размер "2x".
		Изображение с низким разрешением (500×250 пикселей) выглядит хорошо на
		стандартных экранах, а на ретина-экранах будет размытым.
</p>

<figure>
<img class="pic-pages" src="./images/iih11-08-retina-responsive-images-9f367b.c8725ab5.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: подача картинки высокого разрешения на стандартные и на
		ретина-экраны (последнее расточительно)
</small></figcaption>
</figure>

<p>
    Данный способ создания адаптивных PNG, GIF и JPG можно назвать "лентяйским".
		Предполагается, что всем и всегда нужны высокопиксельные картинки.
		Но это не так.
		Картинка 1000×500 пикселей - это излишество для всех не ретиновых
		экранов.
		Об этом -  чуть ниже.
</p>

<div class="title">Оптимизация адаптивных изображений<br>responsive image optimization</div>
<p>
    Разные устройства предъявляют разные требования к изображениям.
		К счастью, HTML позволяет выбрать лучшее изображение для конкретного устройства
		пользователя.
		В следующих нескольких секциях мы рассмотрим три сценария оптимизации
		адаптивных изображений:
</p><ul>
<li>Экраны стандартного разрешения, которым не нужна картинка ретина-качества.</li>
<li>Retina-экраны, которые могут использовать картинки стандартного качества,
	  поскольку они сильно уменьшены.</li>
<li>HTML-макеты для ноутбуков/ПК, использующие широкие изображения, и соответствующие
	  мобильные макеты, использующие более высокое изображение.</li>
</ul><p>
    Первый способ - самый простой.
		Он отлично подходит для изображений шириной менее 600 пикселей, поскольку они
		недостаточно велики, чтобы воспользоваться вторым сценарием.
		Второй способ - очень важная оптимизация для больших изображений, особенно
		для полноцветных фотографий.
		Третий - для тех случаев, когда вы чувствуете себя крутым.
</p>

<div class="title">оптимизация srcset для ретина-экранов<br>retina optimization using srcset</div>
<p>
    Изображения высокого разрешения очень большие.
		Наш illustration-big.png занимает более чем в два раза больше места на
		диске, чем его аналог с низким разрешением.
		Нет смысла пересылать все эти дополнительные данные, если они фактически не
		нужны пользователю.
</p><p>
    Благодаря атрибуту srcset, добавленного к элементу &lt;img/&gt;, изображение
		с высоким разрешением будет подаваться <em>только</em> на ретина-экраны, а
		на обычные экраны будет подаваться версия с низким разрешением.
		Обновите элемент .illustration следующим образом:
</p><p class="code">
<span class="code-blue">&lt;div class=</span><span class="code-rust">'illustration'</span><span class="code-blue">&gt;</span><br>
<span class="code-blue">&lt;img src=</span><span class="code-rust">'illustration-small.png'<br>
<span class="code-blue">srcset=</span><span class="code-rust">'images/illustration-small.png 1x,<br>
images/illustration-big.png 2x'</span><br>
<span class="code-blue">style=</span><span class="code-rust">'max-width: 500px'</span><span class="code-blue"> /&gt;</span><br>
<span class="code-blue">&lt;/div&gt;</span>
</p><p>
    Атрибут srcset указывает на список альтернативных файлов изображений, а также
		свойства, определяющие, когда браузер должен использовать каждый из них.
		Значение 1x велит браузеру отображать illustration-small.png на обычных
		экранах, а 2x - отображать illustration-big.png на ретина-экранах.
		Старые браузеры, не понимающие srcset, возвращаются к атрибуту src.
</p>

<figure>
<img class="pic-pages" src="./images/iih11-09-retina-responsive-images-with-srcset-707397.0268e785.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: подача изображения с низким разрешением на стандартный экран и
		с высоким разрешением на ретина-экраны
</small></figcaption>
</figure>

<p>
    Обычно версии изображения с низким и высоким разрешением абсолютно одинаковы
		(за исключением их размеров), но мы сделали illustration-small.png желтым,
		чтобы вы могли легко отличить его от версии для ретина-экрана, которая имеет
		синий цвет.
</p><p>
    Увидеть это в действии без реального сайта немного сложно, поэтому мы включили
		предыдущий фрагмент кода на эту страницу.
		Картинка ниже должна быть синей, если вы просматриваете ее на ретина-экране.
		А вот на экранах стандартного разрешения она будет желтой.
</p>

<figure>
<img class="pic-pages" src="./images/iih11-10-illustration-small.9eefc3cd.png"
alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10: [если цвет желтый, то у вас экран стандартного разрешения.
		А если синий - то ретина-экран]
</small></figcaption>
</figure>

<p>
    Если вы создаете эти примеры на компьютере с ретина-экраном, можно попробовать
		временно изменить 2x на 1x, чтобы посмотреть, как выглядит изображение без
		ретина-экрана.
		Оно будет немного размытым (и желтым).
</p>

<div class="title">оптимизация ширины экрана с помощью srcset<br>screen width optimization using srcset</div>

<p>
    Класс!
		Можно сэкономить несколько байтов для устройств без ретина.
		К сожалению техника srcset упускает важный момент с большими картинками:
		если у пользователя смартфон с ретина-экраном, загрузится
		высокопиксельная картинка, даже когда обычной будет достаточно.
</p>

<figure>
<img class="pic-pages" src="./images/iih11-11-screen-width-optimization-with-srcset-6dd918.4e6d2a3c.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: низкопиксельная картинка, отправляемая на ноутбуки/ПК и мобильные
		устройства со стандартным экраном, в сравнении с низкопиксельной картинкой,
		отправляемой на ноутбуки/ПК с ретина-экраном
</small></figcaption>
</figure>

<p>
    Представьте, что в .header мы хотим отобразить большую фотографию.
		Ширина заголовка в нашем макете для ноутбуков/ПК - 960 пикселей.
		Тогда для хорошего отображения на ретина-экранах ширина фото должна быть не менее
		1920 пикселей.
		Для стандартных экранов мы также предоставим фотографию шириной 960 пикселей.
		Теперь рассмотрим смартфон с ретина-экраном.
		Смартфоны обычно имеют ширину менее 400 пикселей в портретном режиме.
		Тогда ширина соответствующего фото с качеством "ретина" должна быть
		всего 800 пикселей.
</p><p>
    Ого!
		Мы можем использовать фото стандартного разрешения на смартфонах с ретина-экраном!
</p><p>
    Отсюда следует вывод: оптимизировать большие изображения нужно исходя из их
		конечных размеров, а не только из разрешения экрана устройства.
		Давайте добавим это большое фото в наш элемент .header:
</p><p class="code">
<span class="code-blue">&lt;div class=</span><span class="code-rust">'section header'</span><span class="code-blue">&gt;</span><br>
<span class="code-blue">&lt;div class=</span><span class="code-rust">'photo'</span><span class="code-blue">&gt;</span><br>
<span class="code-blue">&lt;img src=</span><span class="code-rust">'images/photo-small.jpg'</span><br>
<span class="code-blue">srcset=</span><span class="code-rust">'images/photo-big.jpg 2000w,<br>
images/photo-small.jpg 1000w'<br>
<span class="code-blue">sizes=</span><span class="code-rust">'(min-width: 960px) 960px,<br>
100vw'</span><span class="code-blue">/&gt;</span><br>
<span class="code-blue">&lt;/div&gt;</span><br>
<span class="code-blue">&lt;/div&gt;</span>
</p><p>
    У нас тот же элемент srcset, что и в предыдущем разделе, но вместо дескрипторов
		1x и 2x мы указываем физическую ширину картинки.
		2000w говорит браузеру, что photo-big.jpg имеет ширину 2000 пикселей.
		Аналогично, 1000w означает, что ширина photo-small.jpg равна 1000 пикселям.
		Символ w это специальная единица, используемая только для такого рода сценариев
		оптимизации изображений.
</p>

<figure>
<img class="pic-pages" src="./images/iih11-12-img-srcset-physical-width-2153b0.fee137d6.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 12: srcset=1000w - ширина файла низкопиксельной картинки,
		srcset=2000w - ширина файла высокопиксельной картинки
</small></figcaption>
</figure>

<p>
    Для того, чтобы устройство определило, какую картинку следует загрузить,
		одной ширины изображения недостаточно.
		Устройство хочет знать, какой будет конечная ширина картинки.
		Здесь на помощь приходит атрибут sizes.
		Он определяет серию медиазапросов, а также ширину картинки, отображаемой при
		выполнении медиазапроса.
</p>

<figure>
<img class="pic-pages" src="./images/iih11-13-img-sizes-display-width-1f02b4.6d600f99.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 13: sizes=100vw - ширина изображения в мобильном макете,
		sizes=960px - ширина изображения в десктопном макете
</small></figcaption>
</figure>

<p>
    Так, если ширина экрана составляет не менее 960px, то и картинка будет шириной
		960 пикселей.
		Иначе стандартное значение 100vw говорит браузеру, что ширина картинки будет
		равна 100% от "ширины области просмотра" (англ. viewport width - модный термин
		для обозначения ширины экрана).
		Подробнее о vw читайте на <a href="https://developer.mozilla.org/ru/docs/Web/CSS/length">
		сайте MDN</a>.
		Все это соответствует поведению изменения размера картинки в нашем CSS.
</p><p>
    Кстати, для правильного расположения нашего нового фото в заголовка нужно
		внести некоторые изменения.
		Добавьте оба следующих правила в наши другие базовые стили, прямо над
		медиазапросом мобильных стилей:
</p><p class="code">
<span class="code-blue">.header</span> {<br>
<span class="code-green">height</span>: auto;<br>
<span class="code-green">justify-content</span>: inherit;<br>
<span class="code-green">align-items</span>: inherit;<br>
}<br>
<br>
<span class="code-blue">.photo</span> <span class="code-strong">img</span> {<br>
<span class="code-green">width</span>: 100%;<br>
<span class="code-green">display</span>: block;<br>
}
</p><p>
    Помните, что ширина нашего фото низкого разрешения равна 1000 пикселей.
		Это означает, что устройства с ретина-экраном 2x могут использовать ее, если
		ширина их экрана не превышает 500 пикселей.
		В Firefox теперь можно изменять размер браузера, чтобы видеть версию ретина
		("Big") при ширине окна более 500 пикселей и версию без ретина ("Small") при
		меньшей ширине.
</p><p>
    Теперь мы передаем на мобильные устройства изображение размером 115 КБ вместо
		изображения высокого разрешения размером 445 КБ.
		Это особенно актуально для сайтов с большим количеством фотографий.
</p>

<div class="title-under">ТЕСТИРОВАНИЕ В БРАУЗЕРЕ ХРОМ<br>testing with chrome</div>
<p>
    Эта техника отлично работает в Chrome, но не до конца понятно, как это
		происходит.
		Chrome всегда использует картинку с высоким разрешением, если она уже была
		локально кэширована.
		Поэтому мы не сможем увидеть картинку с низким разрешением, просто заузив
		окно браузера.
		Чтобы избежать локального кэша браузера, сделайте следующее: открыв новое окно
		Incognito Window, <em>перед загрузкой страницы</em> сделайте окно очень узким.
		Так можно предотвратить загрузку photo-big.jpg.
</p>

<div class="title">&lt;picture&gt; как решение проблемы художественного оформления<br>
	art direction using &lt;picture&gt;
</div>
<p>
    Предыдущая секция вполне пригодна для оптимизации использования данных.
		На этом можно бы и остановиться, но ведь мы хотим стать более
		искусными и в "художественом оформлении".
		Считайте художественное оформление [art direction] оптимизацией адаптивных
		картинок для дизайнеров.
</p><p>
    Художественное оформление позволяет оптимизировать <em>макеты</em> [layouts], отправляя пользователю
		разные варианты в зависимости от его устройства.
		В предыдущей секции, <em>одну и ту же</em> фотографию мы оптимизировали для
		разных устройств.
		Причем эта фотография в заголовке довольно широка.
		Разве не было бы здорово вместо широкой версии для ноутбуков/ПК, несколько
		обрезать края для отображения ее на мобильных устройствах?
</p>

<figure>
<img class="pic-pages" src="./images/iih11-14-art-direction-with-picture-764252.12bc7cf2.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 14: отображение фото, урезанного по высоте [tall-cropped] на мобильных
		устройствах и урезанного по ширине [wide-cropped] на ноутбуках/ПК с стандартными
		и ретина-экранами
</small></figcaption>
</figure>

<p>
    Для этого нам нужны элементы &lt;picture&gt; и &lt;source&gt;.
		Первый является просто оберткой, а второй условно загружает картинки на
		основе медиавыражений.
		Попробуйте изменить наш элемент .header:
</p><p class="code">
<span class="code-blue">&lt;div class=</span><span class="code-rust">'section header'</span><span class="code-blue">&gt;</span><br>
<span class="code-blue">&lt;div class=</span><span class="code-rust">'photo'</span><span class="code-blue">&gt;</span><br>
<span class="code-blue">&lt;picture&gt;</span><br>
<span class="code-blue">&lt;source media=</span><span class="code-rust">'(min-width: 401px)'<br>
<span class="code-blue">srcset=</span><span class="code-rust">'images/photo-big.jpg'</span><span class="code-blue"> /&gt;</span><br>
<span class="code-blue">&lt;source media=</span><span class="code-rust">'(max-width: 400px)'<br>
<span class="code-blue">srcset=</span><span class="code-rust">'images/photo-tall.jpg'</span><span class="code-blue"> /&gt;</span><br>
<span class="code-blue">&lt;img src=</span><span class="code-rust">'images/photo-small.jpg'</span><span class="code-blue"> /&gt;</span><br>
<span class="code-blue">&lt;/picture&gt;</span><br>
<span class="code-blue">&lt;/div&gt;</span><br>
<span class="code-blue">&lt;/div&gt;</span>
</p><p>
    По своей концепции это похоже на использование медиавыражений в CSS.
		В каждом элементе <source> атрибут media определяет, <em>когда</em> должна
		загружаться картинка, а srcset - <em>какой</em> файл должен быть загружен.
		Элемент &lt;img/&gt; используется только как запасной вариант для старых
		браузеров.
		Уменьшив окно браузера, вы сможете увидеть высокую версию фото:
</p>

<figure>
<img class="pic-pages" src="./images/iih11-15-art-directed-mobile-image-91ca9e.45c96f51.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 15: в мобильной версии фото урезано по высоте, а в версии
		для ноутбуков/ПК - по ширине
</small></figcaption>
</figure>

<p>
    Такой уровень контроля очень обрадует вашего дизайнера.
		Однако есть и недостаток - браузер не может автоматически выбирать оптимальное
		изображение.
		То есть мы потеряли нашу оптимизацию для ретина-экранов из предыдущей
		cекции: до тех пор, пока ширина экрана составляет 401 пиксель или больше,
		браузер <em>всегда</em> будет использовать высокопиксельное изображение, урезанное
		по ширине [wide-cropped image].
</p><p>
    Пытаясь совместить лучшее из двух миров, все быстро усложняется.
		Мы рекомендуем придерживаться версий srcset 1x и 2x для картинок шириной
		менее 600 пикселей, использовать метод srcset плюс sizes из предыдущей секции
		для больших фотографий, а &lt;picture&gt; оставить для тех случаев, когда вместе
		с дизайнером вы задумаете что-то сногсшибательное.
</p>

<div class="title">РЕЗЮМЕ<br></div>
<p>
	  Адаптивные изображения могут показаться довольно сложными, но на самом деле мы
	  пытаемся решить всего две задачи:
</p><ul>
<li>Вписать изображение в мобильную версию сайта, "уважая" его размеры</li>
<li>Избежать отправки пользователю черезчур громоздких изображений</li>
</ul><p>
    Мы решили первую задачу, заставив изображения всегда растягиваться, чтобы
		заполнить 100% своего контейнера, и ограничив их размер с помощью встроенного
		стиля max-width.
		Чтобы решить вторую задачу, мы использовали srcset для оптимизации под разрешение
		экрана, srcset и sizes для оптимизации под ширину устройства и, наконец,
		элемент &lt;picture&gt; для ручного управления отображением файла изображения.
</p><p>
<a href="iih10-responsive-design.html">
    Адаптивный дизайн</a> - постоянно развивающаяся технология.
		Браузеры только недавно внедрили методы оптимизации изображений, рассмотренные
		выше. И это несмотря на то, что адаптивный дизайн является стандартом уже
		полдесятка лет.
		Технологии для создания адаптивного сайта могут меняться, однако фундаментальная
		проблема внешнего вида одного и того же контента на разных устройствах никогда
		не исчезнет.
		Со временем вам придется освоить новые инструменты, но базовые концепции из
		этого урока должны остаться с вами навсегда.
</p><p>
    Оставшиеся пять глав полностью посвящены верстке.
		Мы изучили плавающие элементы, flexbox, продвинутое позиционирование и то,
		как применять все эти концепции для экранов разной ширины.
		Это практически все, что вам когда-либо понадобится для верстки веб-страниц
		с помощью HTML и CSS.
		В следующей главе мы вернемся в мир HTML изучая множество новых элементов,
		которые сильно "порадуют" поисковые системы оптимизацией наших сайтов.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>СЕМАНТИКА HTML</h2>
<div class="chapter">УРОК Nº 12.</div>
<p><em>
    Самый понятный учебник веб-разработки полноценных веб-страниц
</em></p>


<p>
    "Семантика HTML" подразумевает, что вся ваша HTML-разметка должна передавать
		основной смысл вашего контента, а не его внешний вид.
		Мы уже писали семантический HTML код, например, используя <a href="iih02-basic-web-pages.html#structure-vs-presentation">
&lt;strong&gt; вместо &lt;b&gt;</a>), но существует целый набор элементов, созданных с единственной
		целью - добавить больше смысла в общий макет веб-страницы.
    Они называются "элементы секционирования" и выглядят примерно так:
</p>

<figure>
<img class="pic-pages" src="./images/iih12-01-html-sectioning-elements-00c3fd.a9d1b00b.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: элементы &lt;header&gt;, &lt;nav&gt;, &lt;article&gt;, &lt;aside&gt;,
		&lt;figure&gt; и &lt;footer&gt; на типичной веб-странице.
</small></figcaption>
</figure>

<p>
    Использование этих элементов вместо элементов &lt;div&gt; - важный аспект современной
		веб-разработки, так как это облегчает поисковым системам, программам чтения
		с экрана и т.п. идентификацию различных частей вашего сайта.
		Это также помогает вам как разработчику поддерживать сайт организованным,
		что, в свою очередь, облегчает его обслуживание.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-02-semantic-html-ffab7c.f3d6e999.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2: div-"солянка" (несколько серых &lt;div&gt;) и семантическая разметка
		(разноцветные &lt;header&gt;, &lt;article&gt;, &lt;figure&gt;, &lt;footer&gt;)
</small></figcaption>
</figure>

<p>
    В этой главе мы вернемся к простому HTML - без <a href="iih05-css-box-model.html">
		блоковой модели</a>, <a href="iih08-flexbox.html">flexbox</a> или <a href="iih09-advanced-positioning.html">
		схем позиционирования</a>.
		Однако это не значит, что вы не можете применить все правила CSS из предыдущих
		глав к этим новым элементам.
		Считайте, что элементы секционирования - это &lt;div&gt;, только с <em>определенным
		смыслом</em>.
</p>

<div class="title">подготовка<br>setup</div>
<p>
    Нашим примером к этому уроку будет простой нестилизованный HTML-документ.
		Создайте новый <a href="iih01-intro.html#atom">проект Atom</a> под названием
		semantic-html с новым файлом article.html.
		Добавьте в него следующее:
</p><p class="code">
<span class="code-green">&lt;!DOCTYPE html&gt;</span><br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Semantic HTML&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
<br>
&lt;h1&gt;Interneting Is Easy!&lt;/h1&gt;<br>
&lt;ul&gt;<br>
&lt;li&gt;&lt;a href='#'&gt;Home&lt;/li&gt;<br>
&lt;li&gt;&lt;a href='#'&gt;About&lt;/li&gt;<br>
&lt;li&gt;&lt;a href='#'&gt;Blog&lt;/li&gt;<br>
&lt;li&gt;&lt;a href='#'&gt;Sign Up&lt;/li&gt;<br>
&lt;/ul&gt;<br>
<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Предполагается, что &lt;h1&gt; и &lt;ul&gt; - это баннер верхнего уровня
		для нашего сайта, а не основное содержимое веб-страницы.
		Нам никогда раньше не приходилось делать такое различие, но именно об
		этом и пойдет речь на этом уроке.
</p>

<div class="title">обводка документа<br>the document outline</div>

<p>
    Каждый HTML-документ имеет "обводку", с помощью которой поисковые системы и
		программы чтения с экрана видят иерархию содержимого страницы.
		Обводку страницы формируют <a href="iih02-basic-web-pages.html#headings">
		элементы заголовков секций</a> &lt;h1&gt; - &lt;h6&gt;.
		Мы проверим это, добавив фиктивный блог-пост в article.html:
</p>

<p class="code">
<span="code-blue">&lt;h1&gt;</span>Semantic HTML<span="code-blue">&lt;/h1&gt;</span><br>
&lt;p&gt;By Troy McClure. Published January 3rd&lt;/p&gt;<br>
&lt;p&gt;This is an example web page explaining HTML5 semantic markup.&lt;/p&gt;<br>
<br>
&lt;h2&gt;The Document Outline&lt;/h2&gt;<br>
&lt;p&gt;HTML5 includes several “sectioning content” elements that<br>
affect the document outline.&lt;/p&gt;<br>
<br>
&lt;h3&gt;Headers&lt;/h3&gt;<br>
&lt;p&gt;The &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; element is one such sectioning<br>
element.&lt;/p&gt;<br>
<br>
&lt;h3&gt;Footers&lt;/h3&gt;<br>
&lt;p&gt;And so is the &lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt; element.&lt;/p&gt;<br>
<br>
&lt;h2&gt;Inline Semantic HTML&lt;/h2&gt;<br>
&lt;p&gt;The &lt;code>&amp;lt;time&amp;gt;&lt;/code&gt; element is semantic, but it’s not<br>
sectioning content.&lt;/p&gt;<br>
<br>
&lt;p&gt;This fake article was written by somebody at InternetingIsHard.com, which<br>
is a pretty decent place to learn how to become a web developer.&lt;/p&gt;<br>
<br>
&lt;p&gt;&amp;copy; 2017 InternetingIsHard.com&lt;/p&gt;
</p><p>
<a href="https://gsnedders.html5.org/outliner/">
	HTML5 Outliner</a> - это удобный инструмент просмотра обводки документа на странице.
	Пройдите по ссылке и вставьте весь файл article.html в текстовое поле внизу.
	Вы должны увидеть обводку нашего примера, которая в данный момент напоминает
	структуру письменной работы, которую вы учились делать в школе (см. скриншот ниже).
</p>

<figure>
<img class="pic-pages" src="./images/iih12-03-document-outline-heading-elements-576433.641c6025.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: обводка структуры заголовков веб-страниц
</small></figcaption>
</figure>

<p>
    Каждый элемент &lt;h1&gt; создает новую секцию в обводке документа, а все менее
		заметные заголовки, которые следуют за ним, считаются подразделами этого
		заголовка верхнего уровня.
		Например, секция <strong>Semantic HTML</strong> имеет две подсекции: <strong>
		The document outline</strong> [Обводка документа] и <strong>Inline Semantic
		HTML</strong> [Встроенный семантический HTML].
		То же относится к элементам &lt;h2&gt;, &lt;h3&gt; и далее до &lt;h6&gt;.
</p><p>
    Обратите внимание, что фактическое значение уровня заголовка не играет особой
		роли: важно то, больше или меньше он заголовка текущей секции.
		Например, измените заголовки &lt;h3&gt; на &lt;h4&gt; и снова запустите Outliner.
		Поскольку &lt;h4&gt; все равно меньше родительского &lt;h2&gt;, это никак не
		должно повлиять на обводку документа.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-03-document-outline-section-creation-45ee48.47e2f086.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: схема правил, по которым заголовки создают новые секции в обводке
		документа
</small></figcaption>
</figure>

<p>
    Как обводка документа связана с семантическим HTML?
		Заголовки - одни из самых семантических элементов веб-страницы.
		Они играют важную роль в том, как поисковые системы определяют, что является
		важным на вашей веб-странице.
		Кроме того, семантические элементы HTML, о которых мы сейчас расскажем,
		добавляют больше смысла, а иногда даже изменяют стандартное поведение обводки.
</p>

<div class="title">статьи<br>articles</div>
<p>
    Элемент &lt;article&gt; обозначает независимую статью на веб-странице.
		В него следует помещать только тот контент, который можно извлечь из вашей
		страницы и распространить в совершенно другом контексте.
		Например, такое приложение, как <a href="https://flipboard.com">Flipboard</a>,
		должно иметь возможность взять элемент &lt;article&gt; с вашего сайта, отобразить
		его в своем приложении и сделать так, чтобы он был понятен читателям.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-04-html-article-element-82490e.7679f093.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5: элемент &lt;article&gt;, отправленный из вашей страницы на Flipboard,
		поисковики и другие сайты
</small></figcaption>
</figure>

<p>
    Мы можем использовать &lt;article&gt;, чтобы выделить основной
		контент страницы как самостоятельную единицу, например, так:
</p><p class="code">
&lt;article&gt;<br>
&lt;h1>Semantic HTML&lt;/h1&gt;<br>
&lt;p>By Troy McClure. Published January 3rd&lt;/p&gt;<br>
&lt;p>This is an example web page explaining HTML5 semantic markup.&lt;/p&gt;<br>
&lt;!-- ... --&gt;<br>
&lt;p>This fake article was written by somebody at InternetingIsHard.com, which<br>
     is a pretty decent place to learn how to become a web developer.&lt;/p&gt;<br>
&lt;/article&gt;<br>
<br>
&lt;p>&amp;copy; 2017 InternetingIsHard.com&lt;/p&gt;
</p><p>
    Обратите внимание, мы оставили уведомление об авторских правах <em>за
	  пределами</em> элемента &lt;article&gt;, так как это футер для всего сайта,
		а не конкретно для нашей статьи.
		По сути, элементы &lt;article&gt; это мини-веб-страницы в HTML-документе.
		У них есть свои заголовки, футеры и обводка документа, полностью изолированные
		от остальной части сайта.
</p>

<div class="title-under">ИСПОЛЬЗОВАНИЕ НЕСКОЛЬКИХ ARTICLE-ЭЛЕМЕНТОВ<br>using multiple article elements</div>
<p>
    Для таких вещей, как блог-посты, газетные статьи или веб-страницы, посвященные
		одной теме, часто используется только один элемент &lt;article&gt;.
		Однако вполне допустимо иметь более одного &lt;article&gt; на странице.
		Хороший пример - страница с множеством блог-постов.
		Каждый из них может быть обернут в отдельный набор тегов &lt;article&gt;
		(вам не нужно добавлять это в страницу article.html нашего примера):
</p><p class="code">
&lt;article&gt;<br>
&lt;h1&gt;First Post&lt;/h1&gt;<br>
&lt;p>Some content&lt;/p&gt;<br>
&lt;/article&gt;<br>
&lt;article&gt;<br>
&lt;h1&gt;Second Post&lt;/h1&gt;<br>
&lt;p>Some content&lt;/p&gt;<br>
&lt;h1&gt;Subscription&lt;/h1&gt;<br>
&lt;p>Some details&lt;/p&gt;<br>
&lt;/article&gt;<br>
&lt;article&gt;<br>
&lt;h1&gt;Last Post&lt;/h1&gt;<br>
&lt;p&gt;Final bit of content&lt;/p&gt;<br>
&lt;/article&gt;
</p><p>
    Это говорит всем, кто смотрит на нашу страницу, о том, что здесь есть три
		разные статьи, которые можно разместить в интернете*.
		Думайте об этом как о способе объединить несколько HTML-файлов в один документ,
		не запутав поисковые системы, браузеры и другие машины, которые пытаются
		разобрать наш контент.
</p><p>
	  Сравните это с кучей общих элементов &lt;div&gt; с произвольными именами классов,
		и вы начнете понимать, как семантический HTML упрощает навигацию по Сети.
</p><p class="notetran">
    * - "разместить в интернете". В оригинале: can be syndicated.
		У этого слова <a href="https://www.multitran.com/m.exe?l1=1&l2=2&s=syndicated">
		огромное множество переводов</a>.
		Наиболее подходящие переводы для данного случая: "синдицировать; передавать
		информацию в агентство печати; публиковать сразу в нескольких газетах;
		покупать статьи для их одновременной публикации в различных изданиях."
</p>

<div class="title">секции<br>sections</div>
<p>
    Элемент &lt;section&gt; похож на &lt;article&gt;, только он не должен иметь
		смысла вне контекста документа.
		То есть приложение вроде Flipboard не будет пытаться вытащить все &lt;section&gt;'s
		из вашей страницы и представить их как независимые части контента.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-05-html-section-element-92a4d1.03315e33.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: элемент &lt;section&gt; не может быть извлечен из страницы
</small></figcaption>
</figure>

<p>
    Представьте &lt;section&gt; как <em>явный</em> способ определения секций в
		обводке документа.
		Зачем нам это нужно, вместо того чтобы позволить уровням заголовков сделать
		это за нас?
		Часто для верстки секций нужен контейнер, и тогда имеет смысл использовать
		более описательный элемент &lt;section&gt;, а не общий &lt;div&gt;.
</p><p>
    Давайте выделим две секции в нашем файле article.html:
</p><p class="code">
&lt;section&gt;	<span="code-grey">&lt;!-- Добавьте это --&gt;</span><br>
&lt;h2&gt;The Document Outline&lt;/h2&gt;<br>
&lt;p&gt;HTML5 includes several “sectioning content” elements that<br>
affect the document outline.&lt;/p&gt;<br>
<br>
&lt;h3&gt;Headers&lt;/h3&gt;<br>
&lt;p&gt;The &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; element is one such sectioning<br>
element.&lt;/p&gt;<br>
<br>
&lt;h3&gt;Footers&lt;/h3&gt;<br>
&lt;p&gt;And so is the &lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt; element.&lt;/p&gt;<br>
&lt;/section&gt;	<span="code-grey">&lt;!-- Добавьте это тоже--&gt;</span><br>
<br>
&lt;section&gt;	<span="code-grey">&lt;!-- Добавьте и это тоже --&gt;</span><br>
&lt;h2&gt;Inline Semantic HTML&lt;/h2&gt;<br>
&lt;p&gt;The &lt;code>&amp;lt;time&amp;gt;&lt;/code&gt; element is semantic, but it’s not<br>
sectioning content.&lt;/p&gt;<br>
&lt;/section&gt;	<span="code-grey">&lt;!-- Не забудьте добавить и это --&gt;</span>
</p><p>
    Это позволяет сохранить обводку документа в неизменном виде и придать ей
		дополнительную смысловую структуру, а также сделать отличный зацеп для любых
		CSS-стилей, которые мы захотим применить (например, цвет фона для определенной
		секции).
</p>

<div class="title-under">&LT;SECTION&GT; И ОБВОДКА ДОКУМЕНТА<br>
    &LT;SECTION&GT; and the document outline
</div>
<p>
    Предыдущее изменение также имеет интересный побочный эффект для неявного
		поведения секций в наших заголовках.
		Посмотрите, что произойдет, если мы опустим второй &lt;h2&gt; на более низкий
		уровень заголовка:
</p><p class="code">
&lt;section&gt;	<br>
&lt;h6&gt;Inline Semantic HTML&lt;/h6&gt; <span="code-grey">&lt;!-- Измените здесь уровень заголовка --&gt;</span><br>
&lt;p&gt;The &lt;code>&amp;lt;time&amp;gt;&lt;/code&gt; element is semantic, but it’s not<br>
sectioning content.&lt;/p&gt;<br>
&lt;/section&gt;
</p><p>
    Строка &lt;h6&gt; находится ниже, чем предшествующая ей &lt;h3&gt;, поэтому
		можно ожидать, что она станет частью секции <strong>Footer</strong>.
		Но не тут-то было: обводка документа остается точно такой же, как и раньше.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-06-sections-and-document-outline-614f12.f2860cf6.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: ожидаемые и фактические обводки, созданные с помощью схемы обводки
		документа HTML5, в сравнении с реальными веб-браузерами
</small></figcaption>
</figure>

<p>
    Добавляя эти элементы &lt;section&gt;, мы говорим обводке документа, что она
		должна определяться структурой вложенности элементов &lt;section&gt;, а не
		уровнями заголовков.
		В основном это означает, что каждый &lt;section&gt; может иметь свой собственный
		набор заголовков &lt;h1&gt; - &lt;h6&gt;, не зависящих от остальной части страницы.
</p><p>
    Однако не следует использовать элемент &lt;section&gt; для манипулирования
		обводкой документа таким образом, поскольку браузеры, программы чтения с
		экрана и некоторые поисковики неправильно интерпретируют влияние &lt;section&gt;
		на обводку документа.
		Вместо этого всегда определяйте обводку страницы через уровни заголовков,
		используя &lt;section&gt; только в качестве замены контейнеров &lt;div&gt;,
		когда это необходимо.
</p><p>
    Также обратите внимание, что каждый элемент &lt;section&gt; должен содержать
		хотя бы один заголовок, иначе он добавит в обводку документа "секцию без названия".
		Для примера попробуем обновить article.html как показано ниже, а затем снова
		прогоним его через HTML5 Outliner:
</p><p class="code">
&lt;h2>Inline Semantic HTML&lt;/h2><br>
&lt;section><br>
<span="code-grey">&lt;!-- Это будет "Untitled Section" [Секция без названия] --&gt;</span><br>
&lt;p>The &lt;code>&amp;lt;time&amp;gt;</code> element is semantic, but it’s not<br>
  sectioning content.&lt;/p><br>
&lt;/section>
</p><p>
    Это создает новую секцию, но поскольку с ней не связан заголовок, обводка
		документа не знает, как ее назвать.
		При использовании элементов &lt;section&gt; подобного следует избегать.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-07-untitled-section-in-document-outline-b511bc.83afc48e.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: обводка с секцией без названия после добавления нового
		элемента &lt;section&gt;
</small></figcaption>
</figure>

<p>
    Согласно спецификации HTML5, &lt;section&gt; - это довольно общий элемент.
		Это, а также тот факт, что браузеры и программы чтения с экрана не могут
		правильно интерпретировать его роль в обводке документа, затрудняет понимание
		того, когда и как его использовать.
		Советуем использовать &lt;section&gt; скорее как описательную обертку &lt;div&gt;
		для неявно определенных секций вашей страницы.
		Не используйте его для самостоятельного контента (для этого есть &lt;article&gt;)
		или когда он нужен <a href="#divs-for-layout"><em>исключительно</em> для
		верстки</a>.
</p>

<div class="title">элементы навигации<br>nav elements</div>
<p>
    Элемент &lt;nav&gt; позволяет разметить различные навигационные секции вашего
		сайта.
		Это касается основной навигации сайта, ссылок на связанные страницы в боковой
		панели, таблиц с контентом и практически любых групп ссылок.
		Например, в элемент &lt;nav&gt; следует поместить навигационное меню всего сайта:
</p><p class="code">
&lt;h1>Interneting Is Easy!&lt;/h1><br>
&lt;nav> <span="code-grey">&lt;!-- Добавьте это --&gt;</span><br>
&lt;ul><br>
&lt;li>&lt;a href='#'>Home&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>About&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>Blog&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>Sign Up&lt;/a>&lt;/li><br>
&lt;/ul><br>
&lt;/nav> <span="code-grey">&lt;!-- И это добавьте! --&gt;</span>
</p><p>
    Это отличная семантическая информация для поисковых систем.
		Она помогает им быстро определить структуру всего вашего сайта, облегчая
		поиск других страниц.
		Как мы увидим в разделе <a href="#asides">Элементы &lt;aside&gt;</a>, в одну
		страницу можно включить несколько элементов &lt;nav&gt; при наличии разных
		наборов связанных ссылок.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-08-html-nav-element-d1e716.3664d236.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: элементы &lt;nav&gt;, группирующие навигационные ссылки в шапке,
		боковой панели и футере веб-страницы
</small></figcaption>
</figure>

<div class="title" id="headers">хидеры<br>headers</div>
<p>
    &lt;header&gt; это новый элемент семантической разметки, который не
		следует путать с заголовками (элементы &lt;h1&gt;-&lt;h6&gt;).
		Он обозначает вводный контент для секции, статьи или всей веб-страницы.
	  "Вводным контентом" может быть что угодно - от логотипа вашей компании до
		навигационных подсказок или информации об авторе.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-09-html-header-element-7b4e01.d7494385.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10: отдельные элементы &lt;header&gt; для всей веб-страницы в сравнении
		с элементом &lt;article&gt;
</small></figcaption>
</figure>

<p>
    Название/логотип и основную навигацию сайта лучше всего заключать в &lt;header&gt;,
		поэтому давайте добавим его в наш пример проекта:
</p><p class="code">
&lt;header&gt;<br>
&lt;h1>Interneting Is Easy!&lt;/h1><br>
&lt;nav&gt;<br>
&lt;ul><br>
&lt;li>&lt;a href='#'>Home&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>About&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>Blog&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>Sign Up&lt;/a>&lt;/li><br>
&lt;/ul><br>
&lt;/nav><br>
&lt;/header&gt;
</p><p>
    Заголовки связаны только с ближайшим элементом секции - как правило,
		элементом &lt;body&gt;, &lt;section&gt; или &lt;article&gt;.
		Это означает, что вы можете использовать несколько элементов &lt;header&gt;
		для добавления вводного контента в разные части документа.
		Например, название, автор и дата публикации нашей &lt;article&gt; - вполне
		подходящий кандидат для другого &lt;header&gt;:
</p><p class="code">
&lt;article&gt;<br>
&lt;header&gt;<br>
<span="code-blue">&lt;h1&gt;</span>Semantic HTML<span="code-blue">&lt;/h1&gt;</span><br>
&lt;p&gt;By Troy McClure. Published January 3rd&lt;/p&gt;<br>
&lt;/header&gt;<br>
<br>
&lt;p&gt;This is an example web page explaining HTML5 semantic markup.&lt;/p&gt;<br>
<span="code-grey">&lt;!-- ... --&gt;
</p><p>
    Без этого &lt;header&gt; поисковые системы и программы чтения с экрана не узнают,
		что первый &lt;p&gt; отделен от основного контента статьи.
		Как и &lt;section&gt;, он также служит удобным CSS-крючком, поскольку заголовок
		и информация об авторе записи в блоге часто оформляются иначе, чем остальная
		часть статьи.
		Повторимся, &lt;header&gt; можно рассматривать как более семантическую альтернативу
		контейнеру &lt;div&gt;.
</p>

<div class="title">футеры<br>footers</div>
<p>
    Концептуально футеры - это то же самое, что и хидеры, за исключением того,
		что они обычно располагаются в конце статьи/сайта, а не в начале.
		Обычно они используются для уведомления об авторских правах, навигации по футеру
		и биографий авторов в конце записей блога.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-10-html-footer-element-0c927a.ea3eb425.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: элемент &lt;footer&gt; для всей веб-страницы и для элемента </article>
</small></figcaption>
</figure>

<p>
    Футеры ведут себя так же, как и хидеры, - они тоже связаны с ближайшим
		элементом секции.
		Поэтому мы можем использовать их для уведомления об copyright страницы и
		информации об авторе внутри &lt;article&gt;.
		Добавьте следующие два элемента футера на нашу страницу article.html:
</p><p class="code">
&lt;article&gt;<br>
&lt;header&gt;<br>
<span="code-blue">&lt;h1&gt;</span>Semantic HTML<span="code-blue">&lt;/h1&gt;</span><br>
&lt;p&gt;By Troy McClure. Published January 3rd&lt;/p&gt;<br>
&lt;/header&gt;<br>
<br>
&lt;p&gt;This is an example web page explaining HTML5 semantic markup.&lt;/p&gt;<br>
<span="code-grey">&lt;!-- ... --&gt;<br>
<br>
&lt;footer> &lt;!-- Добавьте это --><br>
&lt;p&gt;This fake article was written by somebody at InternetingIsHard.com,<br>
which is a pretty decent place to learn how to become a web developer. This<br>
footer is only for the containing &lt;code>&amp;lt;article&amp;gt;&lt;/code> element.&lt;/p><br>
&lt;/footer>        &lt;!-- Добавьте это --><br>
<br>
&lt;/article&gt;<br>
<br>
&lt;footer>           &lt;!-- И это тоже --><br>
&lt;p>&amp;copy; 2017 InternetingIsHard.com&lt;/p><br>
&lt;/footer>          &lt;!-- Не забудьте закрыть! --><br>
<br>
&lt;/body><br>
&lt;/html>
</p><p>
    Элемент &lt;footer&gt; внутри &lt;article&gt; предназначен только для контента этой статьи,
		что вполне логично, поскольку он содержит биографию автора.
		Второй футер, в свою очередь, связан со всей страницей.
</p>

<div class="title" id="asides">отступление<br>aside</div>
<p>
    Хидеры и футеры - это способ добавить дополнительную информацию
		в статью, но иногда мы хотим <em>удалить</em> информацию из статьи.
		Например, спонсируемая статья в блоге может содержать рекламу компании-спонсора;
		однако мы, вероятно, не захотим делать ее частью текста статьи.
		Именно для этого предназначен элемент &lt;aside&gt; - "отступление".
</p>

<figure>
<img class="pic-pages" src="./images/iih12-11-html-aside-element-ce120b.d784615b.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 12: элемент &lt;aside&gt; внутри для элемента &lt;article&gt; и в
		боковой панели всего сайта
</small></figcaption>
</figure>

<p>
    Давайте добавим фейковое рекламное объявление в файл article.html, прямо
		под заголовком статьи:
</p><p class="code">
&lt;article&gt;<br>
&lt;header&gt;<br>
<span="code-blue">&lt;h1&gt;</span>Semantic HTML<span="code-blue">&lt;/h1&gt;</span><br>
&lt;p&gt;By Troy McClure. Published January 3rd&lt;/p&gt;<br>
&lt;/header&gt;<br>
&lt;!-- Фейковое объявление [fake advertisement]! --><br>
&lt;aside class='advert'><br>
&lt;img src='some-advert-image.png'/><br>
&lt;/aside><br>
<br>
&lt;p&gt;This is an example web page explaining HTML5 semantic markup.&lt;/p&gt;<br>
</p><p>
    Несмотря на то что изображение находится внутри элемента &lt;article&gt;, роботы
		понимают, что оно имеет лишь косвенное отношение к контенту статьи.
		Если она выглядит иначе, чем остальная часть статьи, скорее всего, это отступление.
    Помимо рекламы, &lt;aside&gt; также подходит для выделения определений,
		статистики или цитат.
</p><p>
    Когда &lt;aside&gt; используется <em>за пределами</em> &lt;article&gt;, он
		ассоциируется со страницей в целом (так же, как &lt;header&gt; и &lt;footer&gt;).
		Это делает его хорошим выбором для разметки боковой панели всего сайта.
		Под закрывающим тегом &lt;/article&gt;, перед вторым &lt;footer&gt; добавьте
		следующее:
</p><p class="code">
&lt;aside class='sidebar'&gt;<br>
&lt;h2>Sidebar&lt;/h2&gt;<br>
&lt;p>Some sidebar content&lt;/p&gt;<br>
&lt;nav&gt;<br>
&lt;h3>HTML &amp;amp; CSS Tutorial&lt;/h3&gt;<br>
&lt;ul><br>
&lt;li>&lt;a href='#'>Introduction&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>Basic Web Pages&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>etc...&lt;/a>&lt;/li><br>
&lt;/ul><br>
&lt;/nav><br>
&lt;nav&gt;<br>
&lt;h3>JavaScript Tutorial&lt;/h3&gt;<br>
&lt;ul><br>
&lt;li>&lt;a href='#'>Introduction&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>Hello, JavaScript&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>etc...&lt;/a>&lt;/li><br>
&lt;/ul><br>
&lt;/nav&gt;<br>
&lt;/aside&gt;
</p><p>
    Обратите внимание на атрибуты class в обоих фрагментах.
		Если бы на этом уроке мы фокусировались на CSS, мы могли бы стилизовать наши
		элементы &lt;aside&gt; точно так же, как и все &lt;div&gt;, с которыми мы
		работали на протяжении всего этого учебника.
		Что приводит нас к...
</p>

<div class="title" id="divs-for-layout">divs для верстки<br>divs for layout</div>
<p>
    Используйте семантический HTML всегда, когда это возможно, поскольку он
		помогает машинам понять структуру вашего контента и дает вам стандартный
		словарь для организации веб-страниц.
		Однако иногда требуется элемент-контейнер, но не имеет смысла использовать ни
		один из только что рассмотренных семантических элементов HTML.
		Нет ничего плохого в том, чтобы использовать обычный &lt;div&gt; чисто
		для верстки.
</p><p>
    Например, если мы хотим отцентрировать страницу с помощью знакомой <a href="iih05-css-box-model.html#aligning-boxes">
		техники auto-margin</a>, нам придется поместить всю страницу в контейнер.
		Это полностью соотносится с идеей "внешнего вида", поэтому &lt;div&gt; будет наилучшим вариантом:
</p><p class="code">
&lt;body&gt;<br>
&lt;div class='page'&gt; <span class="code-grey">&lt;!-- Начало контейнера div --&gt;</span><br>
&lt;header&gt;<br>
&lt;h1>Interneting Is Easy!&lt;/h1&gt;<br>
&lt;nav&gt;<br>
&lt;ul><br>
&lt;li>&lt;a href='#'>Home&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>About&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>Blog&lt;/a>&lt;/li><br>
&lt;li>&lt;a href='#'>Sign Up&lt;/a>&lt;/li><br>
&lt;/ul><br>
&lt;/nav><br>
&lt;/header><br>
<span class="code-grey">&lt;!-- ... --&gt;</span><br>
&lt;footer&gt;<br>
&lt;p>&amp;copy; 2017 InternetingIsHard.com&lt;/p&gt;<br>
&lt;/footer&gt;<br>
&lt;/div&gt; <span class="code-grey">&lt;!-- Конец контейнера div --&gt;</span><br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Это особенно актуально для <a href="iih08-flexbox.html">flexbox</a>, поскольку для правильной группировки
		элементов flex требуется много &lt;div&gt;.
		Иногда для этих flex-элементов подходит &lt;section&gt; или &lt;nav&gt;,
		но довольно часто в flexbox-макетах встречаются элементы &lt;div&gt;.
</p><p>
    Суть в том, что не стоит использовать семантические элементы только ради того,
		чтобы их использовать.
		Неуместное использование хуже, чем полное отсутствие, поэтому, если сомневаетесь,
		смело используйте &lt;div&gt;.
</p>

<div class="title">даты и время<br>dates and times</div>
<p>
    Для людей даты и время существуют в разных формах.
		Вы можете назвать 3 января 2017 года "1/3/2017", "3 января" или в зависимости
		от даты, даже "вчера".
		Парсинг такого неоднозначного естественного языка для машин затруднителен и
		чреват ошибками, поэтому на помощь приходит &lt;time&gt;.
</p><p>
    Элемент &lt;time&gt; представляет либо время суток, либо календарную дату.
		Предоставление машиночитаемой даты позволяет браузерам автоматически привязывать
		ее к календарям пользователей и помогает поисковикам легко определять конкретные
		даты.
		Простой поиск в Google покажет вам эффект от включения элемента &lt;time&gt;
		на вашей странице:
</p>

<figure>
<img class="pic-pages" src="./images/iih12-12-time-element-in-google-search-results-5bba38.c0e38e7a.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 13: результаты поиска Google с выделенной датой публикации
</small></figcaption>
</figure>

<p>
    Давайте сделаем ясную дату публикации нашей статьи, обернув ее в теги &lt;time&gt;:
</p></p><p class="code">
&lt;article&gt;<br>
&lt;header&gt;<br>
&lt;h1>Semantic HTML&lt;/h1><br>
&lt;p>By Troy McClure. Published &lt;time datetime='2017-1-3'>January<br>
3rd&lt;/time>&lt;/p><br>
&lt;/header><br>
<span class="code-grey">&lt;!-- ... --&gt;</span>
</p><p>
    Машиночитаемая дата определяется атрибутом datetime.
		Формат даты легко запомнить: от самого большого периода времени к самому
		маленькому: год, месяц, день (дата).
		Обратите внимание, что даже если год не включен в читаемый человеком текст,
		это говорит поисковым системам, что наша статья была опубликована в 2017 году.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-13-datetime-format-d0c825.fe1b3df6.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 14: год, месяц, дата, время и часовой пояс в формате элемента &lt;time&gt;
</small></figcaption>
</figure>

<p>
    В datetime также можно включать время и часовые пояса.
		Если бы мы хотели добавить к дате публикации время 3:00 вечера по тихоокеанскому
		времени, мы бы использовали следующее:
</p><p class="code">
&lt;time datetime='2017-1-3 15:00-0800'>January 3rd&lt;/time>
</p><p>
    Само время указывается в 24-часовом формате, а -0800 - это смещение часового
		пояса относительно GMT* (в данном случае -0800 означает PST - тихоокеанское
		стандартное время**).
</p><p class="notetran">
    * - GMT - Greenwich Mean Time - среднее время по Гринвичу.<br>
		* - PST - Pacific Standard Time - тихоокеанское стандартное
		время.
</p>

<div class="title">адреса<br>address</div>
<p>
    Элемент &lt;address&gt; похож на &lt;time&gt; тем, что он не имеет отношения к общей
		структуре документа, а скорее украшает родительский элемент &lt;article&gt; или
&lt;body&gt; некоторыми метаданными. Он определяет контактную информацию автора
	  статьи или веб-страницы.
&lt;address&gt; <em>не следует</em> использовать для обычных физических адресов.
</p><p>
    Например, мы хотим добавить адрес электронной почты автора в футер нашей статьи:
</p>

<p class="code">
&lt;footer><br>
&lt;p>This fake article was written by somebody at InternetingIsHard.com, which<br>
     is a pretty decent place to learn how to become a web developer. This footer<br>
     is only for the containing &lt;code>&amp;lt;article&amp;gt;&lt;/code> element.&lt;/p><br>
&lt;address><br>
    Please contact &lt;a href='mailto:troymcclure@example.com'>Troy<br>
    McClure&lt;/a&gt; for questions about this article.<br>
&lt;/address><br>
&lt;/footer>
</p><p>
    По умолчанию он будет оформлен так же, как &lt;em&gt;, но это легко изменить
		простым CSS-правилом.
		Кстати вы заметили href-ссылку для электронной почты?
		Подробности на сайте <a href="https://developer.mozilla.org/ru/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks">
		Mozilla Developer Network</a>.
</p>

<div class="title">иллюстрации и подписи<br>figures and captions</div>
<p>
    Последними (но, конечно, не по значимости), являются элементы &lt;figure&gt;
		и &lt;figcaption&gt;.
		Первый это "рисунок", например, диаграмма, иллюстрация или даже фрагмент кода.
		А опциональная &lt;figcaption&gt; это подпись, связанная с родительским элементом
&lt;figure&gt;.
</p><p>
    Чаще всего они используются для добавления видимых описаний к элементам &lt;img/&gt;
		в статье, например, так:
</p><p class="code">
&lt;section><br>
&lt;h2>The Document Outline&lt;/h2><br>
&lt;p>HTML5 includes several “sectioning content” elements that<br>
affect the document outline.&lt;/p><br>
<br>
&lt;figure><br>
&lt;img src='semantic-elements.png'<br>
alt='Diagram showing &lt;article>, &lt;section>, and &lt;nav> elements'/><br>
&lt;figcaption>New HTML5 semantic elements&lt;/figcaption><br>
&lt;/figure><br>
<span class="code-grey">&lt;!-- ... --></span>
</p><p>
<a href="iih03-links-and-images.html#text-alternatives">
		Атрибут alt</a> тесно связан с элементом &lt;figcaption&gt;.
		Атрибут alt должен служить текстовой <em>заменой</em> изображения, а &lt;figcaption&gt; -
		это вспомогательное <em>описание</em>, отображаемое либо с изображением, либо с его
		текстовым эквивалентом.
</p><p>
    Используя &lt;figcaption&gt; вышеуказанным образом можно смело
		опустить атрибут alt картинки без ущерба для SEO.
		В зависимости от того, с какими картинками вы работаете, может оказаться
		более удобным (и менее избыточным) иметь видимые &lt;figcaption&gt;, которые
		описывают их, в отличие от невидимых атрибутов alt.
</p><p>

</p>

<div class="title">особенности css/legacy<br>css/legacy considerations</div>
<p>
    И наконец, небольшое замечание по поводу устаревших браузеров.
		Вышеперечисленные семантические элементы HTML появились в HTML5.
		Все современные браузеры распознают их без дополнительной работы, но иногда в
		глобальных таблицах CSS можно увидеть что-то вроде:
</p><p class="code">
<span class="code-strong">section, article, aside, footer, header, nav</span> {<br>
<span class="code-green">display</span>: block;<br>
}
</p><p>
    Это заставляет новые семантические элементы вести себя в старых браузерах
		как элементы &lt;div&gt; (являющимися <a href="iih05-css-box-model.html#block-and-inline-elements">
		блоковыми блоками</a> а не строчными).
</p>


<div class="title">РЕЗЮМЕ</div>
<p>
    Определение графических стилей с помощью CSS - это то, как мы передаем структуру
		веб-страницы людям.
		Размечая ее с помощью &lt;header&gt;, &lt;article&gt;, &lt;figure&gt; и других
		элементов &lt;section&gt; HTML, мы можем передать эти визуальные стили и машинам.
</p>

<figure>
<img class="pic-pages" src="./images/iih12-14-semantic-html-ffab7c.f3d6e999.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 15: неопределенная структура (серые элементы &lt;div&gt;) в сравнении
		с идентифицируемыми секциями (&lt;header&gt;, &lt;article&gt;, &lt;figure&gt; и &lt;footer&gt;)
</small></figcaption>
</figure>

<p>
    Чтобы понять, почему это важно, представим себе машины, читающие наш контент.
		До появления семантического HTML разработчики использовали кучу элементов &lt;div&gt;
		с различными и несколько произвольными именами классов, определяющими структуру
		страницы.
		Например, все следующие элементы являются логическими именами для заголовка сайта:
</p><p class="code">
&lt;div class='main-menu'><br>
&lt;div class='top-nav'><br>
&lt;div class='top-banner'><br>
&lt;div class='header'>
</p><p>
    Раньше машины должны были понимать все вышеперечисленные &lt;div&gt; и
		многое другое.
		Новые семантические элементы HTML из этого урока - это как бы стандартизированные
		версии названий этих классов.
		Теперь они могут просто искать элемент &lt;header&gt;.
		Мы по-прежнему можем добавлять к нему любые имена классов для стилизации, но
		поисковики теперь имеют предсказуемый способ идентификации заголовков на всех
		HTML5-сайтах в Интернете.
</p><p>
    Семантические элементы, описанные выше, для современных веб-сайтов являются
		оптимальными, но они едва ли исчерпывают все возможности, которые можнг придать
		веб-страницам.
		Вот только для начала:
</p>
<ul>
<li><a href="http://schema.org/docs/gs.html">Schema.org microdata</a> позволяют
    изменять внешний вид вашего сайта в результатах поисковых систем.</li>
<li><a href="https://dev.twitter.com/cards/getting-started">Twitter cards</a> определяют,
	  как ваша веб-страница будет отображаться в твитах.</li>
<li><a href="https://developers.facebook.com/docs/sharing/webmasters#markup">
	  Open Graph metadata</a> изменяют способы распространения вашего контента в
		Facebook.</li>
</ul><p>
    Все эти аспекты относятся к области технического SEO, поэтому мы оставим их
		изучение на ваше усмотрение.
		На следующем уроке мы снова переключимся на изучение еще одного немаловажного
		компонента веб-сайтов (особенно электронной коммерции) - формами.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>ФОРМЫ</h2>
<div class="chapter">УРОК Nº 13.</div>
<p><em>
    Самый понятный учебник веб-разработки для получения пользовательских вводных
</em></p>


<p>
    Элементы HTML-форм позволяют собирать данные от посетителей вашего сайта.
		Списки рассылки, контактные формы и комментарии в блогах - обычные примеры
		для небольших сайтов, но в организациях, которые полагаются на свой сайт для
		получения прибыли, формы священны и почитаемы.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-01-html-form-elements-939709.b6e2f779.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: примеры ввода текста, текстовых полей, радиокнопок, чекбоксов
		и других элементов HTML-форм
</small></figcaption>
</figure>

<p>
    Формы - это "денежные страницы".
		С их помощью сайты электронной коммерции продают свои товары, SaaS-компании*
		собирают оплату за свои услуги, а некоммерческие группы собирают деньги
		в Интернете.
		Многие компании оценивают успех своего сайта по эффективности его форм,
		потому что они отвечают на такие вопросы, как "сколько лидов наш сайт
		отправил в отдел продаж?" и "сколько людей подписались на наш продукт на
		прошлой неделе?".
		Зачастую формы подвергаются бесконечным A/B-тестированиям и оптимизации.
</p><p class="notetran">
    * - SaaS (Software as a service) - программное обеспечение как услуга.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-02-form-frontend-and-backend-2a0f80.f3e81924.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2:  элементы фронтэнд-формы, отправляющие входные данные на бэкенд-сервер
		для обработки
</small></figcaption>
</figure>

<p>
    У функциональной HTML-формы есть два аспекта: фронтенд (пользовательский интерфейс)
		и бэкенд (внутренний сервер).
		Первый - это <em>внешний вид</em> формы (определяемый HTML и CSS), а второй -
		это код, который ее обрабатывает (сохраняет данные в БД, отправляет
		e-mail и т. д.).
		Ниже мы полностью сосредоточимся на фронтенде.
		Обработку форм (бэкенд) оставим для следующего учебника.
</p>

<div class="title">подготовка<br>setup</div>
<p>
    К сожалению, невозможно обойти тот факт, что стилизация форм - это <em>сложно</em>.
		Всегда полезно иметь макет страницы, которую вы хотите создать, прежде чем
		начать ее кодировать, и это особенно актуально для форм.
		Итак, вот пример, который мы будем создавать в этой главе:
</p>

<figure>
<img class="pic-pages" src="./images/iih13-03-responsive-form-mockup-963e65.0b2938bc.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: макеты веб-страницs для смартфонов и ноутбуков/ПК с несколькими
		элементами форм
</small></figcaption>
</figure>

<p>
    Как видите, это форма подачи заявок на участие в конференции для фиктивного докладчика.
		В ней присутствует довольно хороший набор элементов HTML-форм: различные типы
		текстовых полей, группа радиокнопок, выпадающее меню, флажок и кнопка отправки.
</p><p>
    Создайте новый <a href="iih01-intro.html#atom">Atom-проект</a> под названием
		forms и поместите в него новый HTML-файл под названием speaker-submission.html.
		Для начала добавим разметку для заголовка.
		(Эй, между прочим, здесь тоже есть <a href="iih12-semantic-html.html#headers">
		семантический HTML</a>!)
</p><p class="code">
&lt;!DOCTYPE html&gt;<br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Speaker Submission&lt;/title&gt;<br>
&lt;link rel='stylesheet' href='styles.css'><br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
&lt;header class='speaker-form-header'><br>
&lt;h1&gt;Speaker Submission&lt;/h1&gt;<br>
&lt;p&gt;&lt;em&gt;Want to speak at our fake conference? Fill out<br>
this form.&lt;/em>&lt;/p&gt;<br>
&lt;/header&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Затем создайте файл styles.css и добавьте в него следующий CSS.
		Здесь используется простая техника <a href="iih08-flexbox.html">flexbox</a> для
		центрирования заголовка (и формы) независимо от ширины окна браузера:
</p><p class="code">
<span class="code-strong">*</span> {<br>
<span class="code-green">margin</span>: 0;<br>
<span class="code-green">padding</span>: 0;<br>
<span class="code-green">box-sizing</span>: border-box;<br>
}<br>
<br>
<span class="code-strong">body</span> {<br>
<span class="code-green">color</span>: #5D6063;<br>
<span class="code-green">background-color</span>: #EAEDF0;<br>
<span class="code-green">font-family</span>: "Helvetica", "Arial", sans-serif;<br>
<span class="code-green">font-size</span>: 16px;<br>
<span class="code-green">line-height</span>: 1.3;<br>
<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">flex-direction</span>: column;<br>
<span class="code-green">align-items</span>: center;<br>
}<br>
<br>
<span class="code-blue">.speaker-form-header</span> {<br>
<span class="code-green">text-align</span>: center;<br>
<span class="code-green">background-color</span>: #F6F7F8;<br>
<span class="code-green">border</span>: 1px solid #D6D9DC;<br>
<span class="code-green">border-radius</span>: 3px;<br>

<br>
<span class="code-green">width</span>: 80%;<br>
<span class="code-green">margin</span>: 40px 0;<br>
<span class="code-green">padding</span>: 50px;<br>
}<br>
<br>
<span class="code-blue">.speaker-form-header</span> <span class="code-strong">h1</span> {<br>
<span class="code-green">font-size</span>: 30px;<br>
<span class="code-green">margin-bottom</span>: 20px;<br>
}
</p><p>
    Обратите внимание, что мы придерживаемся подхода <a href="iih10-responsive-design.html#mobile-first-developement">
		mobile-first development</a> (см. урок <em>Адаптивный дизайн</em>).
		Эти базовые правила CSS дают нам мобильный макет и служат основой макета для
		ноутбуков/ПК.
		Медиавыражение макета с фиксированной шириной (для ноутбуков/ПК) мы создадим
		чуть ниже.
</p>

<div class="title">формы<br>html forms</div>
<p>
    Переходим к формам!
		Каждую HTML-форму открывает элемент с подходящим названием - &lt;form&gt;.
		Он поддерживает <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/form">
		множество атрибутов</a>, но самые важные из них - action и method.
		Добавим пустую форму в наш HTML-документ, прямо под &lt;header&gt;:
</p><p class="code">
&lt;form action='' method='get' class='speaker-form'><br>
&lt;/form>
</p><p>
    Атрибут action определяет URL, который обрабатывает форму.
		Именно сюда отправляются данные, собранные формой, когда пользователь нажимает
		кнопку <strong>Submit</strong>.
		Обычно это особый URL, определенный вашим веб-сервером, который знает, как
		обрабатывать данные.
		Распространенные технологии бэкенда для обработки форм это <a href="https://nodejs.org/en/">
		Node.js</a>, <a href="https://www.php.net">PHP</a> и <a href="http://rubyonrails.org">
		Ruby on Rails</a>, но на этом уроке мы сосредоточимся на фронтенде.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-04-form-action-attribute-68258a.f363aa5f.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: &lt;form&gt;-атрибуты действия [action] и метода [method],
		отправляемые на бэкенд-сервер
</small></figcaption>
</figure>

<p>
    Атрибут method может быть либо <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/POST">
		post</a>, либо <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/GET">
		get</a>.
		Оба они определяют, как форма отправляется на внутренний сервер.
		Это во многом зависит от того, как ваш веб-сервер хочет обрабатывать форму,
		но общее правило гласит: используйте post, когда вы <em>изменяете</em> данные
		на сервере.
		А get оставьте для тех случаев, когда вы только <em>получаете</em> данные.
</p><p>
    Оставляя атрибут action пустым, мы указываем форме, что она должна отправляться по тому же URL. В сочетании с методом get это позволит нам просмотреть содержимое формы.
</p>

<div class="title-under">СТИЛИЗАЦИЯ ФОРМ<br>styling forms</div>
<p>
    Конечно, сейчас перед нами пустая форма, но это не значит, что мы не можем
		добавить к ней несколько стилей, как к контейнеру &lt;div&gt;.
		Это превратит ее в поле, соответствующее нашему элементу &lt;header&gt;:
</p><p class="code">
<span class="code-blue">.speaker-form</span> {<br>
<span class="code-green">background-color</span>: #F6F7F8;<br>
<span class="code-green">border</span>: 1px solid #D6D9DC;<br>
<span class="code-green">border-radius</span>: 3px;<br>
<br>
<span class="code-green">width</span>: 80%;<br>
<span class="code-green">padding</span>: 50px;<br>
<span class="code-green">margin</span>: 0 0 40px 0;<br>
}
</p>

<div class="title">текстовые поля ввода<br>text input fields</div>
<p>
    Для сбора пользовательских данных понадобится новый инструмент:
		элемент &lt;input/&gt;.
		Для создания текстового поля добавим в &lt;form&gt; немного кода:
</p><p class="code">
&lt;div class='form-row'><br>
&lt;label for='full-name'>Name&lt;/label><br>
&lt;input id='full-name' name='full-name' type='text'/><br>
&lt;/div>
</p><p>
    Во-первых, наш контейнер &lt;div&gt; поможет со стилизацией.
		Это обычная практика для разделения элементов ввода.
		Во-вторых, для меток* формы у нас есть &lt;label&gt;.
		Это еще один <a href="iih12-semantic-html.html">семантический элемент HTML</a>,
		так же как и &lt;article&gt; или &lt;figcaption&gt;.
		Атрибут метки for, должен совпадать с атрибутом id связанного с ней элемента
&lt;input/&gt;.
</p><p class="notetran">
    * - метка - label.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-05-label-element-for-attribute-313489.64666d97.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5: атрибут for элемента &lt;label&gt; указывает на атрибут id элемента
&lt;input&gt;
</small></figcaption>
</figure>

<p>
    В-третьих, элемент &lt;input/&gt; создает текстовое поле.
		Он немного отличается от других элементов, с которыми мы сталкивались, поскольку
		может кардинально менять внешний вид в зависимости от атрибута type, но он
		всегда создает некое интерактивное поле для ввода данных пользователем.
		Помимо текстовых данных далее мы рассмотрим и другие значения.
		Помните, что <a href="iih06-css-selectors.html#id-selectors">ID-селекторы - это плохо</a>:
		атрибут id здесь нужен <em>только</em> для связывания его с элементом &lt;label&gt;.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-06-sending-input-variable-to-server-653369.6274c935.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: атрибут name элемента &lt;input&gt;, отправляющий переменную на сервер
</small></figcaption>
</figure>

<p>
    Теоретически элемент &lt;input/&gt; представляет собой "переменную", отправляемую
		на внутренний сервер.
		Атрибут name определяет имя этой переменной, а значением является то, что
		пользователь ввел в текстовое поле.
		Заметьте, что можно заранее заполнить это значение, добавив к элементу &lt;input/&gt;
		атрибут value.
</p>

<div class="title-under">СТИЛИЗАЦИЯ ПОЛЕЙ ВВОДА ТЕКСТА<br>styling text input fields</div>
<p>
    Элемент &lt;input/&gt; можно стилизовать, как и любой другой элемент HTML.
		Давайте добавим немного CSS в styles.css, чтобы немного украсить его.
		Мы используем все концепции из уроков
<a href="iih04-hello-css.html">Привет, CSS</a>,
<a href="iih05-css-box-model.html">Блоковая модель в CSS</a>,
<a href="iih06-css-selectors.html">Селекторы CSS</a> и
<a href="iih08-flexbox.html">Flexbox</a>:
</p><p class="code">
<span class="code-blue">.form-row</span> {<br>
<span class="code-green">margin-bottom</span>: 40px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: flex-start;<br>
<span class="code-green">flex-direction</span>: column;<br>
<span class="code-green">flex-wrap</span>: wrap;<br>
}<br>
<br>
<span class="code-blue">.form-row</span> <span class="code-strong">input</span>[type='text'] {<br>
<span class="code-green">background-color</span>: #FFFFFF;<br>
<span class="code-green">border</span>: 1px solid #D6D9DC;<br>
<span class="code-green">border-radius</span>: 3px;<br>
<span class="code-green">width</span>: 100%;<br>
<span class="code-green">padding</span>: 7px;<br>
<span class="code-green">font-size</span>: 14px;<br>
}<br>
<br>
<span class="code-blue">.form-row</span> <span class="code-strong">label</span> {<br>
<span class="code-green">margin-bottom</span>: 15px;<br>
}
</p><p>
    Новый тип CSS-селектора input[type='text'], называемый "селектором атрибутов",
		подбирает только те элементы &lt;input/&gt;, у которых атрибут type равен text.
		Это позволяет нам специально выбирать текстовые поля, а не радиокнопки, которые
		определяются одним и тем же HTML-элементом (&lt;input type='radio'/&gt;).
		Подробнее о селекторах атрибутов вы можете прочитать на сайте <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Attribute_selectors">
		Mozilla Developer Network</a>.
</p><p>
    Все наши стили "распределены по именам" в <a href="iih06-css-selectors.html#descendant-selectors">
		селекторе потомка</a> .form-row.
		Подобная разделенность стилей &lt;input/&gt; и &lt;label&gt; облегчает создание
		различных типов форм.
		Почему следует избегать глобальных селекторов input[type='text'] и label, мы
		узнаем, когда доберемся до <a href="#radio-buttons">радиокнопок</a>.
</p><p>
    Наконец, давайте изменим базовые стили, чтобы создать версию для ноутбуков/ПК.
		Добавьте в конец нашей таблицы стилей следующее <a href="iih10-responsive-design.html#media-queries">
		медиавыражение</a>.
</p><p class="code">
<span class="code-strong">@media</span> only screen and (min-width: 700px) {<br>
<span class="code-blue">.speaker-form-header,<br>
.speaker-form</span> {<br>
<span class="code-green">width</span>: 600 px;<br>
}<br>
<span class="code-blue">.form-row</span> {<br>
<span class="code-green">flex-direction</span>: row;<br>
<span class="code-green">align-items</span>: flex-start; <span class="code-grey">/* Чтоб избежать расползания */</span><br>
<span class="code-green">margin-bottom</span>: 20px;<br>
}<br>
<span class="code-blue">.form-row</span> <span class="code-strong">input</span> [type='text'] {<br>
<span class="code-green">width</span>: 250px;<br>
<span class="code-green">height</span>: initial;<br>
}<br>
<span class="code-blue">.form-row</span> <span class="code-strong">label</span> {<br>
<span class="code-green">text-align</span>: right;<br>
<span class="code-green">width</span>: 120px;<br>
<span class="code-green">margin-top</span>: 7px;<br>
<span class="code-green">padding-right</span>: 20px;<br>
}<br>
}
</p><p>
    Посмотрите, как замечательно используется <a href="iih08-flexbox.html#flex-container-direction">
		свойство flex-direction</a>, чтобы &lt;label&gt;
		отображалась поверх своего элемента &lt;input/&gt; в мобильном макете, но
		слева от него в макете для ноутбуков/ПК.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-07-styling-text-input-field-6e4ed3.59f8f642.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: страница с одиночным текстовым полем, стилизованным с помощью CSS
</small></figcaption>
</figure>

<div class="title">поля ввода электронной почты<br>email input fields</div>
<p>
    Атрибут type элемента &lt;input/&gt; также позволяет выполнять базовую валидацию ввода.
		Добавим еще один элемент ввода, принимающий <em>только</em>
		адреса электронной почты, а не любые текстовые значения:
</p><p class="code">
&lt;div class='form-row'><br>
&lt;label for='email'>Email&lt;/label><br>
&lt;input id='email'<br>
         name='email'<br>
         type='email'<br>
         placeholder='joe@example.com'/><br>
&lt;/div>
</p><p>
    Это работает точно так же, как ввод type='text', за исключением автоматической
		проверки ввода email-адреса.
		Попробуйте в Firefox набрать что-то не являющееся мейл-адресом, а затем
		щелкните за пределами поля, чтобы оно потеряло фокус и подтвердило ввод.
		Поле станет красным, показывая, что введенное значение неверно.
		Chrome и Safari не выполняют такую проверку, до тех пор пока пользователь не попытается
		отправить форму.
		Мы увидим это в действии чуть ниже.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-08-firefox-invalid-email-input-f98cc1.c572f304.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: в красной рамке - неверное значение поля электронной почты
</small></figcaption>
</figure>

<p>
    Однако это больше, чем просто валидация.
		Сообщая браузерам, что мы ищем адрес электронной почты, они могут обеспечить
		более интуитивный пользовательский опыт.
		Например, когда браузер смартфона видит атрибут type='email', он отображает
		особую клавиатуру с легкодоступным символом @.
</p><p>
    Также обратите внимание на атрибут placeholder, отображающий какой-либо
		стандартный текст, когда элемент &lt;input/&gt; пуст.
		Это хороший прием UX*, побуждающий пользователя ввести собственное значение.
</p><p>
    Помимо email-адресов, существует множество других встроенных параметров валидации.
		Подробнее см. MDN-<a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/input">
		справочник по &lt;input/&gt;</a>.
		Особенно интересны атрибуты required, minlength, maxlength и pattern.
</p><p class="notetran">
    * - UX - User Experience - Опыт взаимодействия.
</p>

<div class="title-under">СТИЛИЗАЦИЯ ПОЛЕЙ ВВОДА электронной почты<br>styling email input fields</div>
<p>
    Мы хотим, чтобы наше поле email соответствовало текстовому полю из предыдущей
		секции.
		Поэтому добавим еще один селектор атрибутов к существующему правилу input[type='text'],
		как показано ниже:
</p><p class="code">
<span class="code-grey">/* Измените это правило */</span><br>
<span class="code-blue">.form-row</span> <span class="code-strong">input</span>[type='text'] {<br>
<span class="code-green">background-color</span>: #FFFFFF;<br>
<span class="code-grey">/* ... */</span><br>
}<br>
<br>
<span class="code-grey">/* Чтобы получить еще один селектор */</span><br>
<span class="code-blue">.form-row</span> <span class="code-strong">input</span>[type='text'],<br>
<span class="code-blue">.form-row</span> <span class="code-strong">input</span>[type='email'] {<br>
<span class="code-green">background-color</span>: #FFFFFF;<br>
<span class="code-grey">/* ... */</span><br>
}
</p><p>
    Опять же, мы не хотим использовать здесь обычный input type селектор, потому
		что тогда будут стилизованы <em>все элементы</em> &lt;input/&gt;, включая
		радиокнопки и чекбоксы.
		Это часть того, что делает стилизацию форм сложной.
		Понимание CSS для выделения именно тех элементов, которые вам нужны -
		крайне важный навык.
</p><p>
    Не будем забывать и о стилях для ноутбука/ПК.
		В нашем медиавыражении обновите правило input[type='text'] так, чтобы оно
		соответствовало следующему (обратите внимание, что мы готовимся к
		следующим секциям с селекторами select и textarea):
</p><p class="code">
<span class="code-strong">@media</span> only screen and (min-width: 700px) {<br>
<span class="code-grey">/* ... */<br>
<span class="code-blue">.form-row</span> <span class="code-strong">input</span> [type='text'],<br>
<span class="code-blue">.form-row</span> <span class="code-strong">input</span> [type='text'], <span class="code-grey">/* Добавьте */<br>
<span class="code-blue">.form-row</span> <span class="code-strong">input</span> [type='text'], <span class="code-grey">/* эти */<br>
<span class="code-blue">.form-row</span> <span class="code-strong">input</span> [type='text'], <span class="code-grey">/* селекторы */<br>
<span class="code-green">width</span>: 250px;<br>
<span class="code-green">height</span>: initial;<br>
}<br>
<span class="code-grey">/* ... */<br>
}
</p><p>
    Поскольку теперь у нас возможно "верное" и "неверное" входное значение,
		наверно следует донести это до пользователей.
<a href="iih06-css-selectors.html#pseudo-classes-for-links">
		Псевдоклассы</a> :invalid и :valid позволяют стилизовать эти состояния независимо
		друг от друга.
		Например, мы хотим сделать рамку и текст красными, если пользователь ввел
		неприемлемое значение.
		Добавьте следующее правило в нашу таблицу стилей, вне медиавыражения:
</p><p class="code">
<span class="code-blue">.form-row</span> <span class="code-strong">input</span>[type='text']: invalid,<br>
<span class="code-blue">.form-row</span> <span class="code-strong">input</span>[type='email']: invalid {<br>
<span class="code-green">border</span>: 1px solid #D55C5F;<br>
<span class="code-green">color</span>: #D55C5F;<br>
<span class="code-green">box-shadow</span>: none;
<span class="code-grey">/* Удаление стандартного красного свечения в Firefox */</span><br>
}

</p><p>
    Пока мы не добавим кнопку отправки, вы сможете увидеть это только в Firefox,
		но идея вам понятна.
		Существует еще псевдокласс :focus, выбирающий элемент, который
		пользователь заполняет в данный момент.
		Это дает еще больше контроля над внешним видом форм.
</p>

<div class="title" id="radio-buttons">радиокнопки<br>radio buttons</div>
<p>
    Изменение свойства type элемента &lt;input/&gt; на radio превращает его в радиокнопку.
		С радиокнопками дело обстоит немного сложнее, чем с текстовыми полями, поскольку
		они всегда работают в группах, позволяя пользователю выбрать один вариант из
		множества предопределенных.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-09-radio-label-fieldset-legend-elements-0affe5.75239169.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: &lt;fieldset&gt;, обертывающий &lt;legend&gt; и ряд радиокнопок
		со связанными элементами &lt;label&gt;
</small></figcaption>
</figure>

<p>
    Это означает, что нужна не только метка для каждого элемента &lt;input/&gt;,
		но и способ группировки радиокнопок и маркировки всей группы.
		Для этого предназначены &lt;fieldset&gt; и &lt;legend&gt;.
		Каждая созданная группа радиокнопок должна:
</p><ul>
<li>Быть обернута в &lt;fieldset&gt;, который помечен &lt;legend&gt;.</li>
<li>Связывать элемент &lt;label&gt; с каждой радиокнопкой</li>
<li>Использовать один и тот же атрибут name для каждой радиокнопки в группе.</li>
<li>Использовать разные атрибуты value для каждой радиокнопки.</li>
</ul><p>
    Наш пример с радиокнопкой содержит все эти компоненты.
		Добавьте в элемент &lt;form&gt; под полем электронной почты следующее:
</p><p class="code">
&lt;fieldset class='legacy-form-row'><br>
&lt;legend>Type of Talk&lt;/legend><br>
&lt;input id='talk-type-1'<br>
         name='talk-type'<br>
         type='radio'<br>
         value='main-stage' /><br>
&lt;label for='talk-type-1' class='radio-label'>Main Stage&lt;/label><br>
&lt;input id='talk-type-2'<br>
         name='talk-type'<br>
         type='radio'<br>
         value='workshop'<br>
         checked /><br>
&lt;label for='talk-type-2' class='radio-label'>Workshop&lt;/label><br>
&lt;/fieldset>
</p><p>
    В отличие от текстовых полей, пользователь не может вводить свои значения в
		радиокнопки, поэтому каждая из них нуждается в явном атрибуте value.
		Именно это значение отправится на сервер, когда пользователь отправит форму.
		Также очень важно, чтобы у каждой радиокнопки был одинаковый атрибут name, иначе
		форма не поймет, что они входят в одну группу.
</p><p>
    Мы также добавили новый атрибут - checked.
		Это атрибут "булева типа".
		Он никогда не принимает значения - он либо существует в элементе &lt;input/&gt;,
		либо не существует.
		Если он присутствует на элементе радиокнопки или галочки, то этот элемент будет
		выбран/отмечен по умолчанию.
</p>

<div class="title-under">СТИЛИЗАЦИЯ РАДИОКНОПОК<br>styling radio buttons</div>
<p>
    Когда речь идет о стилизации радиокнопок, против нас работает несколько вещей.
		Во-первых, просто больше элементов, о которых нужно беспокоиться.
		Во-вторых, элементы &lt;fieldset&gt; и &lt;legend&gt; имеют довольно уродливые стили по
		умолчанию, и в разных браузерах они не слишком согласованы.
		В-третьих, на момент написания этой статьи &lt;fieldset&gt; не поддерживает
		flexbox.
</p><p>
    Не волнуйтесь! Это хороший пример того, как <a href="iih07-floats.html">
		обтекание</a> [floats] может быть хорошим Plan B для устаревших/неудобных элементов.
		Вы заметили, что вместо существующего класса радиокнопки .form-row, мы выбрали
		новый класс .legacy-form-row?
		Так он будет полностью отделен от других элементов, используя
		floats вместо flexbox.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-10-radio-button-float-layout-df003b.a95fa586.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10:  мобильная версия, созданная блоковым блоком &lt;label&gt; и версия
		для ноутбуков/ПК с плавающим элементом слева
</small></figcaption>
</figure>

<p>
    Начнем со стилей для смартфонов и планшетов, добавив следующие правила за
		пределами медиавыражения.
		Мы избавимся от стандартных стилей &lt;fieldset&gt; и &lt;legend&gt;, затем
		сделаем радиокнопки и ярлыки обтекаемыми, чтобы они отображались в одну строку
		под &lt;legend&gt;:
</p><p class="code">
<span class="code-blue">.legacy-form-row</span> {<br>
<span class="code-green">border</span>: none;<br>
<span class="code-green">margin-bottom</span>: 40px;<br>
}<br>
<br>
<span class="code-blue">.legacy-form-row</span> <span class="code-strong">legend</span> {<br>
<span class="code-green">margin-bottom</span>: 15px;<br>
}<br>
<br>
<span class="code-blue">.legacy-form-row .radio-label</span> {<br>
<span class="code-green">display</span>: block;<br>
<span class="code-green">font-size</span>: 14px;<br>
<span class="code-green">padding</span>:  0 20px 0 10px;<br>
}<br>
<br>
<span class="code-blue">.legacy-form-row</span> <span class="code-strong">input</span> [type='radio'] {<br>
<span class="code-green">margin-top</span>: 2px;<br>
}<br>
<br>
<span class="code-blue">.legacy-form-row .radio-label,<br>
.legacy-form-row</span> <span class="code-strong">input</span> [type='radio'] {<br>
<span class="code-green">float</span>: left;<br>
}
</p><p>
    В версии для ноутбуков/ПК нужно, чтобы &lt;legend&gt; располагался на одной линии
		с элементами &lt;label&gt; из предыдущей секции (отсюда ширина: 120px),
		чтобы <em>все элементы</em> были плавающими (float), и отображались на одной
		линии.
		Обновите наши медиавыражения, включив в них следующее:
</p><p class="code">
<span class="code-strong">@media</span> only screen and (min-width: 700px) {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-blue">.legacy-form-row</span> {<br>
<span class="code-green">margin-bottom</span>: 10px; <br>
}<br>
<span class="code-blue">.legacy-form-row</span> <span class="code-strong">legend</span> {<br>
<span class="code-green">width</span>: 120px;<br>
<span class="code-green">text-align</span>: right;<br>
<span class="code-green">padding-right</span>: 20px;<br>
}<br>
<span class="code-blue">.form-row</span> <span class="code-strong">legend</span> {<br>
<span class="code-green">float</span>: left;<br>
}<br>
}

</p><p>
    Что касается макетов, то это довольно хорошее кроссбраузерное решение.
		Однако настройка внешнего вида самой кнопки - это уже другая история.
		Это возможно, если воспользоваться атрибутом checked, но это немного сложно.
		Мы оставим вас гуглить "custom radio button CSS" и исследовать эту кроличью
		нору самостоятельно.
</p>

<div class="title">элементы select (выпадающие меню)<br>select elements
(dropdown menus)</div>
<p>
    Выпадающие меню являются альтернативой радиокнопкам, поскольку они позволяют
		пользователю выбрать один из множества вариантов.
		Элемент &lt;select&gt; представляет собой выпадающее меню и содержит множество
		элементов &lt;option&gt;, которые представляют каждый элемент.
</p><p class="code">
&lt;div class='form-row'><br>
&lt;label for='t-shirt'>T-Shirt Size&lt;/label><br>
&lt;select id='t-shirt' name='t-shirt'><br>
&lt;option value='xs'>Extra Small&lt;/option><br>
&lt;option value='s'>Small&lt;/option><br>
&lt;option value='m'>Medium&lt;/option><br>
&lt;option value='l'>Large&lt;/option><br>
&lt;/div>
</p><p>
    Как и в элементах радиокнопки &lt;input/>, у нас есть атрибуты name и value,
		которые передаются на внутренний сервер.
		Но вместо того, чтобы быть определенными в одном элементе, они распределены
		между элементами &lt;select> и &lt;option>.
</p>

<div class="title-under">СТИЛИЗАЦИЯ ЭЛЕМЕНТОВ SELECT<br>styling select elements</div>
<p>
    Как и радиокнопки, элементы &lt;select>, с трудом поддаются стилизации.
		На это есть своя причина.
		Выпадающие элементы - это сложный интерактивный элемент, и их поведение
		значительно отличается на разных устройствах.
		Например, на iPhone нажатие на элемент &lt;select> приводит к появлению
		собственного прокручивающегося компонента пользовательского интерфейса,
		который значительно упрощает навигацию по меню.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-11-select-dropdown-in-iphone-a9968d.5e9c2541.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: три элемента &lt;option> в прокручивающемся меню &lt;select>
		в нижней части экрана iPhone
</small></figcaption>
</figure>

<p>
    Лучше всего позволить браузеру/устройству определить оптимальный способ
		предварительной настройки элемента &lt;select>, поэтому мы сохраним простоту
		нашего CSS.
		К сожалению, даже самые простые вещи оказываются иногда на удивление сложными.
		Например, попробуйте изменить размер шрифта нашего элемента &lt;select>:
</p><p class="code">
<span class="code-blue">.form-row</span> <span class="code-strong">select</span> {<br>
<span class="code-green">width</span>: 100%;<br>
<span class="code-green">padding</span>: 5px;<br>
<span class="code-green">font-size</span>: 14px; <span class="code-grey">/* Это не работает в Chrome или Safari */</span><br>
}
</p><p>
    Это работает в Firefox, но не в Chrome или Safari!
		Чтобы исправить ситуацию, можно использовать префикс для свойства appearance,
		характерный для конкретного производителя:
</p><p class="code">
<span class="code-blue">.form-row</span> <span class="code-strong">select</span> {<br>
<span class="code-green">width</span>: 100%;<br>
<span class="code-green">padding</span>: 5px;<br>
<span class="code-green">font-size</span>: 14px; <span class="code-grey">/* Это не работает в Chrome или Safari */</span><br>
<span class="code-green">-webkit-appearance</span>: none; <span class="code-grey">/* Данный префикс заставит это работать */</span><br>
}
</p><p>
    Префикс -webkit будет применяться <em>только</em> к Chrome и Safari (они работают на
		движке WebKit), а Firefox останется незатронутым.
		По сути это хак.
		Даже MDN говорит о том, что <a href="https://developer.mozilla.org/ru/docs/Web/CSS/appearance">
		не стоит использовать это свойство CSS</a>.
</p><p>
    Подобные трудности со стилями - серьезный аспект при создании формы.
		Если вам нужны пользовательские стили, лучше использовать радиокнопки или виджеты JavaScript UI.
<a href="https://getbootstrap.com/docs/3.4/javascript/">
		Bootstrap Dropdowns</a> и <a href="https://jqueryui.com/selectmenu/#default">
		jQuery Selectmenu</a> - распространенные JavaScript-решения для настройки меню выбора.
		В любом случае, теперь вы хотя бы понимаете суть проблемы.
		Подробнее о проблемах &lt;select> можно прочитать <a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Advanced_form_styling#Dealing_with_the_select_nightmare">
		здесь</a>.
</p>

<div class="title">ТЕКСТОВЫЕ ПОЛЯ<br>textareas</div>
<p>
    Элемент &lt;textarea> создает многострочное текстовое поле, предназначенное
		для большого количества текста от пользователя.
		Они подходят для таких вещей, как биографии, эссе и комментарии.
		Давайте добавим &lt;textarea> в нашу форму вместе с небольшим инструктирующим
		текстом:
</p><p class="code">
&lt;div class='form-row'><br>
&lt;label for='abstract'>Abstract&lt;/label><br>
&lt;textarea id='abstract' name='abstract'>&lt;/textarea><br>
&lt;div class='instructions'>Describe your talk in 500 words or less&lt;/div><br>
&lt;/div>
</p><p>
    Заметьте, что этот элемент не является самозакрывающимся, как элемент &lt;input/>,
		поэтому вам всегда нужен закрывающий тег &lt;/textarea>.
		Если вы хотите добавить текст по умолчанию, он должен находиться внутри тега,
		а не в атрибуте value.
</p>

<div class="title-under">СТИЛИЗАЦИЯ ТЕКСТОВЫХ ПОЛЕЙ<br>styling textareas</div>
<p>
    К счастью, стилизация текстовых полей довольно проста.
		Добавьте в ваш файл styles.css (перед медиавыражением!) следующее:
</p><p class="code">
<span class="code-blue">.form-row</span> <span class="code-strong">textarea</span> {<br>
<span class="code-green">font-family</span>: "Helvetica", "Arial", sans-serif;<br>
<span class="code-green">font-size</span>: 14px;<br>
<br>
<span class="code-green">border</span>: 1px solid #D6D9DC;<br>
<span class="code-green">border-radius</span>: 3px;<br>
<br>
<span class="code-green">min-height</span>: 200px;<br>
<span class="code-green">margin-bottom</span>: 10px;<br>
<span class="code-green">padding</span>: 7px;<br>
<span class="code-green">resize</span>: none;<br>
}<br>
<br>
<span class="code-blue">.form-row .instructions</span> {<br>
<span class="code-green">color</span>: #999999;<br>
<span class="code-green">font-size</span>: 14px;<br>
<span class="code-green">margin-bottom</span>: 30px;<br>
}
</p><p>
    По умолчанию многие браузеры позволяют пользователю изменять размер элементов
&lt;textarea> до нужных размеров.
		Мы отключили это с помощью свойства resize.
</p><p>
    Также нам нужно немного поправить макет для ноутбуков/ПК.
		&lt;div>-элемент .instructions должен находиться под &lt;textarea>, поэтому
		давайте сдвинем его влево на ширину колонки &lt;label>.
		В конец нашего медиавыражения добавьте следующее правило:
</p><p class="code">
<span class="code-strong">@media</span> only screen and (min-width: 700px) {<br>
<span class="code-grey">/* ... */<br>
<span class="code-blue">.form-row .instructions</span> {<br>
<span class="code-green">margin-left</span>: 120px;<br>
}<br>
}
</p>

<div class="title">чекбоксы<br>checkboxes</div>
<p>
    Чекбоксы - это что-то вроде радиокнопок, но они позволяют пользователю выбрать
		сколько угодно вариантов вместо всего одного.
		Это упрощает задачу, ибо браузеру не нужно знать, какие флажки входят
		в одну группу.
		Другими словами, нам не нужна обертка &lt;fieldset> или общие атрибуты имен
		[shared name attributes].
		Добавьте в конец формы следующее:
</p><p class="code">
&lt;div class='form-row'><br>
&lt;label class='checkbox-label' for='available'><br>
&lt;input id='available'<br>
name='available'<br>
type='checkbox'<br>
value='is-available'/><br>
&lt;span>I’m actually available the date of the talk&lt;/span><br>
&lt;/label><br>
&lt;/div>
</p><p>
    То, как мы использовали &lt;label> здесь, немного отличается от предыдущих
		секций.
		Вместо того чтобы быть отдельным элементом, &lt;label> обертывает
		соответствующий элемент &lt;input/>.
		Это вполне допустимо, и так будет проще подобрать нужный нам макет.
		Но все же лучше использовать атрибут for.
</p>

<div class="title-under">СТИЛИЗАЦИЯ ЧЕКБОКСОВ<br>styling checkboxes</div>
<p>
    Для мобильного макета нам нужно всего лишь переопределить margin-bottom,
		который мы установили для остальных элементов &lt;label>.
		Добавьте в styles.css, вне медиавыражения, следующее:
</p><p class="code">
<span class="code-blue">.form-row .checkbox-label</span> {<br>
<span class="code-green">margin-bottom</span>: 0;<br>
}
</p><p>
    А внутри медиавыражения мы должны учесть 120-пиксельную колонку с метками:
</p><p class="code">
<span class="code-strong">@media</span> only screen and (min-width: 700px) {<br>
<span class="code-grey">/* ... */<br>
<span class="code-blue">.form-row .checkbox-label</span> {<br>
<span class="code-green">margin-left</span>: 120px;<br>
<span class="code-green">width</span>: auto;<br>
}<br>
}
</p><p>
    Обернув и чекбокс, и текст метки, можно использовать ширину auto для расположения
		всего поля формы в одну строку.
		Помните, что ширина auto заставляет блок соответствовать размеру его контента?
</p>

<figure>
<img class="pic-pages" src="./images/iih13-12-adding-a-checkbox-8a0541.ad08759c.png"
width="45%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 12: веб-страница с несколькими элементами HTML-формы, включая чекбокс
</small></figcaption>
</figure>

<div class="title">кнопки отправки<br>submit buttons</div>
<p>
    И наконец, завершим нашу форму кнопкой отправки.
		Элемент &lt;button> это кнопка, отправляющая содержащуюся
		в ней &lt;form>:
</p><p class="code">
&lt;div class='form-row'><br>
&lt;button>Submit&lt;/button><br>
&lt;/div>
</p><p>
    При нажатии на кнопку браузер проверяет все элементы &lt;input/> в форме.
		Если проблем с валидацией	не возникло, он отправляет ее по URL-адресу action.
		Если в поле email вы ввели что-то, не являющееся адресом электронной почты
		и нажмете кнопку &lt;button>, то увидите сообщение об ошибке.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-13-chrome-invalid-email-input-3ae531.21eff6a1.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 13: сообщение об ошибке ввода недопустимого значения для поля
		электронной почты
</small></figcaption>
</figure>

<p>
    Это также дает нам возможность увидеть, как данные пользователя отправляется
		на сервер.
		Сначала заполните все поля &lt;input/> и убедитесь, что e-mail валидируется
		верно.
		Затем нажмите кнопку и просмотрите полученный URL в браузере.
		Там должно быть что-то вроде этого:
</p><p class="code">
speaker-submission.html?full-name=Rick&email=rick%40internetingishard.com&talk-type=workshop&t-shirt=l&abstract=Derp.&available=is-available
</p><p>
    Все, что находится после ? представляет собой переменные в нашей форме.
		За атрибутом name каждого &lt;input/> следует знак равенства, затем его значение.
		Каждая переменная отделяется символом &amp;.
		Если бы у нас был внутренний сервер, ему было бы очень просто получить всю
		эту информацию, запросить базу данных (или что-то еще) и сообщить, была ли
		отправка формы успешной или нет.
</p>

<div class="title-under">СТИЛИЗАЦИЯ КНОПОК<br>styling buttons</div>
<p>
    В <a href="iih06-css-selectors.html#pseudo-classes-for-links">секции "Псевдоклассы"</a>
		урока <em>Селекторы CSS</em> у нас был опыт стилизации кнопок.
		Тогда мы применяли эти стили к элементу &lt;a>, но мы можем использовать те же
		приемы и для &lt;button>.
</p>

<figure>
<img class="pic-pages" src="./images/iih13-14-styling-a-submit-button-7e80de.07a2978c.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 14: кнопка отправки формы
</small></figcaption>
</figure>

<p>
    Очистим этот безобразный стандартный стиль &lt;button>, добавив в таблицу
		стилей следующее:
</p><p class="code">
<span class="code-blue">.form-row</span> <span class="code-strong">button</span> {<br>
<span class="code-green">font-size</span>: 16px;<br>
<span class="code-green">font-weight</span>: bold;<br>
<br>
<span class="code-green">color</span>: #FFFFFF;<br>
<span class="code-green">background-color</span>: #5995DA;<br>
<br>
<span class="code-green">border</span>: none;<br>
<span class="code-green">border-radius</span>: 3px;<br>
<br>
<span class="code-green">padding</span>: 10px 40px;<br>
<span class="code-green">cursor</span>: pointer;<br>
}<br>
<br>
<span class="code-blue">.form-row</span> <span class="code-strong">button</span>:hover {<br>
<span class="code-green">background-color</span>: #76AEED;<br>
}<br>
<br>
<span class="code-blue">.form-row</span> <span class="code-strong">button</span>:active {<br>
<span class="code-green">background-color</span>: #407FC7;<br>
}
</p><p>
    Как и в случае с чекбоксом, учитываем колонку с метками шириной 120px, поэтому
		включаем в медиавыражения еще одно правило:
</p><p class="code">
<span class="code-strong">@media</span> only screen and (min-width: 700px) {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-blue">.form-row</span> <span class="code-strong">button</span>{<br>
<span class="code-green">margin-left</span>: 120px; <br>
}<br>
}
</p>

<div class="title">РЕЗЮМЕ</div>
<p>
    На этом уроке вы узнали про наиболее распространенные элементы форм HTML.
		Теперь у вас есть все эти инструменты для сбора данных от посетителей вашего сайта:
</p><ul>
<li>&lt;input type='text'/></li>
<li>&lt;input type='email'/></li>
<li>&lt;input type='radio'/></li>
<li>&lt;select> и &lt;option></li>
<li>&lt;textarea></li>
<li>&lt;input type='checkbox'/></li>
<li>&lt;button></li>
</ul><p>
    Для создания красивых форм вы должны хорошо разбираться в HTML и CSS, но для
		того, чтобы сделать эти формы функциональными, требуются навыки, которых у
		вас пока нет.
		Эти навыки выходят за рамки данного учебника, но, возможно, вам будет полезно
		узнать о них.
		В общем, существует два способа обработки форм:
</p><ul>
<li>Используйте атрибут action, чтобы отправить данные формы на внутренний URL-адрес,
	  который затем перенаправляет на страницу "Успех" [success page] или "Ошибка"
		[error page].
		Выше мы уже говорили об этом, и никакого JavaScript тут не требуется.</li>
<li>Используйте AJAX-запросы, чтобы отправить форму, не покидая страницу.
	  Сообщения об успехе или ошибке отображаются на той же странице путем управления
		HTML с помощью JavaScript.</li>
</ul><p>
    В зависимости от структуры вашей компании, обработка форм может не входить в
		ваши обязанности фронтенд-веб-разработчика.
		В этом случае скооперируйтесь с бэкенд-разработчиком из вашей команды,
		чтобы убедиться, что &lt;form> отправляет правильные пары имя-значение.
		Иначе вам придется позаботиться о том, чтобы фронтенд и бэкенд ваших форм
		гармонично сочетались друг с другом.
</p><p>
    Далее вас ожидает <a href="/">заключительный урок</a>.
		Мы завершим навыки работы с фронтендом, подробно обсудив веб-шрифты и
		практические принципы типографики, которые должен знать каждый разработчик.
</p>
<hr>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<h2>ВЕБ-ТИПОГРАФИКА</h2>
<div class="chapter">УРОК Nº 14.</div>
<p><em>
    Самый понятный учебник веб-шрифтов и основных принципов типографики
</em></p>


<p>
    Под "веб-типографикой" понимают внешний вид всего текста на сайте.
		Она включает <a href="iih04-hello-css.html#more-text-styles">основные свойства
		текста CSS</a>, например, какой тип шрифта использовать, когда выделять курсивом.
		Но типографика - это намного больше.
		Это пространство между и вокруг букв, слов и строк.
		Это размер различных участков текста по отношению друг к другу и история
		каждого семейства шрифтов.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-01-web-typography-terminology-e06b82.f2f8b094.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: примеры семейств и относительных размеров шрифтов, стилей
		отступов, выравнивания текста, вертикального интервала и длины строки
</small></figcaption>
</figure>

<p>
    Многие типографические решения вам подскажет дизайнер.
		Проблема в том, что типографика - это "невидимое" искусство.
		Чтобы понять, о чем просят дизайнеры, нужно уметь видеть типографику так же,
		как они.
</p><p>
    Этот урок посвящен не только механике добавления веб-шрифтов на сайт или
		свойствам CSS для перемещения текста.
		Мы также выясним, как правильно использовать все эти инструменты для создания
		красивых, профессиональных сайтов.
    Допустим, дизайнер спрашивает: "Можно ли увеличить отступы в этом абзаце?"
		Так вот, к концу этого урока вы будете не только понимать о чем говорят дизайнеры,
		но и <em>почему</em> они этого хотят.
</p><p>
    Можно позабыть конкретные свойства CSS, но концепции типографики, рассмотренные
		ниже, останутся с вами навсегда, потому что это не случайные правила - они
		основаны на функциях.
		Они делают ваш контент более читабельным и помогают эффективнее доносить информацию.
</p>

<div class="title">краткая история веб-шрифтов<br>a brief history of web fonts</div>
<p>
    Начнем с изучения того, как отображать веб-страницы собственным* шрифтом,
		ибо это самый интересный аспект современной веб-типографики.
		За последние несколько лет веб-шрифты сильно изменились, поэтому,
		прежде чем приступить к созданию нашего примера, вам необходимо получить
		базовое представление о различных форматах шрифтов в Интернете.
</p><p class="notetran">
	  * - в оригинале: custom font - "пользовательский шрифт".
</p>

<div class="title-under">БЕЗОПАСНЫЕ ВЕБ-ШРИФТЫ<br>web safe fonts</div>
<p>
    Давным-давно существовали только "безопасные веб-шрифты".
		Их было около дюжины и они были предустановлены на большинстве компьютеров.
		Не было такого понятия, как пользовательский файл шрифта, отправляемый
		браузерам для использования на вашем сайте.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-02-web-safe-fonts-eaa8b0.1fcdf764.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2: веб-сервер запрашивает у компьютера пользователя отображение текста
		шрифтом Georgia, компьютер проверяет у себя наличие этого шрифта
</small></figcaption>
</figure>

<p>
    Если вам <em>был нужен</em> особый шрифт, единственным вариантом было экспортировать
		изображение текста и включить его в веб-страницу с помощью элемента &lt;img/>.
		Это безумно ограничивало возможности веб-дизайнеров и приводило к довольно
		сложным ситуациям для разработчиков.
		Честно говоря, мы не знаем, как мы выжили в ту эпоху HTML и CSS.
</p>

<div class="title-under">СОБСТВЕННЫЕ ВЕБ-ШРИФТЫ<br>custom web fonts</div>
<p>
    Примерно в 2010 году браузеры начали поддерживать собственные шрифты, что было замечательно.
		Однако для каждого браузера и дивайса требовался свой формат файла.
		Соответственно, большинство веб-сайтов предоставляли 4 разных файла веб-шрифтов:
</p><table>
<tr>
<td><strong>ФОРМАТ ФАЙЛА</strong></td>
<td><strong>БРАУЗЕР/УСТРОЙСТВО</strong></td>
</tr><tr>
<td>.svg</td>
<td>Очень старые Safari (iOS и десктоп)</td>
</tr><tr>
<td>.eot</td>
<td>Internet Explorer</td>
</tr><tr>
<td>.ttf</td>
<td>Все кроме Internet Explorer</td>
</tr><tr>
<td>.woff</td>
<td>Более новые браузеры</td>
</tr>
</table>
<p>
    В результате появился "пуленепробиваемый синтаксис" <a href="https://www.paulirish.com/2009/bulletproof-font-face-implementation-syntax/">
		Bulletproof @font-face syntax</a>, с которым вы наверняка столкнетесь в
		какой-то момент своей карьеры веб-разработчика.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-03-bulletproof-font-face-d18a22.c3574f93.png"
width="65%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: веб-сервер предоставляет браузеру для использования шрифты .svg, .eot, .ttf и .woff
</small></figcaption>
</figure>

<div class="title-under">ШРИФТЫ WOFF<br>woff fonts</div>
<p>
    С недавнего времени* были стандартизированы Web Open Font Format (WOFF),
		и жить стало немного проще.
<a href="https://caniuse.com/?search=woff">
		Более 90%</a> современных браузеров поддерживают шрифты в формате .woff.
		Также растет и поддержка его следующей эволюции - .woff2.
		WOFF2 похож на оригинальный формат WOFF, но предлагает значительное уменьшение
		размера файла (что увеличивает производительность).
</p><p class="notetran">
    * - Данный учебник был опубликован в 2017 году.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-04-woff-and-woff-2-fonts-0cced1.5f1b640d.png"
width="45%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: веб-сервер, предоставляющий браузеру только шрифты .woff и .woff2
</small></figcaption>
</figure>

<p>
    Со временем, вероятно, вы полностью перейдете на WOFF2, но сейчас мы рекомендуем
		как WOFF, так и WOFF2.
		Это обеспечит безотказную работу на старых браузерах и повысит производительность
		на современных.
		Если только устаревшие браузеры не составляют большую часть вашей целевой аудитории,
		шрифты .ttf, .svg и .eot уходят в прошлое.
</p>

<div class="title">где найти веб-шрифты<br>where to find web fonts</div>
<p>
    В Интернете есть множество мест, где можно скачать как бесплатные, так и
		премиум шрифты.
		Три наших фаворита перечислены ниже.
		Какой шрифт использовать, обычно решает ваш дизайнер (и его бюджет), но для
		разработчика полезно знать компромиссы между этими вариантами.
</p><table>
<tr>
<td><strong>САЙТ</strong></td>
<td><strong>ЦЕНА</strong></td>
<td><strong>КАЧЕСТВО</strong></td>
<td><strong>ВЫБОР</strong></td>
</tr><tr>
<td><a href="https://www.fontsquirrel.com/">Font Squirrel</a></td>
<td>Халява</td>
<td>Пан-Либо-Пропал</td>
<td>Огромный</td>
</tr><tr>
<td><a href="https://fonts.google.com/">Google Fonts</a></td>
<td>Халява</td>
<td>Хорошее</td>
<td>Приличный</td>
</tr><tr>
<td><a href="https://www.fontspring.com/">Fontspring</a></td>
<td>Дорого</td>
<td>Хорошее</td>
<td>Превосходный</td>
</tr>
</table><p>
    Шрифты WOFF разработаны специально для современного веба, в то время как
		шрифты для ноутбуков/ПК содержат дополнительные функции, полезные для программ
		редактирования графики, таких как Adobe Illustrator.
		Обязательно загрузите или приобретите веб-версию шрифтов, которые вы хотите
		использовать, а не только версию для ноутбука/ПК.
</p>


<div class="title">подготовка<br>setup</div>
<p>
    Итак, мы готовы к экспериментам с веб-шрифтами.
		Для этого мы создадим этот <a href="https://internetingishard.netlify.app/html-and-css/web-typography/example/final/web-fonts">
		пример веб-сайта</a>.
		Мы подумали, что вам, вероятно, не захочется начинать его с нуля, поэтому <a href="docs/iih14-web-typography-338d1d.zip">
		загрузите начальный проект</a>.
		Распакуйте его и откройте папку web-typography в своем любимом текстовом редакторе.
		Если у вас нет любимого текстового редактора, воспользуйтесь <a href="iih01-intro.html#atom">
		редактором Atom</a>.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-05-project-files-af1f60.0cb68671.png"
width="25%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5: файловый браузер редактора Atom после распаковки примера проекта
</small></figcaption>
</figure>

<p>
    У нас есть 6 HTML-документов, использующих таблицу стилей typo.css.
		Мы продемонстрируем различные принципы типографики, добавив в каждый из этих
		HTML-файлов некоторые <a href="iih04-hello-css.html#cascade">стили для конкретной
		страницы</a>.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-06-web-typography-screenshot-669f41.07e9c0ec.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: наш пример веб-страницы с веб-шрифтами и системными шрифтами
		(до добавления веб-шрифтов)
</small></figcaption>
</figure>

<p>
    Откройте один из HTML-файлов в браузере.
		Вы увидите, что наш исходный проект очень близок к финальному, за исключением
		веб-шрифтов и других типографических свойств CSS.
</p>

<div class="title">локальные веб-шрифты<br>locally hosted web fonts</div>
<p>
    Существует два различных способа добавления веб-шрифтов на ваш сайт: локальное
		размещение [locally hosted] и внешнее размещение [externally hosted].
		Ниже мы рассмотрим оба способа.
		Сначала в наш проект мы добавим локально размещенный веб-шрифт.
		Этот процесс состоит из трех шагов:
</p><ol>
<li>Скачайте веб-шрифт и добавьте его в свой проект.</li>
<li>Вставьте веб-шрифт в таблицу стилей.</li>
<li>Используйте шрифт в других местах таблицы стилей.</li>
</ol><p>
    Мы будем работать с файлами web-fonts.html и typo.css.
		Откройте их в текстовом редакторе, если вы еще этого не сделали.
</p>

<div class="title-under">ХОСТИНГ ФАЙЛА WOFF<br>hosting a woff file</div>
<p>
    Итак, нам нужен веб-шрифт.
		В нашем примере используется бесплатный шрифт Roboto.
		Скачайте его с <a href="https://www.fontsquirrel.com/fonts/roboto">
		Font Squirrel</a>.
		Убедитесь, что выбрана вкладка <strong>Webfont Kit</strong>, а не кнопка <strong>
		Download TTF</strong>.
		Снимите флажки со всех форматов, кроме <strong>WOFF</strong>, поскольку мы будем
		использовать только его.
		Затем нажмите на <strong>Download @font-face Kit</strong>.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-07-download-roboto-screenshot-348421.0b0f7a17.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: загрузка семейства шрифтов Roboto с сайта Font Squirrel
</small></figcaption>
</figure>

<p>
    В итоге вы получите ZIP-файл с лицензией, инструкциями и папкой web fonts
		с кучей поддиректорий.
		Шрифт Roboto имеет множество различных <a href="#font-families-and-font-faces">
		начертаний</a> - светлое, обычное, полужирное, курсивное и конденсированное.
		Каждая из этих папок содержит разные начертания.
		Нужная нам называется roboto_light_macroman.
		Откройте ее и скопируйте файл Roboto-Light-webfont.woff в наш проект.
</p>

<div class="title-under">ВСТРАИВАНИЕ ВЕБ-ШРИФТА<br>embedding a web font</div>
<p>
    Отлично.
		У нас есть файл WOFF.
		Для использования на нашей веб-странице, нужно вставить его в таблицу
		стилей с помощью правила @font-face.
		Веб-шрифты всегда должны быть включены в верхнюю часть таблицы стилей, поэтому
		добавьте код в самое начало typo.css:
</p><p class="code">
<span class="code-strong">@font-face</span> {<br>
<span class="code-green">font-family</span>: <span class="code-rust">'Roboto'</span>;<br>
<span class="code-green">src</span>: <span class="code-blue">url</span>(
<span class="code-rust">'Roboto-Light-webfont.woff'</span>) <span class="code-blue">format</span>(
<span class="code-rust">'woff'</span>);<br>
}
</p><p>
    Свойство font-family определяет, как мы будем ссылаться на этот шрифт в дальнейшем.
		Оно работает как внутренний ярлык, поэтому может быть любым.
		Оно не обязательно <em>должно</em> совпадать с официальным названием шрифта,
		но это упрощает интуитивное понимание.
		Как будет показано ниже, стоит оставить название как можно более общим (например,
		Roboto вместо Roboto Light).
</p><p>
    Далее у нас есть свойство src, определяющее путь к файлу .woff через
		нотацию url().
		Путь может быть <a href="iih03-links-and-images.html#absolute-relative-and-root-relative-links">
		абсолютным, относительным или корневым</a>.
		При использовании относительного пути, как в нашем случае, он всегда будет
		относительным к .css-файлу, а не к HTML-документу.
		Нотация format() позволяет браузерам узнать, к какому формату относится файл
		веб-шрифта.
</p><p>
    Перезагрузив страницу web-fonts.html, вы не увидите никаких изменений,
		потому что @font-face предоставил нам <em>доступ</em> только к нашему файлу .woff.
		Нам все еще нужно <em>использовать</em> его где-то еще в нашей таблице стилей.
</p>

<div class="title-under">ИСПОЛЬЗОВАНИЕ ВЕБ-ШРИФТА<br>using a web font</div>
<p>
    В секции <a href="iih04-hello-css.html#defining-fonts">Выбор шрифтов</a> говорилось
		про CSS-свойство font-family, определяющее, какой шрифт используется
		в конкретном HTML-элементе.
		После добавления правила @font-face at-rule мы можем использовать Roboto в
		качестве допустимого значения font-family в любом другом месте нашей таблицы
		стилей.
</p><p>
    Давайте сделаем Roboto Light шрифтом по умолчанию для всего нашего проекта.
		Для этого изменим font-family в селекторе body файла typo.css:
</p><p class="code">
<span class="code-strong">body</span> {<br>
<span class="code-green">font-family</span>: <span class="code-rust">'Roboto'</span>, sans-serif;
<span class="code-grey"> /* Добавьте 'Roboto' сюда */</span><br>
<span class="code-green">font-size</span>: 18px;<br>
<span class="code-green">line-height</span>: 1.8em;<br>
<span class="code-green">color</span>: #5D6063;<br>
}
</p><p>
    Теперь <em>весь текст</em> должен отображаться шрифтом Roboto Light.
		А это значит, что мы потеряли сравнение с системным шрифтом sans-serif в файле
		web-fonts.html.
		Исправим это, добавив <a href="iih04-hello-css.html#page-specific-styles">
		внутренние стили</a> в &lthead> файла web-fonts.html:
</p><p class="code">
<span class="code-blue">&ltstyle></span><br>
<span class="code-blue">.system-fonts</span> {<br>
<span class="code-green">font-family</span>: sans-serif;<br>
}<br>
<span class="code-blue">&lt/style></span>
</p><p>
    Класс .system-fonts применяется ко второму блоку в файле web-fonts.html.
		Вышеуказанное правило имеет приоритет над правилом body в typo.css, поэтому,
		открыв web-fonts.html в браузере, увидим наш Roboto Light сверху и
		стандартный системный шрифт снизу:
</p>

<figure>
<img class="pic-pages" src="./images/iih14-08-custom-web-font-vs-system-font-0aa7bc.863bf7a4.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: страница с веб-шрифтами и системными шрифтами (после добавления
		веб-шрифтов)
</small></figcaption>
</figure>

<div class="title" id="font-families-and-font-faces">
    семейства и начертания шрифтов<br>font families and font faces</div>
<p>
		Одно семейство шрифтов состоит из нескольких шрифтовых "лиц" [faces]*.
		Каждое начертание шрифта имеет в семействе свой вес или стиль.
		"Вес" [weight] это жирность конкретного шрифта, а "стиль" [style] - его начертание:
		романское (вертикальное), курсивное, конденсированное, расширенное или
		какое-либо другое.
</p><p class="notetran">
    * - "лицо" шрифта принято называть <em>начертанием</em>.
</p><p>
    В нашем примере Roboto Light - один из шрифтов семейства Roboto.
		Остальные 17 шрифтов в скачанном ранее ZIP можно представить так:
</p>

<figure>
<img class="pic-pages" src="./images/iih14-09-font-weights-and-styles-9bf7f0.dca801b0.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: Шрифты Roboto - ось X: вес шрифта (100-900), ось Y: его стили
		(roman, italic, condensed)
</small></figcaption>
</figure>

<p>
    В CSS вес шрифта выражается в виде числовых значений от 100 до 900.
		К счастью, для каждого из этих значений существуют стандартные, относительно
		удобные для понимания термины.
		"Черный" обычно означает 900, "полужирный" - 700, "обычный" - 400 и т. д.
		Как показано выше, большинство семейств не поставляют лица для каждого веса.
		В Roboto отсутствуют extra light (200), semi bold (600) и extra bold (800).
</p><p>
    Стоит отметить, что каждая комбинация стиля и веса разработана как совершенно
		отдельное лицо.
		В высококачественном семействе шрифтов конденсированные стили - это не просто
		сжатые версии латинского шрифта, а полужирный шрифт - это не просто более
		"толстая" версия.
		Каждая буква в каждом начертании прорабатана вручную, чтобы обеспечить
		равномерное начертание текста.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-10-roman-versus-italic-a-fe7025.7587de63.png"
width="45%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10: начертание буквы a - романское (вертикальное) в сравнении с курсивным
</small></figcaption>
</figure>

<p>
    Это особенно заметно в курсивных и латинских начертаниях многих шрифтов с
		засечками.
		Например, строчная буква "а" в Century Schoolbook FS (шрифт, который вы сейчас
		читаете) приобретает совершенно другую форму, когда она <em>выделена курсивом</em>.
</p>

<div class="title-under">ПОДДЕЛЫВАНИЕ <br>fakin’ it</div>
<p>
    Почему так важен этот вес и стиль?
		В дизайне обычно используется несколько шрифтов одного семейства,
		поэтому следует знать, как встроить несколько файлов .woff, представляющих
		родственные шрифты.
</p><p>
    Но сначала давайте посмотрим, что происходит, когда мы <em>не предлагаем</em>
		несколько шрифтовых лиц.
		Обновите левый абзац в файле web-fonts.html и добавьте в него элементы &lt;em>
		и &lt;strong>:
</p><p class="code">
<span class="code-blue">&lt;section class=</span> <span class="code-rust">'section section--gray'</span>
<span class="code-blue">></span><br>
<span class="code-blue">&lt;h2></span>Web Fonts<span class="code-blue">&lt;h2></span><br>
<br>
<span class="code-blue">&lt;p></span>This paragraph is using a web font call
<span class="code-blue">&lt;em></span>Roboto Light<span class="code-blue">&lt;/em></span>. It’s a<br>
  little more refined and lends some <span class="code-blue">&lt;strong></span>unique character <span class="code-blue">&lt;/strong></span> to<br>
  the web page.<span class="code-blue">&lt;/p></span><br>
<span class="code-blue">&lt;/section></span>
</p><p>
    Перезагрузив страницу, вы заметите, что полужирный текст на самом
		деле не такой уж и полужирный.
		Это происходит потому, что он <em>синтезируется</em>.
		Мы не указали начертание полужирного шрифта для элемента &lt;strong>, поэтому
		браузер пытается его подделать, автоматически преобразуя Roboto Light в более
		толстое начертание.
		То же самое происходит и с курсивом в элементе &lt;em>, но определить это
		немного сложнее.
		Такое автоматическое преобразование почти всегда приводит к некачественной
		типографике.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-11-synthesized-bold-vs-genuine-bold-363a2f.77e10839.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: синтезированное полужирное начертание в виде чуть более жирного
		текста в сравнении с настоящим полужирным [genuine bold] начертанием в виде
		гораздо более жирного текста
</small></figcaption>
</figure>

<p>
    Чтобы убедиться, что полужирный и курсивный шрифты действительно синтезируются,
		добавьте в typo.css следующее правило.
		Свойство font-synthesis определяет, разрешено ли браузеру подделать его или нет.
		На момент написания этой статьи* только Firefox обращает внимание на font-synthesis,
		поэтому в Chrome или Safari это не сработает:
</p><p class="code">
<span class="code-grey">/*  Это работает только в Firefox  */</span><br>
<span class="code-strong">em, strong</span> {<br>
<span class="code-green">font-synthesis</span>: none;<br>
}
</p><p>
    Откройте файл web-fonts.html в Firefox, и элементы &lt;em> и &lt;strong> перестанут
		быть курсивными или полужирными - весь абзац будет набран латинским шрифтом
		Roboto Light.
</p><p class="notetran">
    * - Данный учебный курс был опубликован в 2017 году.
</p>

<div class="title-under">НЕСКОЛЬКО ШРИФТОВ (НЕПРАВИЛЬНЫЙ ПОДХОД)<br>multiple font faces (the wrong way)</div>
<p>
    Давайте попробуем добавить в наш проект шрифты Roboto Light Italic и Roboto Bold.
		Скопируйте из ZIP-файла Roboto, который мы скачали ранее, в папку web-typography
		следующие файлы:
</p><ul>
<li>roboto_bold_macroman/Roboto-Bold-webfont.woff</li>
<li>roboto_lightitalic_macroman/Roboto-LightItalic-webfont.woff</li>
</ul><p>
    Файл .woff представляет собой шрифтовое лицо одного семейства шрифтов,
		а @font-face позволяет нам внедрить это лицо в таблицу стилей.
<mark>Наивным способом</mark> внедрения этих новых WOFF-файлов было бы простое
    добавление объявлений @font-face и изменение свойства font-family и по мере
		необходимости src.
		Добавьте в верхнюю часть файла typo.css следующее:
</p><p class="code">
/* НЕ НАЗЫВАЙТЕ СЕМЕЙСТВА ШРИФТОВ ТАК */<br>
<span class="code-strong">@font-face</span> {<br>
<span class="code-green">font-family</span>: 'Roboto Light Italic';<br>
<span class="code-green">src</span>: url('Roboto-LightItalic-webfont.woff') format('woff');<br>
}<br>
<br>
<span class="code-strong">@font-face</span> {<br>
<span class="code-green">font-family</span>: 'Roboto Bold';<br>
<span class="code-green">src</span>: url('Roboto-Bold-webfont.woff') format('woff');<br>
}
</p><p>
    Затем, чтобы использовать эти начертания в элементах &lt;em> и &lt;strong>,
		нам понадобятся следующие правила:
</p><p class="code">
/* ЭТО НЕУКЛЮЖИЙ КОД */<br>
<span class="code-strong">em</span> {<br>
<span class="code-green">font-family</span>: 'Roboto Light Italic', serif;<br>
}<br>
<br>
<span class="code-strong">strong</span> {<br>
<span class="code-green">font-family</span>: 'Roboto Bold', serif;<br>
}
</p><p>
    Это <em>будет работать</em>, и теперь при перезагрузке web-fonts.html в
		браузере вы должны увидеть правильные курсивные и полужирные шрифты.
		Проблема в том, что вручную указывать font-family каждый раз, когда мы хотим
		использовать курсивный или полужирный шрифт, как-то странно.
		Для этого следует использовать свойства CSS font-style и font-weight.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-12-at-font-face-multiple-faces-wrong-way-68feb0.1217aa54.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 12: три связанных файла .woff и три несвязанные объявления @font-face
</small></figcaption>
</figure>

<p>
    Мы оказались в этой неуклюжей ситуации из-за того, как именно мы внедрили эти
		новые .woff-файлы.
		Использование отдельных значений font-family в @font-face заставляет их
		выглядеть как совершенно несвязанные начертания шрифтов.
		Хотя на самом деле все они из семейства Roboto.
</p><p>
    По этой причине <strong>никогда не используйте описанную выше технику для
		вставки нескольких начертаний одного семейства шрифтов</strong>.
		Прежде чем двигаться дальше, удалите оба приведенных выше фрагмента.
</p>

<div class="title-under">НЕСКОЛЬКО ШРИФТОВ (ПРАВИЛЬНЫЙ ПОДХОД)<br>multiple font faces (the right way)</div>
<p>
    Чтобы сохранить родственные связи между тремя нашими шрифтами, все они должны
		использовать общее значение Roboto для свойства font-family.
		Чтобы различать светлый*, курсивный и полужирный шрифты, мы добавим в at-правило
		свойства font-style и font-weight.
		Замените все объявления @font-face в typo.css на следующие:
</p><p class="notetran">
    * - слово light из оригинала переводится в MDN по-разному: "светлый"; "сверхлегкий"
</p><p class="code">
<span class="code-strong">@font-face</span> {<br>
<span class="code-green">font-family</span>: 'Roboto';<br>
<span class="code-green">src</span>: url('Roboto-Light-webfont.woff') format('woff');<br>
<span class="code-green">font-style</span>: normal;<br>
<span class="code-green">font-weight</span>: 300;<br>
}<br>
<br>
<span class="code-strong">@font-face</span> {<br>
<span class="code-green">font-family</span>: 'Roboto';<br>
<span class="code-green">src</span>: url('Roboto-LightItalic-webfont.woff') format('woff');<br>
<span class="code-green">font-style</span>: italic;<br>
<span class="code-green">font-weight</span>: 300;<br>
}<br>
<br>
<span class="code-strong">@font-face</span> {<br>
<span class="code-green">font-family</span>: 'Roboto';<br>
<span class="code-green">src</span>: url('Roboto-Bold-webfont.woff') format('woff');<br>
<span class="code-green">font-style</span>: normal;<br>
<span class="code-green">font-weight</span>: 700;<br>
}
</p><p>
    Считайте, что каждое правило @font-face - это описание файла .woff.
		Первое at-правило @font-face гласит, что это шрифт романский (нормальный) Roboto,
		вес шрифта 300 (light - "светлый*").
		Второе гласит, что он также относится к семейству Roboto и имеет вес 300,
		но он курсивный.
		Наконец, третье сообщает браузеру, что Roboto-Bold-webfont.woff
		содержит романический шрифт весом 700 (bold - "полужирный**").
</p><p class="notetran">
    * - кроме "светлый" и "сверхлегкий" light в MDN переводится как "сверхтонкий";<br>
		** - bold вместо ожидаемого "жирный" в MDN переводится как "полужирный".
</p>

<figure>
<img class="pic-pages" src="./images/iih14-13-at-font-face-multiple-faces-8198c0.838fa67e.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 13: связь трех связанных файлов .woff с тремя связанными объявлениями
		@font-face путем указания font-style и font-weight
</small></figcaption>
</figure>

<p>
    Поскольку браузер знает, что наши шрифты связаны, наш CSS становится гораздо
		более интуитивным.
		В селекторе body мы можем задать стандартные семейство и вес шрифта.
		А когда мы захотим использовать курсив или полужирный шрифт для
    какого-либо элемента, можно просто указать font-style или font-weight,
		и браузер извлечет соответствующий файл .woff:
</p><p class="code">
<span class="code-strong">body</span> {<br>
<span class="code-green">font-family</span>: 'Roboto', sans-serif;<br>
<span class="code-green">font-weight</span>: 300;<br>
<span class="code-grey">/* ... */</span><br>
}<br>
<br>
<span class="code-strong">em</span> {<br>
<span class="code-green">font-style</span>: italic;<br>
}<br>
<br>
<span class="code-strong">strong</span> {<br>
<span class="code-green">font-weight</span>: bold;  /* Or 700 */<br>
}
</p><p>
    Значения font-style и font-weight для элементов &lt;em> и &lt;strong> установлены по умолчанию.
		Поэтому нам <em>не нужно</em> включать сюда последние два правила.
		Заметьте, что единственными удобными для человека ключевыми словами для
		font-weight являются normal (400) и bold (700).
		Все другие уровни жирности должны задаваться числами.
</p>


<div class="title">внешнее размещение веб-шрифтов<br>externally hosted web fonts</div>
<p>
    Ладно, все это было сложно.
		Существует способ использования веб-шрифтов попроще: внешнее
		размещение от <a href="https://fonts.google.com">Google Fonts</a>.
		Мы сможем пропустить первые два шага, связанные с локальным размещением.
		Вместо добавления файлов .woff в наш проект и встраивания их с помощью
		@font-face, Google Fonts сделать все это за нас.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-14-locally-vs-externally-hosted-fonts-7bba77.efc60542.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 14: обслуживание веб-шрифтов с собственного веб-сервера и обслуживание
		с сервера Google Fonts
</small></figcaption>
</figure>

<p>
    Сейчас мы будем работать с файлом history.html, поэтому откройте его как в
		текстовом редакторе, так и в веб-браузере.
		Если вы хотите узнать краткую историю типографики, начиная с первого печатного
		станка, прочтите текст примера.
		Сейчас в каждом разделе history.html используется шрифт Roboto Light, но мы
		их изменим, чтобы они соответствовали периоду, о котором пойдет речь.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-15-selecting-a-google-font-3a5534.c4e0d2a8.png"
width="55%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 15: копирование веб-шрифтов &lt;link> из Google Fonts
</small></figcaption>
</figure>

<p>
    Начнем с изменения шрифта для раздела <em>Gothic/Blackletter</em>.
		В <a href="https://fonts.google.com">Google Fonts</a> найдите <strong>
		UnifrakturMaguntia</strong>.
		Он должен быть похож на те, которыми писали монахи в средние века.
		Нажмите кнопку <strong>Select this font</strong>.
		Во всплывающем меню вы увидите элемент &lt;link/>.
		Скопируйте его в &lt;head> файла history.html, над элементом &lt;link/>,
		содержащим нашу таблицу стилей typo.css.
</p><p class="code">
&lt;link href="https://fonts.googleapis.com/css?family=UnifrakturMaguntia" rel="stylesheet">
</p><p>
    Помните, что &lt;link/> <a href="iih04-hello-css.html#linking-a-css-stylesheet">
		подключает внешние таблицы стилей</a>.
		Как раз это и делает приведенный выше HTML.
		Однако вместо ссылки на локальный CSS-файл он включает CSS, определенный
		Google Fonts.
		Если вы вставите значение href в браузер, вы найдете то же самое объявление
		@font-face, которое мы использовали в предыдущем разделе - только на этот
		раз нам не пришлось его прописывать.
		Ура!
</p><p>
    Теперь, когда мы внедрили наш веб-шрифт UnifrakturMaguntia, мы можем использовать
		его для стилизации любого HTML-элемента.
		Добавьте в &lt;head> файла history.html следующее:
</p><p class="code">
<span class="code-blue">&lt;style></span><br>
<span class="code-blue">.blackletter</span> {<br>
<span class="code-green">font-family</span>: 'UnifrakturMaguntia', cursive;<br>
}<br>
<span class="code-blue">&lt;/style></span>
</p><p>
    Первая секция имеет атрибут class='blackletter',
		поэтому теперь она будет напечатана готическим шрифтом:
</p>

<figure>
<img class="pic-pages" src="./images/iih14-16-adding-a-google-font-e4afca.baff68a6.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 16: текст, набранный шрифтом blackletter
</small></figcaption>
</figure>

<p>
    Google Fonts - быстрое и простое решение, но все же профессиональные сайты
		обычно используют локальными веб-шрифтами.
		Это дает гораздо больше возможностей (вы не ограничены ассортиментом Google
		шрифтов) и может повысить производительность/надежность, если оставшаяся часть
		сайта оптимизирована верно.
</p>

<div class="title-under">СЛИШКОМ МНОГО ШРИФТОВЫХ ФАЙЛОВ<br>too many font files</div>
<p>
    Заговорив о производительности, давайте сделаем нечто ужасное.
		На нашей странице history.html есть еще 10 разделов, и мы придадим каждому
		из них свой собственный веб-шрифт.
		Можно внедрить несколько шрифтов в один элемент &lt;link/>.
		Поэтому измените нашу таблицу стилей Google Fonts, включив в нее все остальные:
</p><p class="code">
<mark>
<span class="code-blue">&lt;link<nobr>%20href=</span><span class="code-rust">%22https://fonts.googleapis.com/css%3ffamily=Alfa+Slab+One|Droid+Sans+Mono|Lato|Libre+Baskerville|Lobster|Questrial|Rokkitt|Rufina|Sorts+Mill+Goudy|UnifrakturMaguntia%22</span><nobr>%20<span class="code-blue">rel=</span><span class="code-rust">%22stylesheet%22</span><span class="code-blue">&gt;</span>
</mark>
</p><p>
    Заметим, что это можно сделать в Google Fonts, выбрав несколько шрифтов перед
		копированием элемента &lt;link/>.
		Затем добавьте все эти новые шрифты в элемент &lt;style> файла history.html:
</p><p class="code">
<span class="code-blue">.old-style</span> {<br>
<span class="code-green">font-family</span>: 'Sorts Mill Goudy', serif;<br>
}<br>
<span class="code-blue">.transitional</span> {<br>
<span class="code-green">font-family</span>: 'Libre Baskerville', serif;<br>
}<br>
<span class="code-blue">.didot</span> {<br>
<span class="code-green">font-family</span>: 'Rufina', serif;<br>
}<br>
<span class="code-blue">.slab</span> {<br>
<span class="code-green">font-family</span>: 'Rokkitt', serif;<br>
}<br>
<span class="code-blue">.fat-face {<br>
<span class="code-green">font-family</span>: 'Alfa Slab One', cursive;<br>
}<br>
<span class="code-blue">.grotesque</span> {<br>
<span class="code-green">font-family</span>: 'Roboto', sans-serif;<br>
}<br>
<span class="code-blue">.geometric</span> {<br>
<span class="code-green">font-family</span>: 'Questrial', sans-serif;<br>
}<br>
<span class="code-blue">.humanist</span> {<br>
<span class="code-green">font-family</span>: 'Lato', sans-serif;<br>
}<br>
<span class="code-blue">.display</span> {<br>
<span class="code-green">font-family</span>: 'Lobster', cursive;<br>
}<br>
<span class="code-blue">.monospace</span> {<br>
<span class="code-green">font-family</span>: 'Droid Sans Mono', monospace;<br>
}
</p><p>
    Теперь каждый раздел history.html отображается шрифтом той эпохи, которую
		он описывает.
		Это будет хорошим введением в историческую значимость различных шрифтов.
		Но на практике <strong>никогда не помещайте такое количество веб-шрифтов
		на одну веб-страницу</strong>.
</p><p>
    Помните, что каждый веб-шрифт - это файл .woff или .woff2, который браузер
		должен загрузить, прежде чем отобразить страницу.
		Большее количество шрифтов увеличивает время загрузки.
		Ключ к эффективному использованию веб-шрифтов - баланс между производительностью
		(меньшее количество веб-шрифтов) и красиво набранным документом (большее
		количество веб-шрифтов).
</p><p>
    Вот и все, что вам нужно знать о веб-шрифтах.
		Остальная часть этого урока посвящена основным принципам типографики.
    Это простые рекомендации (с простым CSS), обычно отличающие любительскую
    веб-страницу от профессиональной.
</p>

<div class="title">Отступы в абзацах<br>paragraph indents</div>
<p>
    Отделение абзацев друг от друга - одна из самых фундаментальных функций типографики.
		Есть два общепринятых решения: либо использовать отступ indent первой строки,
<em>либо</em> margin между абзацами.
		Ваши читатели (надеемся) не глупы - им не нужны два признака того, что начинается
		новый абзац, поэтому никогда не используйте <em>одновременно</em> indent* и
		margin.
		Это уже перебор.
</p><p class="notetran">
    * - в русскоязычном MDN слово "отступ" используется для трех различных терминов:
		indent, margin, padding.
		Во избежании путаницы indent я перевожу как "indent" или "indent-отступ".
</p>

<figure>
<img class="pic-pages" src="./images/iih14-17-paragraph-indents-vs-margins-943b17.fedcd281.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 17: indent-отступ первой строки нового абзаца ("ок"), добавление полей между
		абзацами ("ок"), оба варианта - никогда! (never both)
</small></figcaption>
</figure>

<p>
    Свойство CSS text-indent определяет размер отступа первой строки определенного
		элемента (обычно это &lt;p>).
		Мы можем изучить это на нашей странице indents.html.
		Измените существующие margin-стили в первом разделе на indent, добавив
		в элемент &lt;style> следующее:
</p><p class="code">
<span class="code-blue">&lt;style></span><br>
<span class="code-blue">.paragraph-indent</span> <span class="code-strong">p</span> {<br>
<span class="code-green">text-indent</span>: 1em;<br>
<span class="code-green">margin-bottom</span>: 0;<br>
}<br>
<span class="code-blue">.paragraph-indent</span> <span class="code-strong">p</span>:first-of-type {<br>
<span class="code-green">text-indent</span>: 0;<br>
<span class="code-blue">&lt;/style></span>
</p><p>
    Обратите внимание, что первый абзац после заголовка никогда не должен иметь
	  indent, так как обычно очевидно, что это новый абзац.
	  Это очень хороший пример использования <a href="iih06-css-selectors.html#pseudo-classes-for-structure">
		псевдокласса :first-of-type</a>.
</p><p>
    А вот негативный пример, чтобы мы помнили, чего делать не следует.
		Добавьте это в стили конкретной страницы в файле indents.html:
</p><p class="code">
<span class="code-grey">/* ДИЗАЙНЕРЫ ОСУДЯТ ВАС ЗА ЭТО */</span><br>
<span class="code-blue">.never-both</span> <span class="code-strong">p</span> {<br>
<span class="code-green">text-indent</span>: 1em;<br>
<span class="code-green">margin-bottom</span>: 1em;<br>
}
</p><p>
    Это может показаться смешным, но предупреждение о том, что дизайнеры вас
<em>осудят</em>, на самом деле вовсе не шутка.
</p>

<div class="title">выравнивание текста<br>text alignment</div>
<p>
    Выравнивание текста подсознательно влияет на то, как его читают.
		Возможно, вы не замечали ранее, что ваши глаза не двигаются
		плавно по мере чтения - они перескакивают со слова на слово и со
		строки на строку.
		Глаза фиксируются на одних местах и пропускают другие.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-18-fixation-reading-vs-smooth-eye-motions-9c0886.6c6129a9.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 18: текст с точками (вы читаете так) и потоки строк текста
		(так вы НЕ читаете)
</small></figcaption>
</figure>

<p>
    В хорошо спроектированном HTML-документе выравнивание текста не бывает
		случайным.
		Оно учитывает вышеупомянутую особенность человеческой физиологии.
		Правильное выравнивание сильно облегчает пользователям чтение
		вашего текста, поскольку дает их глазам якорь, помогающий перемещаться от
		строки к строке.
</p><p>
    Ниже будет показано, как правильно выравнивать выравнивание текста по левому
		краю, по центру, по правому краю и по обеим краям [justified].
		Все эти примеры основаны на <a href="iih04-hello-css.html#more-text-styles">
		свойстве text-align</a>, которое управляет выравниванием текста определенного
		HTML-элемента.
    В нашем проекте мы создали страницу alignment.html с несколькими сценариями.
</p>

<div class="title-under">ВЫРАВНИВАНИЕ СЛЕВА<br>left alignment</div>
<p>
    Большая часть текста должна быть выровнена слева, потому что это вертикальный
		якорь, к которому читатель может вернуться на каждой строке.
		Длинные фрагменты текста почти всегда выровнены по левому краю.
		Короткие тексты и заголовки имеют немного больше свободы действий.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-19-left-text-alignment-26dbc5.645ac857.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 19: вертикальные точки по левому краю текста служат
		якорями для глаз
</small></figcaption>
</figure>

<p>
    Выравнивание слева - это стандартное значение text-align.
		Но если бы мы хотели быть более выразительными, в элемент &lt;style> нашего
		файла alignment.html можно было бы добавить следующее правило:
</p><p class="code">
<span class="code-blue">&ltstyle></span><br>
<span class="code-blue">.left</span> {<br>
<span class="code-green">text-align</span>: left;<br>
}<br>
<span class="code-blue">&lt/style></span>
</p>

 <p><p>
    Конечно, если вы работаете над сайтом на языке, который пишется справа налево,
		(например, арабский), вы можете поменять все эти советы.
		См. <em>Выравнивание справа</em> ниже.
 </p>

<div class="title-under">ВЫРАВНИВАНИЕ ПО ЦЕНТРУ<br>center alignment</div>
<p>
    Текст, выровненный по центру, не имеет якоря, поэтому на переходах к следующей
		строке глазу легче потеряться.
		Он лучше всего подходит для коротких строк (подробнее об этом позже) и для
		особых видов контента, таких как стихи, тексты песен и заголовки.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-20-center-text-alignment-29e1d3.ff1814b5.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 20: неравномерно расположенные точки на отцентрированном тексте
</small></figcaption>
</figure>

<p>
    Выровняйте по центру второй абзац в файле alignment.html с помощью следующего
		встроенного [page-specific] стиля:
</p><p class="code">
<span class="code-blue">.center</span> {<br>
<span class="code-green">text-align</span>: center;<br>
}
</p><p>
    Обратите внимание, что теперь страница кажется немного разрозненной.
		Второй абзац, выровненный по центру, нарушает течение первого абзаца,
		выровненного слева.
		Вообще, выравнивание текста должно быть одинаковым на всей веб-странице.
		Если отцентрирован один заголовок, отцентрируйте <em>все заголовки</em>.
</p>

<div class="title-under">ВЫРАВНИВАНИЕ СПРАВА<br>right alignment</div>
<p>
    Другой аспект при выборе выравнивания текста - это его связь с окружающими
		элементами.
		Взгляните на третий раздел в файле alignment.html.
		Мы хотим переместить надпись к изображению слева от него и выровнять ее по
		правому краю, чтобы она выглядела как прикрепленная к изображению:
</p>

<figure>
<img class="pic-pages" src="./images/iih14-21-right-aligning-a-caption-cb645b.61e1895a.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 21: картинка и слева от нее выровненный по правому краю текст
</small></figcaption>
</figure>

<p>
    В нашем примере изображение заключено в &lt;figure>, а подпись - в &lt;figcaption>,
		поэтому к вышеуказанному макету приведет добавление в alignment.html, точнее
		в элемент &lt;style>, следующего кода.
</p><p class="code">
<span class="code-strong">figcaption</span> {<br>
<span class="code-green">display</span>: none;<br>
}<br>
<span class="code-strong">@media</span> only screen and (min-width: 900px) {<br>
<span class="code-strong">figure</span> {<br>
<span class="code-green">position</span>: relative;<br>
}<br>
<span class="code-strong">figcaption</span> {<br>
<span class="code-green">display</span>: block;<br>
<br>
<span class="code-green">font-style</span>: italic;<br>
<span class="code-green">text-align</span>: right;<br>
<span class="code-green">background-color</span>: #FFFFFF;<br>
<br>
<span class="code-green">position</span>: absolute;<br>
<span class="code-green">left</span>: -220px;<br>
<span class="code-green">width</span>: 200px;<br>
}<br>
}
</p><p>
    Это также хороший пример <a href="iih09-advanced-positioning.html">продвинутого
		позиционирования</a>.
		Относительное положение &lt;figure> задает систему координат для абсолютного
		позиционирования &lt;figcaption>.
		Сдвинув надпись влево на 220px и задав ей явную ширину 200px, мы получим хороший
		20-пиксельный margin между картинкой и ее надписью.
</p><p>
    Как и центрированный текст, выравнивание cправа следует использовать в особых
		случаях, поскольку неровный левый край затрудняет читателю поиск следующей
		строки.
</p>

<div class="title-under">JUSTIFY-ВЫРАВНИВАНИЕ<br>justified text</div>
<p>
    Justify-выравнивание* создается тонкой регулировкой интервалов между
		словами/буквами и разделения длинных слов дефисами, до тех пор, пока каждая
		строка не станет одинаковой ширины.
		Без хорошего дефисного движка**, justify-выравнивание приводит к большим пробелам
		между словами, затрудняющим глазам горизонтальное перемещение по тексту.
</p><p class="notetran">
    * - русский перевод justify в MDN и Википедии не найден.
    Поэтому здесь и далее используется "justify-выравнивание".
		Смысл: выравнивание левых и правых границ текста по левым и правым границам
		содержимого параграфа.<br>
		** - в оригинале: high-quality hyphenation engine.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-22-good-vs-bad-hyphenation-engine-ba40e3.901599e8.png"
width="65%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 22: bad hyphenation - "плохой дефис" (неравномерные пробелы между
		буквами и словами) и good hyphenation - "хороший дефис" (равномерные пробелы)
</small></figcaption>
</figure>

<p>
    К сожалению, большинство браузеров не имеют <em>вообще никакого</em> встроенного
		дефисного движка, поэтому выравнивания текста в HTML-документах лучше избегать.
	  Для наглядности в наш файл alignment.html добавим еще одно правило:
</p><p class="code">
<span class="code-blue">.justify</span> {<br>
<span class="code-green">text-align</span>: justify;<br>
}
</p><p>
    Сравните это с абзацем, выровненным по левому краю.
		Такой абзац будет выглядеть чуть более равномерно и привлекательно.
</p>

<div class="title">вертикальный интервал текста<br>vertical text spacing</div>
<p>
    Как выравнивание текста, так и вертикальный интервал не является чем-то
		случайным.
		В этом разделе мы рассмотрим грамотное использование трех свойств CSS:
</p><ul>
<li>margin-top (или padding-top)</li>
<li>margin-bottom (или padding-bottom)</li>
<li>line-height</li>
</ul><p>
    Первые два свойства вам уже знакомы.
		Они определяют вертикальный интервал между отдельными абзацами.
		Новое свойство line-height задает интервал между строками <em>в одном абзаце</em>.
		В традиционной типографике высота строки называется leading - "лидирование"*.
		Ранее печатники использовали маленькие полоски свинца для увеличения интервала
		между строками текста.
</p><p class="notetran">
    * - от lead - свинец.
</p><p>
    Вместе эти свойства создают "вертикальный ритм" веб-страницы.
		Существуют различные методы определения "оптимального" вертикального ритма
		для конкретного макета, но общие принципы таковы:
</p><ul>
<li>достаточно пространства чтоб свободно дышалось</li>
<li><em>одинаковые</em> интервалы на всей странице.</li>
</ul><p>
    Чтобы продемонстрировать это, мы разрушим вертикальный ритм во второй половине нашей страницы spacing.html.
		Добавьте следующие встроенные [page-specific] стили в файл spacing.html
</p><p class="code">
<span class="code-blue">&lt;style></span><br>
<span class="code-blue">.messy</span> {<br>
<span class="code-green">line-height</span>: 1.2em;<br>
}<br>
<span class="code-blue">.messy</span> <span class="code-strong">h2</span> {<br>
<span class="code-green">line-height</span>: .9em;<br>
}<br>
<span class="code-blue">.messy</span>:last-of-type {<br>
<span class="code-green">line-height</span>: 1.5em;<br>
}<br>
<span class="code-blue">.messy</span>:last-of-type <span class="code-strong">h2</span> {<br>
<span class="code-green">margin-bottom</span>: .3em;<br>
}<br>
<span class="code-blue">.messy .button</span>:link,<br>
<span class="code-blue">.messy .button</span>:visited {<br>
<span class="code-green">margin-top</span>: 0;<br>
}<br>
<span class="code-blue">&lt;/style></span>
</p><p>
    Несколько небольших изменений высоты строк, padding и margin могут существенно
		повлиять на качество страницы:
</p>

<figure>
<img class="pic-pages" src="./images/iih14-23-vertical-text-spacing-a9d71f.67471267.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 23: сравнение больших, равномерных интервалов с тесными и неравномерными
</small></figcaption>
</figure>

<p>
    В расчете вертикального ритма страницы на удивление много математики и психологии,
		но это работа для вашего дизайнера.
		Как разработчик, вы должны знать свойства CSS, чтобы реализовать то, о чем они просят.
		Важно понимать, что дизайнеры действительно думает об этих вещах.
		Поэтому уделяйте самое пристальное внимание свойствам margin, padding и line-height.
</p>

<div class="title">длина строки<br>line length</div>
<p>
    Если вертикальный интервал вашего текста не является произвольным, не стоит
		удивляться, что и горизонтальный интервал не является таковым.
		Длина строки или "мера" [measure] есть горизонтальная длина вашего текста.
		Это количество символов или слов, помещающихся в одну строку.
		Мера связана со следующими свойствами CSS:
</p><ul>
<li>width</li>
<li>margin-left (или padding-left)</li>
<li>margin-right (или padding-right)</li>
</ul><p>
    Хорошим правилом является ограничение количества символов до 80 на строку.
		Как и выравнивание, это неявно влияет на читабельность вашего контента.
		Для перемещения от левого края абзаца к правому, глазу нужна энергия.
		Чем дальше ему приходится сканировать, тем быстрее он устает.
		Возврашение к началу следующей длинной строки напрягает.
		В длинных строках легко заблудиться.
</p>

<figure>
<img class="pic-pages" src="./images/iih14-24-line-length-measure-ce052b.0380b0d3.png"
width="65%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 24: длина строки как ширина абзаца
</small></figcaption>
</figure>

<p>
    Именно поэтому многие сайты (включая и этот) используют <a href="iih10-responsive-design.html#few-notes-on-design">
		макеты фиксированной ширины</a> или на более широких экранах разбивают
		контент на несколько колонок.
		Без ограничения ширины страницы или разделения на колонки длина строки
		становится невыносимо большой.
</p><p>
    В нашем примере файл line-length.html имеет приемлемую меру.
		Давайте посмотрим, что произойдет, если мы разобьем нижнюю половину страницы,
		добавив в ее &lt;head> следующее:
</p><p class="code">
<span class="code-blue">&lt;style></span><br>
<span class="code-strong">@media</span> only screen and (min-width: 580px) {<br>
<span class="code-blue">.not-so-manageable</span> {<br>
<span class="code-green">max-width</span>: 100%;<br>
<span class="code-green">margin-left</span>: 2em;<br>
<span class="code-green">margin-right</span>: 2em;<br>
}<br>
}<br>
<span class="code-blue">&lt;/style></span>
</p><p>
    Теперь вторая секция растягивается на всю ширину окна браузера.
		Из-за большой длины строки это несколько неудобно для восприятия.
		Повторимся, цель хорошей веб-типографики - сделать так, чтобы посетителям
		было как можно легче воспринимать ваш контент.
</p>

<div class="title">дополнительные рекомендации<br>
    по типографике<br>other basic typography guidelines</div>
<p>
    Вышесказанного должно быть достаточно, чтобы вы начали свой путь к
		качественной веб-типографике.
		Типографика это целая индустрия и мы едва коснулись ее поверхности.
		Эта тема относится скорее к дизайну, чем к веб-разработке, поэтому мы просто
		дадим несколько финальных рекомендаций:
</p><ul>
<li>Для элемента body используйте размер шрифта от 14px до 20px.</li>
<li>Используйте "двойные кавычки" &amp;rdquo;, &amp;ldquo; и "одинарные"
	  кавычки &amp;rsquo;, &amp;lsquo; посредством HTML-<a href="iih03-links-and-images.html#entities">
	  сущностей</a>.</li>
<li>Используйте правильные тире (&amp;ndash;, &amp;mdash;) и другие символы (&amp;copy;).</li>
<li>Не используйте text-decoration: underline (кроме случаев hover).</li>
<li>Используйте <em>настоящие</em> курсивные шрифты вместо синтезированных,
	  если они не перегружают производительность.</li>
</ul><p>
    Если вам нравятся такие вещи, то в <a href="http://practicaltypography.com/summary-of-key-rules.html">
		Practical Typography</a> есть фантастический список общих правил для верстки
		документов.
</p>

<div class="title">РЕЗЮМЕ</div>
<p>
    Цель этого урока была двоякой:
</p><ul>
<li>Изучить механику веб-шрифтов и основные свойства типографики CSS.</li>
<li>Понять, как дизайнеры относятся к типографике.</li>
</ul><p>
    Возможно, по окончании этого урока вы не сможете с нуля создать роскошно
		набранную веб-страницу, но это и не важно.
		Его цель была <em>познакомить</em> вас с невидимым искусством типографики.
		Теперь у вас есть словарный запас, чтобы говорить о таких вещах, как
		семейства шрифтов, начертания, вес и стили, а также лидирование, мера и
		вертикальный ритм.
</p><p>
    Ключевая мысль этого урока - на хорошо сверстанной веб-странице нет ничего
		случайного.
		Размер шрифта, стиль отступов, выравнивание текста, высота строки,
		margins и все мельчайшие детали страницы были тщательно продуманы.
		За всеми этими решениями стоит некий <em>замысел</em>.
</p><p>
    Все рассмотренные в данном учебнике свойства CSS, на самом деле очень просты.
		По сути, мы просто перемещали кучу квадратиков, меняли цвета и изменяли
		внешний вид текста.
<em>Смысл</em> этих действий зависит от дизайна и бизнес-целей сайта, который вы
	  создаете.
</p><p>
	  Хотите верьте, хотите нет, но вы подошли к концу нашего учебника <a href="/">
		HTML & CSS is Hard</a>.
		Мы рассмотрели все элементы HTML и свойства CSS, необходимые для создания
		профессиональных веб-страниц.
		Единственное, чего не хватает, - это опыта.
		Ваш следующий шаг - отработать все эти новые навыки, создав несколько
		веб-страниц с нуля.
</p><p>
    Ждите следующие учебники!
</p>

<h1><a href="/" title="RUS EDITION of Interneting is Hard">HTML & CSS IS HARD - НА РУССКОМ</a></h1>
<p><em>
    ИТ-терминология самого простого и понятного учебника веб-разработки
</em></p>

<h2>ГЛОССАРИЙ К УЧЕБНИКУ HTML & CSS IS HARD</h2>
<p><small>Updated 10.04.2024</small></p>
<hr>
<p>ПРИМЕЧАНИЯ<br>
<small>
    Стандарты перевода согласно MDN - <a href="https://developer.mozilla.org/en-US/docs/Glossary">
		Mozilla Developers Network</a>.
		Второй источник русскоязычных терминов - Wikipedia.
</small>
</p><p><small>
    Когда перевод состоит из нескольких слов, используем сначала первое, при
		повторении можно взять второе, при очередном повторении берем тогда уже третье.
		Пример: <strong>content</strong> - 1)контент, 2)содержание, 3)содержимое;
</small>
</p><p>
<small>
    JS code terms are <mark>marked yellow</mark>.
		Пример: <strong>content</strong> - 1)контент, 2)содержание, 3)содержимое;
</small></p>

<p>СОКРАЩЕНИЯ<br>
	 англ. - английский<br>
	 см. - смотри<br>
	 тж. - также
	 ex. - пример(ы), например
</p>
<br><br>
<!--
<dt id="">ABH</dt>
<dd> – s. <a href="gloss.html#abh">Ausländerbehörde</a></dd>

<dt id="">Abmeldung</dt>
<dd> – deregistration of your residence in Germany</dd>

<dt id=""></dt>
<dd> – s. <a href="gloss.html#abh">Ausländerbehörde</a></dd>

<dt id=""></dt>
<dd> – </dd>

accessibility
<strong></strong> - ;<br>
<strong></strong> - ;<br>
<strong></strong> - ;<br>
<strong></strong> - ;<br>
<strong></strong> - ;<br>
<strong></strong> - ;<br>
<strong></strong> - ;<br>
<strong></strong> - ;<br>
<strong></strong> - ;<br>
<strong></strong> - ;<br>
<strong>block .....</strong> - <a href="">блок объявлений</a>;<br>
-->

<p>
<strong>absolut and flexible sizes</strong> - фиксированные и гибкие размеры;<br>
<strong>accessibility</strong> - доступность;<br>
<strong>advanced</strong> - продвинутый;<br>
<strong>advisory information</strong> - консультативная информация;<br>
<strong>alignment</strong> - выравнивание;<br>
<strong>alignment >> alignment control</strong> - управление выравниванием;<br>
<strong>alignment >> alignment features</strong> - механизм выравнивания;<br>
<strong>alignment >> text alignment</strong> - выравнивание текста;<br>
<strong>annotation</strong> - аннотация;<br>
<strong>appropriate</strong> - подходящий;<br>
<strong>arbitrary number</strong> - произвольное число;<br>
<strong>arbitrary number >> arbitrary number of other child elements</strong> -
произвольное число других дочерних элементов;<br>
<strong>ARIA role</strong> - ARIA-роль, ARIA-роли;<br>
<strong>art direction</strong> - художественное оформление;<br>
<strong>art direction problem</strong> - часто без перевода или: <a href="https://developer.mozilla.org/ru/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">
	проблема художественного оформления</a>;<br>
<strong>ascending counter</strong> - возрастающий счетчик;<br>
<strong>aside</strong> - отступление, элемент &lt;aside&gt;;<br>
<strong>assuming it is...</strong> - при условии, что...<br>
<strong>at-rules, @-rules</strong> - at-правила, @-правила. Это CSS операторы, которые
	показывают CSS как себя вести;<br>
<strong>attribute selector</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Attribute_selectors">
	селектор атрибутов</a>;<br>
<strong>auto-margin</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/margin-left">
	auto отступ</a>;<br>
<strong>axis</strong> - ось. <small>Main and cross axis - главная и поперечная оси;</small><br>
<strong>backend</strong> - бэкенд;<br>
<strong>base color</strong> - основной цвет;<br>
<strong>basic example</strong> - базовый пример;<br>
<strong>basic sections of a document</strong> - основные составляющие документа;<br>
<strong>blank line</strong> - пустая строка;<br>
<strong>block of CSS</strong> - CSS блок;<br>
<strong>blur radius</strong> - радиус размытия;<br>
<strong>boolean attribute</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Boolean">
	 аттрибут булева типа</a>;<br>
<strong>box</strong> - блок или бокс (оба понятия встречаются в MDN. <small><a href="https://developer.mozilla.org/ru/docs/Web/CSS/display">
	 прямоугольная область, являющаяся изображением элемента</a></small>;<br>
<strong>box model</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model">
	 блоковая модель</a>, блочная модель, боксовая модель;<br>
<strong>block</strong> - блок, тж. см. box;<br>
<strong>block box</strong> - блоковый блок;<br>
<strong>block-level behavior</strong> - блоковое поведение;<br>
<strong>block scope</strong> - s. scope;<br>
<strong>block statement</strong> also: compound statement - <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/block">
блок инструкций</a> (или сложная инструкция в других языках);<br>
<strong>body</strong> - тело, элемент body;<br>
<strong>boolean </strong> - <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Boolean">
	 Boolean атрибут, булев атрибут</a>, булевский атрибут;<br>
<strong>border</strong> - рамка или границы. Сплошная линия, которая расположена рядом с внешним
	 отступом (padding);<br>
<strong>border area</strong> - область рамки;<br>
<strong>border edge</strong> - края рамки;<br>
<strong>break</strong> - разрыв;<br>
<strong>break >> create a break at that location</strong> - создать разрыв в этом месте;<br>
<strong>break onto a new line</strong> - начинать(ся) с новой строки;<br>
<strong>breakpoint</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/debugger">
	 точка останова</a>, брейкпоинт;<br>
<strong>breakpoint >> setting a breakpoint</strong> - установка точек останова;<br>
<strong>bullet, bullet point</strong> - маркер в виде круга, "пулька";<br>
<strong>bulleted list</strong> - маркированный список;<br>
<strong>callback function</strong> - колбэк-функция;<br>
<strong>canvas scripting API</strong> - отрисовка графики при помощи скриптов (обычно используется JavaScript);<br>
<strong>capability</strong> - возможность;<br>
<strong>caption</strong> - подпись (обычно под изображением, диаграммой, фото и т.п.);<br>
<strong>carriage-return</strong> - возврат каретки;<br>
<strong>cascade</strong> - каскадность;<br>
<strong>cascade >> Cascading Style Sheets</strong> - Каскадные Таблицы Стилей;<br>
<strong>case-sensitive</strong> - чувствительны к регистру;<br>
<strong>case > in lower case</strong> - в нижнем регистре;<br>
<strong>casing</strong> - регистр;<br>
<strong>caveat</strong> - оговорка;<br>
<strong>cell</strong> - ячейка;<br>
<strong>сentering the image</strong> - Центрирование изображения;<br>
<strong>character</strong> - символ;<br>
<strong>character attribut</strong> - символьный атрибут (ex: type);<br>
<strong>character set</strong> - стандарт кодировки символов, кодировка символов;<br>
<strong>checkbox</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/Accessibility/ARIA/Roles/checkbox_role">
	 чекбокс</a>;<br>
<strong>child >> first child</strong> - первый дочерний (элемент);<br>
<strong>citation metadata</strong> - метаданные цитирования;<br>
<strong>class selectors</strong> - селекторы по классу;<br>
<strong>click</strong> - щелчок;<br>
<strong>code units</strong> - кодовые значения;<br>
<strong>collapse</strong> - схлопывание;<br>
<strong>collapse >> margin collaps</strong> - схлопывание margin, <a href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_box_model/Mastering_margin_collapsing">
	 схлопывание внешних отступов</a>;<br>
<strong>сolumn</strong> - колонка;<br>
<strong>сolumn >> main content column</strong> - колонка основного содержимого;<br>
<strong>columns and rows</strong> (in <a href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout">
	 Grid Layout</a>) - колонки и строки;<br>
<strong>сollapse</strong> - объединение в одно;<br>
<strong>combinator</strong> - комбинатор;<br>
<strong>combinator >> descendant combinator</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Descendant_combinator">
	Комбинатор " " (пробел)</a> ;<br>
<strong>combinator >> <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Child_combinator">
	 child combinator (>)</a></strong> - комбинатор >. <small>Разделяет 2 селектора,
	 находит элементы заданные вторым селектором, являющие прямыми потомками для
	 элементов отобранных первым селектором.</small>;<br>
<strong>complex</strong> - сложный;<br>
<strong>compliant</strong> - совместимые;<br>
<strong>comprehension</strong> - понятие;<br>
<strong>comprehension >> Fundamental layout comprehension</strong> - Фундаментальное
	 понятие вёрстки;<br>
<strong>consecutive</strong> -последовательные, идущие подряд, идущие друг за другом;<br>
<strong>container</strong> - контейнер;<br>
<strong>content</strong> - контент, содержание, содержимое документа  или страницы;<br>
<strong>content >> content area</strong> - внутренняя область элемента;<br>
<strong>content >> end content</strong> - конечный контент (содержимое в футере);<br>
<strong>content >> introductory content</strong> - вводный контент, вводное содержимое;<br>
<strong>content >> main content</strong> - основное содержимое;<br>
<strong>content >> media content</strong> - медиа-контент;<br>
<strong>content >> phrasing content</strong> - фразовый контент;<br>
<strong>content >> self-contained content</strong> - самостоятельный контент;<br>
<strong>content(-box) width</strong> -  ширина контента;<br>
<strong>content(-box) height</strong> - высота контента;<br>
<strong>content items</strong> - элементы контента;<br>
<strong>control flow statements</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/block">
    операторы управления потоком</a> Ex. if...else and for.;<br>
<strong>control of overlapping content</strong> - управление перекрывающимся контентом;<br>
<strong>current element</strong> - текущий элемент;<br>
<strong>conditional processing</strong> - условная обработка;<br>
<strong>contextual menue</strong> - контекстное меню;<br>
<strong>consistently</strong> - последовательно;<br>
<strong>controls</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/Forms/User_input_methods">
	 управление</a>;<br>
<strong>core</strong> - ядро;<br>
<strong>crafting</strong> - создание;<br>
<mark><strong>Event reference</strong></mark> - <a href="https://developer.mozilla.org/ru/docs/Web/Events">
	справочник по событиям</a>;<br>
<strong>dealing with files</strong> - работа с файлами;<br>
<strong>debugger >> invoke a debugger </strong> - <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/debugger">
	вызвать функциональность отладки</a>;<br>
<strong>debugging</strong> - отладка;<br>
<strong>declaration</strong> - использование; декларация #mdn; объявление (in CSS) #wiki;<br>
<strong>declaration >> function declaration</strong> - использование функции;
<small>Variables declared with var = Переменные, объявленные через var</small><br>
<strong>declaration block</strong> - блок деклараций, блок объявлений;<br>
<strong>dedicated tags</strong> - выделенные теги;<br>
<strong>definition list</strong> - список определений;<br>
<strong>define >> in which it was defined</strong> - в котором оно было определено;<br>
<strong>delete</strong> - удалять;<br>
<strong>demarcating edits</strong> - разграничительные правки;<br>
<strong>deprecated, but kept for compatibility purposes</strong> - устарели, но сохранены в целях совместимости;<br>
<strong>descendants of this element</strong> - потомки данного элемента;<br>
<strong>descendant selector</strong> - селектор потомков;<br>
<strong>descriptor</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">
	дескриптор;<br>
<strong>descriptor >> data d./accessor d.</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#descriptor">
	дескриптор данных/дескриптор доступа</a>;<br>
<strong>desktop</strong> - насто́льный (стациона́рный) компью́тер, ПК, дескто́п #wiki;<br>
<strong>diff</strong> - разница, различие;<br>
<strong>diff >> source code diff information</strong> - информация о различиях в исходном коде;<br>
<strong>display type</strong> - тип отображения (элемента);<br>
<strong>distributing</strong> - распределение;<br>
<strong>drag</strong> - перетаскивать;<br>
<strong>draw</strong> - отрисовывать;<br>
<strong>draw >> draw graphics and animations</strong> - отрисовка графиков и анимации;<br>
<strong>editor's note</strong> -примечание редактора;<br>
<strong>effect</strong> - влияние;<br>
<strong>effect >> have no effect on some elements </strong> - не оказывать влияния на
   некоторые элементы;<br>
<strong>embed</strong> - встроенный;<br>
<strong>embed >> embed sound content</strong> - встроенный звуковой контент;<br>
<strong>empty string value</strong> - значение "пустая строка", указывает, что элемент
   должен быть редактируемым;<br>
<strong>encoding >> UTF-16 e.</strong> - встроенный;<br>
<strong>ensuring accessibility</strong> - обеспечение (улучшение) доступности;<br>
<strong>entity, HTML entities</strong> - сущность, HTML-сущности;<br>
<strong>entity >> memorable entities</strong> - запоминающиеся сущности (мнемоники).
   Напр. &amp;copy; для символа копирайта (©);<br>
<strong>enumerated attribute</strong> - логический атрибут;<br>
<strong>environments</strong> - среды;<br>
<strong>event handler</strong> - обработчики событий;<br>
<strong>explicit</strong> - явный, четко выраженный;<br>
<strong>external application</strong> - внешнее приложение;<br>
<strong>external resource</strong> - внешний ресурс;<br>
<strong>face, font face</strong> - начертание, начертание шрифта. Тж. см. value в типографике;<br>
<strong>favicon</strong> - иконка в стиле "favicon";<br>
<strong>feature</strong> - функция; особенность;<br>
<strong>feature >> range feature</strong> - функция диапазона;<br>
<strong>figure</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/figure">
	иллюстрация</a>;<br>
<strong>file structure</strong> - файловая структура;<br>
<strong>fixed width</strong> - фиксированная ширина;<br>
<strong>fixed width layout</strong> - макет фиксированной ширины;<br>
<strong>flavor</strong> - тип, вид;<br>
<strong>flavor >> two main flavors</strong> - два основных типа;<br>
<strong>flexbox</strong> - технология <a href="https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Flexbox">
	flexbox</a> (инструмент CSS-верстки);<br>
<strong>flex container</strong> - flex контейнер;<br>
<strong>flex element</strong> - flex элемент (дочерний элемент flex контейнера);<br>
<strong>flex item</strong> - см. flex element;<br>
<strong>flexible box</strong> - flex блок;<br>
<strong>float</strong> - в CSS: 1) обтекание, 2) свойство <a href="https://developer.mozilla.org/ru/docs/Web/CSS/float">
	float</a>, 3) плавающий (напр. плавающий элемент) <small>Изначально созданное для плавающих изображений внутри
	текстовых блоков, свойство float стало одним из наиболее часто используемых
	инструментов для создания мульти-колоночной вёрстки веб-страниц.</small>;<br>
<strong>float element</strong> - плавающий элемент;<br>
<strong>flow >> normal flow</strong> - нормальный поток;<br>
<strong>flow content</strong> - потоковый контент;<br>
<strong>flow layout</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_flow_layout">
	схема потока</a>, <a href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_flow_layout">
	поточная раскладка</a>;<br>
<strong>fluid</strong> - жидкий;<br>
<strong>fluid layout / website</strong> - жидкий макет / <a href="https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Responsive_Design">
		 жидкий сайт</a>;<br>
<strong>font</strong> - шрифт;<br>
<strong>font > custom font</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/CSS/Styling_text/Web_fonts#веб-шрифты">
	собственный шрифт</a>;<br>
<strong>font > downloadable font</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/@font-face">
	загружаемый шрифт</a>;<br>
<strong>font > locally hosted font</strong> - локальный шрифт;<br>
<strong>font > web safe font</strong> - безопасные веб-шрифты;<br>
<strong>font file(s)</strong> - файл(ы) шрифтов;<br>
<strong>font-size</strong> - размер шрифта;<br>
<strong>font stack</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/CSS/Styling_text/Web_fonts">
стек шрифта</a>;<br>
<strong>font-weight</strong> - начертание шрифта;<br>
<strong>footer</strong> - нижний колонтитул (футер), "подвал";<br>
<strong>fr</strong> - блок fr - блок фракции (fraction) - единица для макета сетки;<br>
<strong>frontend</strong> - фронтенд;<br>
<strong>full bleed</strong> - polygr.	без полей, без рамки по краям; (о фотографиях,
	графических материалах – напр., full bleed image;<br>
<strong>full-bleed layout</strong> - макет (вебстраницы) без рамки по краям;<br>
<strong>gap</strong> - разрыв;<br>
<strong>generic container</strong> - универсальный контейнер;<br>
<strong>generic container</strong> - таблица стилей (как правило, CSS) слово "global" в MDN
	и в русскоязычной википедии при переводе опускается;<br>
<strong>global attribute</strong> - глобальный атрибут;<br>
<strong>glossary entries</strong> - словарь;<br>
<strong>grapheme</strong> - графема;<br>
<strong>grid</strong> - сетка или <a href="https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Grids">
	грид</a>;<br>
<strong>grid >> CSS Grid Layout</strong> - макет сетки или CSS <a href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout">
	грид-раскладка</a> (двумерная система вёрстки). <small>
	Она позволяет вам размещать контент в строках и столбцах и имеет множество
	возможностей, которые упрощают построение сложных макетов</small>;<br>
<strong>grid inspector</strong> - <a href="https://firefox-source-docs.mozilla.org/devtools-user/page_inspector/how_to/examine_grid_layouts/index.html">
	грид-инспектор (en-US)</a>;<br>
<strong>guides</strong> - руководство;<br>
<strong>handle</strong> - обрабатывать;<br>
<strong>handle >> automatically handle subtitles</strong> - автоматически обрабатывать субтитры;<br>
<strong>hash</strong> - хеш, символ решетки (#);<br>

<strong>header</strong> - шапка,  элемент метаданных (header element), хидер, заголовок
	(колонтитул) <small>большая полоса вверху страницы, с крупным заголовком и/или
	логотипом.
	Здесь указывается общая информация о веб-сайте, одинаковая для всех страниц.
</small>;<br>
<strong>header >> global h., specific h.</strong> - глобальный заголовок, конкретный з.;<br>
<strong>heading</strong> - ??????;<br>
<strong>homepage</strong> - домашняя страница;<br>

<strong>horizontal rule</strong> - горизонтальный разделитель; горизонтальная прямая;<br>
<strong>hook up</strong> - подключать. <small>stylesheet is hooked up to our HTML page
	 = таблица стилей подключена к HTML-страницам.;</small><br>
<strong>&lt;hr&gt; thematic break element</strong> - горизонтальный разделитель,
	(для тематического изменения текста) <small>напр. изменение темы или сцены
</small>;<br>
<strong>hyperlink</strong> - гипертекстовая ссылка;<br>
<strong>hyphen</strong> - дефис;<br>
<strong>identifier (ID)</strong> - идентификатор (ID);<br>
<strong>image</strong> - изображение, картинка;<br>
<strong>implicit</strong> - неявный;<br>
<strong>image map (a clickable link area)</strong> - карта изображения (интерактивная область ссылок);<br>
<strong>imaginative</strong> - творчески;<br>
<strong>index</strong> - оглавление якорных ссылок;<br>
<strong>indent</strong> - отступ, пустое место;<br>
<strong>information architecture</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/HTML/Introduction_to_HTML/Document_and_website_structure">
	планирование содержания всего веб-сайта</a>;<br>
<strong>inherent</strong> - собственная, естественная, присущая, оригинальная;<br>
<strong>inline</strong> - строковый, строчный;<br>
<strong>inline box</strong> - inline-блок, строковый блок;<br>
<strong>inline element</strong> - строчный элемент;<br>
<strong>inline >> inline display type</strong> - inline (строчный) тип отображения;<br>
<strong>inline >> generic inline container</strong> - основной строковый контейнер;<br>
<strong>innate property</strong> - врожденное свойство;<br>
<strong>inner display type</strong> - внутренний тип отображения;<br>
<strong>input value</strong> - входное значение;<br>
<strong>instance</strong> - экземпляр;<br>
<strong>instance >> every valid MathML instance</strong> - каждый допустимый экземпляр MathML;<br>
<strong>interface</strong> - интерфейс;<br>
<strong>invalid type</strong> - неверный тип;<br>
<strong>italicized type</strong> - курсив;<br>
<strong>item placement</strong> - расположение элемента;<br>
<strong>justify</strong> - выравнивание левых и правых границ текста по левым и правым границам
	содержимого параграфа;<br>
<strong>keyword colors</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/color_value#ключевые_цвета">ключевые цвета</a>;<br>
<strong>label</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/option">
	метка, ярлык</a> >;<br>
<strong>layout</strong> - разметка (напр. web page layout = разметка вебстраницы);
	тж. раскладка (напр. клавиатуры);<br>
<strong>layout (CSS)</strong> - верстка (напр. в CSS); макет (page layout = макет страницы);
	схема (s. flow layout);<br>
<strong>layout >> CSS layout</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout">
	CSS-макет</a>;<br>
<strong>layout >> Grid layout</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/justify-content">
		Grid размещение</a>;<br>
<strong>layout shifter</strong> - "перевертыш" (перевод в MDN, Wiki не найден);<br>
<strong>layout >> multiple-column layout</strong> - мульти-колоночная вёрстка;<br>
<strong>legacy layout methods</strong> - устаревшие методы вёрстки;<br>
<strong>legend</strong> - легенда;<br>
<strong>light</strong> - сверхлегкий, см. value в типографике;<br>
<strong>light > lighter</strong> - значение "светлее" в типографике;<br>
<strong>&lt;li&gt; list item element</strong> - элемент для создания элементов списка;<br>
<strong>integer attribute</strong> - числовой атрибут (ex.: value);<br>
<strong>line</strong> - строка;<br>
<strong>line >> break a line</strong> - разбить строку;<br>
<strong>line break &lt;br&gt;</strong> - элемент "перенос строки";<br>
<strong>line break in text</strong> - перенос строки в тексте;<br>
<strong>line >> new lines</strong> - новые строки;<br>
<strong>link</strong> - ссылка, тж. гиперссылка;<br>
<strong>link >> relativ link</strong> - относительная ссылка;<br>
<strong>link >> root-relativ link</strong> - <mark>корневая ссылка????</mark>;<br>
<strong>linking</strong> - подключение, напр. таблицы CSS;<br>
<strong>list of zero or more statements</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/block">
    группировка нуля или более инструкций</a>;<br>
<strong>log</strong> v. - выводить(ся); <small>This logs 2 because = Здесь выводится "2" потому что...</small><br>
<strong>machine-readable translation</strong> - машиночитаемое представление;<br>
<strong>main-axis</strong> - главная ось (напр. flex контейнера);<br>
<strong>main page</strong> - главная страница;<br>
<strong>maintain</strong> - обслуживать, обслуживание (напр. вебсайта);<br>
<strong>margin</strong> - внешний отступ тж. внешние отступы - пространство вокруг внешней стороны элемента;<br>
<strong>margin area</strong> - отступы. <small>добавляют пустое пространство вокруг элемента
	и определяют расстояние до соседних элементов</small>;<br>
<strong>margin-bottom</strong> - нижний отступ;<br>
<strong>margin-top</strong> - верхний отступ;<br>
<strong>markup</strong> - разметка, прежде всего HTML-разметка;<br>
<strong>markup >> markup language</strong> - язык разметки;<br>
<strong>media element</strong> - медиа-элемент;<br>
<strong>media-feature</strong> - медиафункция;<br>
<strong>media queries</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_media_queries/Using_media_queries">
	 медиавыражения</a>;<br>
<strong>@media at-rule</strong> - at-правило @media;<br>
<strong>@media CSS at-rule</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/@media">
	 At-правило @media в CSS</a>;<br>
<strong>metadata</strong> - метаданные;<br>
<strong>micro data</strong> - микроданные;<br>
<strong>mockup</strong> - эскиз;<br>
<strong>mode</strong> - режим;<br>
<strong>mode >> display mode</strong> - режим отображения;<br>
<strong>monospace font</strong> - моноширинный шрифт;<br>
<strong>multimedia resources</strong> - мультимедийные ресурсы (изображения, аудио и видео);<br>
<strong>naming conventions</strong> - стандарты наименования файлов;<br>
<strong>navigation bar</strong> - навигационное меню;<br>
<strong>navigational aids</strong> - ссылки навигации;<br>
<strong>negative value</strong> - отрицательное число;<br>
<strong>node</strong> - узел;<br>
<strong>node >> node tree</strong> - древо узлов;<br>
<strong>non-visual browsers</strong> - невизуальные браузеры;<br>
<strong>not common to every page content</strong> - уникальный для каждой страницы контент;<br>
<strong>non-replaced element</strong> - незаменяемый элемент;<br>
<strong>notation</strong> - нотация;<br>
<strong>object model >> CSS object model</strong> - объектная модель CSS;<br>
<strong>offset</strong> - смещение, напр. горизонтальное, вертикальное; пересекать ?????<br>
<strong>omit it from rendering</strong> - пропустить его при <a href="https://developer.mozilla.org/en-US/docs/Glossary/Rendering_engine">
   рендеринге</a>;<br>
<strong>outline</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/outline">
	обводка</a>;<br>
<strong>operator</strong> - оператор - <small>см. <a href="">статью в MDN</a> про JS-операторы
	присваивания, сравнения, арифметические, битовые, логические, строчные, и
	различные специальные операторы;</small><br>
<strong>overflow</strong> - переполнение; свойство <a href="https://developer.mozilla.org/ru/docs/Web/CSS/overflow">
	overflow</a>;<br>
<strong>override</strong> - переопределять;<br>
<strong>padding</strong> - внутренний отступ или внутренние поля - пространство внутри рамки и в то же время
	вокруг контента (например,вокруг абзаца текста);<br>
<strong>padding area</strong> - область отступов или поля элемента.
	Пустая область, окружающая контент;<br>
<strong>padding edge</strong> - края полей;<br>
<strong>padding >> thickness of the padding</strong> - размеры полей;<br>
<strong>pane</strong> - панель;<br>
<strong>parse</strong> - парсить;<br>
<strong>parser</strong> - парсер;<br>
<strong>parsing</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/API/DOMParser">
	парсинг</a>;<br>
<strong>path</strong> - путь;<br>
<strong>people with visual impairments</strong> - люди с нарушениями зрения;<br>
<strong>permitted content</strong> - допустимое содержимое;<br>
<strong>platform convention</strong> - платформа;<br>
<strong>platform convention >> defined by the platform convention</strong> - определяется платформой;<br>
<strong>plug-in</strong> - плагин;<br>
<strong>plug-in >> browser plug-in</strong> - плагин для браузера;<br>
<strong>position</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/position">
	позиционирование</a>. Тж. см. positioning;<br>
<strong>positioning</strong> - позиционирование. П. позволяет брать элементы из нормального
	потока и изменять их поведение, например, заставляет находиться друг под
	другом или всегда оставаться в одном и том же месте внутри окна просмотра браузера;<br>
<strong>positioning >> relative p., absolut p., fixed, sticky p.</strong> - позиционирование
	относительное, абсолютное, фиксированное??????, липкое;<br>
<strong>preceding term</strong> - предшествующий термин;<br>
<strong>preformatted text предварительно</strong> - отформатированный текст;<br>
<strong>prerequisites</strong> - необходимые условия;<br>
<strong>presentation</strong> - внешний вид #wiki;<br>
<strong>property</strong> - свойство, напр. margin или color (in CSS);<br>
<strong>property value</strong> - значение свойства (напр. red для свойства color (in CSS);<br>
<strong>radio button</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Element/input/radio">
	радиокнопка</a> (переключатель);<br>
<strong>range of text</strong> - диапазон текста;<br>
<strong>related links</strong> - связанные ссылки;<br>
<strong>render</strong> - отображаться, отрисовываться, рендериться.
	Ex. not rendered = не отображается;<br>
<strong>repository</strong> - репозиторий, напр. репозиторий Github;<br>
<strong>resetting</strong> - сброс;<br>
<strong>respected</strong> - применяются;<br>
<small>the width and height properties are respected = будут применяться
	 свойства width и height.
</small>;<br>
<strong>responsive web design (RWD)</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Responsive_Design">
	отзывчивый (адаптивный) веб-дизайн</a>;<br>
<strong>responsive images</strong> - адаптивные изображения;<br>
<strong>root element</strong> - корневой элемент;<br>
<strong>root of the hard drive</strong> - корень жесткого диска;<br>
<strong>root-relativ link</strong> - корневая ссылка;<br>
<strong>rule</strong> - правило (не только в грамматике, но и в кодировании);<br>
<strong>selector</strong> also: <strong>element selector, tag selector, type selector</strong> - селектор
	(др. названия: Селектор элемента/тега/типа), т.е. имя HTML-элемента в начале
	набора правил; <br>

<strong>set</strong> - определять, отображать и др.;<br>
<strong>set >> inner type sets the layout of children</strong> - внутренний тип (зд. отображения)
определяет расположение дочерних элементов;<br>




</strong> - универсальный селектор - * (in CSS) #wiki;<br>

</strong> - селектор идентификаторов, напр. #paragraph1 (in CSS) #wiki;<br>
</strong> - селектор атрибутов, напр. a[href="http://www.somesite.com"] (in CSS) #wiki;<br>
</strong> - селектор потомков (контекстный селектор), напр. div#paragraph1 p.note (in CSS) #wiki;<br>
</strong> - селектор псевдоклассов, напр. a:active (in CSS) #wiki;<br>
</strong> - селектор псевдоэлементов, напр. p::first-letter (in CSS) #wiki;<br>




<strong>scope</strong> - область видимости;<br>
<strong>scope >> block scope</strong> - блочная область видимости;<br>
<strong>scoped to the containing function</strong> - имеют областью видимости содержащую их функцию;<br>
<strong>screen readers</strong> - программы чтения с экрана;<br>
<strong>scripting</strong> - скриптинг, исполнение скриптов, использование скриптовых языков, напр. JavaScript;<br>
<strong>search form</strong> - форма поиска;<br>
<strong>sectioning</strong> - секционирование;<br>
<strong>sectioning content</strong> - секционный контент;<br>
<strong>sectioning root</strong> - секционный корень;<br>
<strong>self-contained content</strong> - самостоятельный контент;<br>
<strong>semi-opaque pixels</strong> - полупрозрачные пиксели;<br>
<strong>sensible structure</strong> - рациональная структура;<br>
<strong>sequential keyboard navigation,</strong> - последовательная навигация с клавиатуры;<br>
<strong>shopping cart widget</strong> - виджет корзины в интернет-магазине;<br>
<strong>siblings</strong> - соседние элементы;<br>
<strong>siblings >> adjacent siblings</strong> - то же, что и siblings выше;<br>
<strong>sidebar</strong> - <a href="https://developer.mozilla.org/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface/Sidebars">
	 боковая панель</a>;<br>
<strong>sitemap</strong> - карта сайта;<br>
<strong>slash </strong> - косая прямая, слеш, знак дроби "/";<br>
<strong>slash >> back slash, backward slash</strong> - обратный слеш;<br>
<strong>slash >> forward slash</strong> - прямой слеш, то же самое что "косая прямая";<br>
<strong>slug</strong> - дословно "слизняк", comp.: динамический идентификатор,
   одно или несколько слов в названии URL или файла в каталоге.
<small>Примеры: &lt;locale&gt;/docs/ или Glossary/Slug;</small><br>
<strong>snippet</strong> - фрагмент кода;<br>
<strong>sound HTML structure</strong> - осмысленная структурв HTML; <small>writing a sound
	 HTML structure = написание осмысленной структуры HTML</small>;<br>
<strong>space, space character</strong> - пробел;<br>
<strong>space >> single space</strong> - один пробел;<br>
<strong>spacing</strong> - расстояние, интервал, пробел;<br>
<strong>spacing > letter s.</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/letter-spacing">
	 межбуквенное расстояние</a> в тексте;<br>
<strong>spacing > word s. </strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/word-spacing">
   длина пробела</a> между словами и между тегами;<br>
<strong>spacing of the content</strong> - изменение интервалов контента;<br>
<strong>spaces >> End-of-line spaces</strong> - Пробелы в конце строки;<br>
<strong>specificity, CSS specificity</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Specificity">
	cпецифичность</a>;<br>
<strong>specify</strong> - указывать;<br>
<strong>specify >> not specified in the standard</strong> - не указаны в стандарте;<br>
<strong>spelling errors</strong> - орфографические ошибки;<br>
<strong>srсset</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/API/HTMLImageElement/srcset">
 свойство srсset</a>;<br>
<strong>statement</strong> - оператор;<br>
<strong>statement >> statement block</strong> - блок инструкций;<br>
<strong>statement >> empty statement</strong> - пустой оператор;<br>
<strong>statements >> multiple statements</strong> -  несколько операторов;<br>
<strong>streamed media</strong> - потоковое мультимедиа;<br>
<strong>string</strong> - строка;<br>
<strong>stroke</strong> - обводка; контур;<br>
<strong>stylesheet</strong> - стиль, таблица стилей;<br>
<strong>subdirectory</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/Dealing_with_files">
	поддиректория</a>;<br>
<strong>submenu</strong> also known as pop-up menus - подменю??? использовано впервые в уроке 9 строка 562;<br>
<strong>tab, tabs</strong> - табулятор, табуляция;<br>
<strong>tabular data</strong> - табличные данные;<br>
<strong>tag</strong> - тег;<br>
<strong>tag >> start tag, end tag</strong> - открывающий, закрывающий тег;<br>
<strong>tag >> tag omission	</strong> - пропуск тегов;<br>
<strong>target file</strong> - целевой файл;<br>
<strong>taxonomical designations</strong> - систематические обозначения;<br>
<strong>template</strong> - шаблон;<br>
<strong>textarea</strong> - элемент textarea;<br>
<strong>text that has stress emphasis</strong> - акцентируемый текст;<br>
<strong>textual replacement for the image</strong> - текстовое описание изображения;<br>
<strong>thematic break, i.e. between paragraph</strong> - тематическое разделение, напр. абзацев;<br>
<strong>top-level element</strong> - элемент верхнего уровня;<br>
<strong>track</strong> - 1) отслеживать 2) полоса, трек;<br>
<strong>track >> highlighted track</strong> - подсвеченная полоса (трек);<br>
<strong>track changes</strong> - отслеживание изменений;<br>
<strong>track size</strong> - размер полосы (или трека);<br>
<strong>trick</strong> - уловка;<br>
<strong>underlines</strong> - подчеркивания;<br>
<strong>underscore</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/Dealing_with_files">
	 нижнее подчеркивание</a>;<br>
<strong>Uniform Resource Locators (URL)</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL">
   Единый локатор ресурсов</a>;<br>
<strong>uniquely >> can be declared uniquely within the block</strong> - может быть объявлено
единожды внутри блока;<br>
<strong>unsupported type</strong> - неподдерживаемый тип;<br>
<strong>usage notes</strong> - примечание; использование;<br>
<strong>user agent</strong> - пользовательское приложение;<br>
<strong>user input</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/Forms/User_input_methods">
	 ввод пользователя</a>;<br>
<strong>validation</strong> - валидация;<br>
<strong>validation > constraint validation</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Constraint_validation">валидация ограничений
</a>;<br>
<strong>validation > client-side form validation</strong> - <a href="https://developer.mozilla.org/ru/docs/Learn/Forms/Form_validation">
	валидация форм на стороне клиента</a>;<br>
<strong>validity</strong> - валидность;<br>
<small> it does so only to ensure that those contents are valid = он делает это,
только чтобы убедиться в валидности содержимого</small>;<br>
<strong>value</strong> - значение, напр. 10px  (in CSS);<br>
<strong>value normal, bold, lighter*, bolder</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/font-weight#значения">
	значения начертаний шрифта</a>: нормальное, полужирное, сверхтонкое (тж. см. light),
	сверхжирное;<br>
<strong>value &lt;number></strong> - (в типографике) <a href="https://developer.mozilla.org/ru/docs/Web/CSS/font-weight">
	цифровые значения насыщенности шрифтов</a> [между 1 и 1000];<br>
<strong>value >> element's attribute values</strong> - значение аттибутов элемента;<br>
<strong>value >> values of its Text</strong> - содержимое (его) узла Text;<br>
<strong>variables introduced within a block</strong> - переменные, введённые внутри блока;<br>
<strong>visual media</strong> - визуальная среда;<br>
<small>to be represented in visual media as blocks of text = быть представленым в визуальной среде в виде блоков текста
</small>;<br>
<strong>viewport</strong> - область просмотра, видимая пользователю область веб-страницы,
	то, что может увидеть пользователь, не прибегая к прокрутке.;<br>
<strong><a href="https://developer.mozilla.org/ru/docs/Glossary/Viewport">
	 viewport</a> >> visual viewport</strong> - окно просмотра.
<small>
	 Окно просмотра это обычно прямоугольная область в компьютерной графике,
	 которая в настоящее время просматривается на экране в полноэкранном режиме.
</small>
<strong>visibility</strong> - свойство visibility скрывает или показывает элемент без изменения
разметки документа. Также скрывает строки и столбцы;<br>
<strong>void element</strong> - пустой элемент;<br>
<strong>web</strong> - веб;<br>
<mark><strong>WebVR</strong></mark> - веб виртуальная реальность;<br>
<strong>weight > exact w.</strong> - заданное цифровое значение насыщенности;<br>
<strong>weight > weight name</strong> - <a href="https://developer.mozilla.org/ru/docs/Web/CSS/font-weight#определение_веса_имени">
	вес имени</a>, вес насышенности. Также см. <a href="https://learn.microsoft.com/en-us/typography/opentype/spec/os2#usweightclass">
	usWeightClass</a>;<br>
<strong>weight > fallback weights</strong> - недоступность заданного значения;<br>
<strong>weight > relative w.</strong> - относительный вес;<br>
<strong>whitespace</strong> -  <a href="https://developer.mozilla.org/ru/docs/Glossary/Whitespace">
	пробельные символы</a>;<br>
<strong>white-space</strong> - свойство <a href="https://developer.mozilla.org/ru/docs/Web/CSS/white-space">
	white-space</a>;<br>
<strong>working draft</strong> - черновик #wiki;<br>
<strong>wrapper</strong> - обертка;<br>
<strong>wrapper >> class of wrapper</strong> - класс-обёртка;<br>
<strong>writing mode</strong> - режим письма;
</p>



<section id="chapter-next">
<a href="index.html"
class="chapter-next">
		 ОГЛАВЛЕНИЕ ></a>
</section>

<br><br>
</div>
</body>
</html>
