<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0' />
<title>8. FLEXBOX</title>
<!-- <link rel="stylesheet" href="../css/style.css"> -->
<link rel="stylesheet" href="style-iih.css">
</head>

<body>
<header>
<div class='index-header'>
<div id='index-header-titel'>
<h1>МУДРЕНЫЙ HTML&CSS</h1>
</div>
<div id='index-header-teaser'>
<p>
УРОК Nº 8.
</p>
</div>
<div id='index-header-undertitel'>
<p>
  Самый понятный учебник современной CSS-верстки
</p>
</div>
</div>

</div>
</header>
<h1><a href="/iih" title="RUS EDITION of Interneting is Hard">МУДРЕНЫЙ HTML&CSS</a></h1>
<h2>FLEXBOX</h2>
<p>УРОК Nº 8.</p>
<p><em>
    Самый понятный учебник современной CSS-верстки
</em></p>


<p>
    Режим макета Flexbox ["Гибкий блок"] предлагает альтернативу плавающим
		элементам <a href="iih07-floats.html">Floats</a> для создания общего вида
		веб-страницы.
		В то время как плавающие элементы позволяют нам только горизонтально
		располагать наши блоки, flexbox дает нам <em>полный</em> контроль над
		выравниванием, направлением, порядком и размером наших блоков.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-01-flexbox-layouts-7abd58.f93fcbe3.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 1: сравнение свойств выравнивания (alignment), направления (direction),
		порядка (order) и размера (size) flexbox
</small></figcaption>
</figure>
<p>
    В настоящее время веб переживает серьезные изменения, поэтому стоит немного
		поговорить о состоянии отрасли.
		В последнее десятилетие плавающие элементы Floats были единственным вариантом
		для создания сложной веб-страницы.
		В результате они хорошо поддерживаются даже в устаревших браузерах, а
		разработчики используют их для создания миллионов веб-страниц.
		Это означает, что вы неизбежно столкнетесь с плавающими элементами во время
		своей карьеры веб-разработчика (так что предыдущий урок не был пустой
		тратой времени).
</p><p>
    Изначально плавающие элементы предназначались для макетов в журнальном
		стиле (см. статью <a href="iih07-floats.html#floats-for-content">Floats для
		контента</a>).
		Несмотря на все изученное на прошлом уроке, виды макетов, создаваемых с помощью
		плавающих элементов, несколько ограничены.
		Даже простой макет боковой панели, с технической точки зрения, является
		немного хаком.
		Чтобы избавиться от этих ограничений, был изобретен Flexbox.
</p><p>
		Наконец-то мы достигли того момента, когда поддержка браузерами достигла
		критической массы и разработчики могут начать создавать полноценные сайты с
		использованием flexbox.
		Мы рекомендуем использовать flexbox для компоновки веб-страниц как можно чаще,
		оставляя плавающие элементы для тех случаев, когда вам нужно, чтобы поток
		страницы <em>обтекал</em> блок (например, при верстке в журнальном стиле),
		или для поддержки устаревших веб-браузеров.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-02-flexbox-vs-floats-418bf3.44fa853b.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 2: плавающие элементы Floats для обтекания текста вокруг блока
		("журнальная" структура) и Flexbox для остальной части макета (основная
		структура страницы)
</small></figcaption>
</figure>

<p>
    На этом уроке мы шаг за шагом рассмотрим всю модель макета flexbox.
		Вы научитесь создавать практически любой макет, который предложит
		веб-дизайнер.
</p>

<div class="title">подготовка<br>setup</div>
<p>
	Пример для этого урока относительно прост, но он наглядно демонстрирует все
	важные свойства flexbox.
	В итоге мы получим что-то похожее на это:
</p>

<figure>
<img class="pic-pages" src="./images/iih08-03-footer-flexible-items-static-widths-af0a32.2dfc1aff.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 3: веб-страница с макетом на основе flexbox
</small></figcaption>
</figure>

<p>
    Для начала нам нужен пустой HTML-документ, в котором нет ничего, кроме строки меню.
		Создайте новый <a href="iih01-intro.html#atom">Atom-проект</a> под названием
		flexbox, в котором будут храниться все файлы примеров для этого урока.
		Затем создайте файл flexbox.html и добавьте в него следующую разметку:
</p><p class="code">
	<span class="code-green">&lt;!DOCTYPE html&gt;</span><br>
&lt;html lang='en'&gt;<br>
&lt;head&gt;<br>
&lt;meta charset='UTF-8'/&gt;<br>
&lt;title&gt;Some Web Page&lt;/title&gt;<br>
&lt;link rel='stylesheet' href='styles.css'/&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
&lt;div class='menu-container'&gt;<br>
&lt;div class='menu'&gt;<br>

&lt;div class='date'&gt;Aug 14, 2016&lt;/div&gt;<br>
&lt;div class='signup'&gt;Sign Up&lt;/div&gt;<br>
&lt;div class='login'&gt;Login&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;
</p><p>
    Далее нужно создать таблицу стилей styles.css.
		Выглядеть это будет не очень презентабельно: просто синяя полоса меню во всю ширину
		с белым блоком в ней.
		Обратите внимание, что для центрирования меню мы будем использовать flexbox
		вместо уже привычной техники auto-margin.
</p><p class="code">
<span class="code-strong">*</span> {<br>
<span class="code-green">margin</span>: 0;<br>
<span class="code-green">padding</span>: 0;<br>
<span class="code-green">box-sizing</span>: border-box;<br>
}<br>
<br>
<span class="code-blue">.menu-container</span> {<br>
<span class="code-green">color</span>: #fff;<br>
<span class="code-green">background-color</span>: #5995DA;
<span class="code-grey">/* синий */</span>
<br>
<span class="code-green">padding</span>: 20px 0;<br>
}<br>
<br>
<span class="code-blue">.menu</span> {<br>
<span class="code-green">border</span>: 1px solid #fff;
<span class="code-grey">/* для отладки */</span><br>
<span class="code-green">width</span>: 900px;<br>
}
</p><p>
    Напоследок <a href="docs/iih08-flexbox-images-449705.zip">скачайте несколько
		изображений</a> для нашего примера веб-страницы.
		Распакуйте их в проект flexbox, сохранив родительский каталог images.
		Ваш проект должен выглядеть примерно так:
</p>

<figure>
<img class="pic-pages" src="./images/iih08-04-project-files-5cb6e0.e9e7714c.png"
width="30%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 4: скриншот файлов проекта
</small></figcaption>
</figure>

<div class="title">обзор<br>flexbox overview</div>
<p>
    Flexbox использует два типа блоков, которые мы никогда не видели раньше:
		"flex контейнеры" [flex containers] и "flex элементы" [flex items].
		Задача flex контейнера - сгруппировать несколько flex элементов и определить,
		как они будут располагаться.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-05-flex-container-and-flex-items-6234bb.7ffe361a.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 5: flex-контейнер в виде выделенного контейнера, обертывающего
		серые элементы, и flex-элементы в виде выделенных блоков внутри контейнера
</small></figcaption>
</figure>

<p>
    Каждый HTML-элемент, являющийся прямым дочерним элементом flex контейнера,
		представляет собой "элемент" [flex item].
		Flex элементами можно манипулировать по отдельности, но в основном их
		расположение определяет контейнер.
		Основная задача flex элементов - сообщить контейнеру, сколько элементов ему
		нужно расположить.
</p><p>
    Как и в случае с макетами на основе плавающих элементов [floats], создание
		сложных веб-страниц с помощью flexbox сводится к созданию вложенных блоков.
		Вы выравниваете кучу flex элементов внутри контейнера, и, в свою очередь,
		эти элементы могут служить flex контейнерами для своих собственных элементов.
		Работая с примерами этого урока, помните, что основная задача компоновки страницы
		не изменилась: мы по-прежнему просто перемещаем группу вложенных блоков.
</p>

<div class="title">флекс-контейнеры<br>flex containers</div>
<p>
    Первый шаг в использовании flexbox - превращение одного из наших HTML-элементов
		в flex-контейнер.
		Для этого мы используем свойство display, которое должно быть знакомо нам по
		уроку <a href="iih05-css-box-model.html#changing-box-behavior">Блочная модель в CSS</a>.
		Значение flex сообщает браузеру, что все в блоке должно отображаться
		с помощью flexbox, а не блоковой модели, как это делается по умолчанию.
</p><p>
    Добавьте следующую строку в наше правило .menu-container, чтобы превратить
		его в flex контейнер:
</p><p class="code">
<span class="code-blue">.menu-container</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">display</span>: flex;<br>
}
</p><p>
    Это <em>активирует</em> режим верстки flexbox - без него браузер будет
		игнорировать все свойства flexbox, которые мы сейчас рассмотрим.
		Явное определение flex-контейнеров означает, что вы можете смешивать и сочетать
		flexbox с другими моделями верстки (например, с плавающими элементами и всем
		тем, что мы будем изучать в разделе <a href="iih09-advanced-positioning.html">
		Продвинутое позиционирование</a>).
</p>

<figure>
<img class="pic-pages" src="./images/iih08-06-enabling-flexbox-dd3b59.cb39abcd.png"
width="40%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 6: смешивание и сочетание макета flexbox с блочными блоками и
		плавающими элементами
</small></figcaption>
</figure>

<p>
    Ура!
		У нас есть flex контейнер с одним flex элементом в нем.
		Однако наша страница будет выглядеть точно так же, как и раньше, потому что
		мы не указали контейнеру, как отображать его элемент.
</p>

<div class="title">Выравнивание элемента<br>aligning a flex item</div>
<p>
    После того как вы создали flex-контейнер, нужно задать горизонтальное
		выравнивание его элементов.
		Для этого предназначено свойство justify-content.
		Мы можем использовать его, чтобы выровнять по центру наше .menu, как
		показано ниже:
</p><p class="code">
<span class="code-blue">.menu-container</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;
<span class="code-grey">/* добавьте это */</span><br>
}
</p><p>
    Это имеет тот же эффект, что и добавление объявления margin: 0 auto к элементу .menu.
		Но обратите внимание, что мы добавили свойство к <em>родительскому</em> элементу
		(flex-контейнеру), а не непосредственно к элементу, который мы хотим выровнять
		по центру (flex-элементу).
		Управление элементами через их контейнеры является общей темой в flexbox,
		и это немного отличается от того, как мы позиционировали блоки до сих пор.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-07-flex-justify-content-alignment-ea129c.f7d754ab.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 7: flex-start (3 блока с выравниванием по левому краю), center
		(3 блока с выравниванием по центру), flex-end (3 блока с выравниванием по
		правому краю)
</small></figcaption>
</figure>

<p>
    Другие значения для justify-content показаны ниже:
</p><ul>
<li>center</li>
<li>flex-start</li>
<li>flex-end</li>
<li>space-around</li>
<li>space-between</li>
</ul><p>
    Попробуйте изменить justify-content на flex-start и flex-end.
		Это позволит выровнять меню по левой и правой стороне окна браузера соответственно.
		Не забудьте изменить его обратно на center, прежде чем двигаться дальше.
		Последние две опции полезны только когда в контейнере находятся несколько
		flex-элементов.
</p>

<div class="title">Распределение нескольких элементов<br>distributing multiple flex items</div>
<p>
    "Подумаешь! Мы уже умеем выравнивать влево/вправо с помощью плавающих элементов
		и центрировать с помощью auto-margins" - скажете вы.
		Верно.
		Но Flexbox не проявляет себя по-настоящему, пока в контейнере всего один элемент.
		Свойство justify-content также позволяет равномерно распределить элементы
		внутри контейнера.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-08-flex-justify-content-distribution-b0ee9c.3c71bf1f.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 8: space-around (3 блока с одинаковым пространством между ними и
		их контейнером), space-between (3 блока с пробелами между ними, но не между
		их контейнером)
</small></figcaption>
</figure>

<p>
    Измените наше правило .menu следующим образом:
</p><p class="code">
<span class="code-blue">.menu</span> {<br>
<span class="code-green">border</span>: 1px solid #fff;<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: space-around;<br>
}
</p><p>
    Это превращает наше .menu во вложенный flex контейнер, а значение space-around
		распределяет его элементы по всей ширине.
		Вы должны увидеть что-то вроде этого:
</p>

<figure>
<img class="pic-pages" src="./images/iih08-09-menu-bar-flex-space-around-e4b5a5.144eb729.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 9: веб-страница, на которой элементы &lt;li&gt; строки меню размещены
		с использованием пространства между ними
</small></figcaption>
</figure>

<p>
    Flex-контейнер автоматически распределяет дополнительное горизонтальное
		пространство по обе стороны от каждого элемента.
		Значение space-between аналогично, но оно только добавляет дополнительное
		пространство <em>между</em> элементами.
		Это именно то, что требуется для нашей страницы.
		Поэтому обновите строку justify-content:
</p><p class="code">
<span class="code-strong">justify-content</span>: space-between;
</p><p>
    Конечно, вы также можете использовать здесь center, flex-start, flex-end,
		если хотите сдвинуть все элементы в ту или иную сторону.
		Но давайте оставим значение space-between.
</p>

<div class="title" id="grouping-flex-items">группировка элементов<br>grouping flex items</div>
<p>
    Flex контейнеры умеют позиционировать только элементы, находящиеся уровнем
		ниже (то есть свои дочерние элементы).
		Их нисколько не волнует, что находится внутри тех flex элементов.
		Это означает, что группировка flex элементов - еще одно оружие в вашем арсенале
		для создания HTML-макета.
		Если обернуть множество элементов в дополнительный &lt;div&gt;, получится
		совершенно другая веб-страница.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-10-grouping-flex-items-1bb642.c1c54766.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 10: обертывание двух flex-элементов в &lt;div&gt; для устранения
		одного из flex-элементов
</small></figcaption>
</figure>

<p>
    Предположим, вы хотите, поместить ссылки <strong>Sign Up</strong>
		и <strong>Login</strong> в правую часть страницы (см. скриншот ниже).
		Для этого достаточно поместить их в другой &lt;div&gt;:
</p>

<p class="code">
&lt;div class='menu'&gt;<br>
&lt;div class='date'&gt;Aug 14, 2016&lt;/div&gt;<br>
&lt;div class='links'&gt;<br>
&lt;div class='signup'&gt;Sign Up&lt;/div&gt;
<span class="code-grey">&lt;!-- это вложено --&gt;</span><br>
&lt;div class='login'&gt;Login&lt;/div&gt;
<span class="code-grey">&lt;!-- и это вложено --&gt;</span><br>
&lt;/div&gt;<br>
&lt;/div&gt;<br>
</p><p>
    Вместо трех элементов в нашем flex-контейнере .menu теперь только два
		(.date и .links).
		В соответствии с существующим поведением пространства между ними, они будут
		привязаны к левой и правой стороне страницы.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-11-menu-bar-grouped-items-1-31c157.2b3287bf.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 11: веб-страница, c двумя полями меню, внутри контейнеров &lt;div&gt;
</small></figcaption>
</figure>

<p>
    Но теперь нам нужно разместить элемент .links, поскольку он использует
		стандартный режим блокового размещения.
		Решение: больше вложенных flex-контейнеров!
		Добавьте новое правило в наш файл styles.css, которое превратит элемент
		.links в flex-контейнер:
</p><p class="code">
<span class="code-blue">.links</span> {<br>
<span class="code-green">border</span>: 1px solid #fff;
<span class="code-grey">/* для отладки */</span><br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: flex-end;<br>
}<br>
<br>
<span class="code-blue">.login</span> {<br>
<span class="code-green">margin-left</span>: 20px;<br>
}
</p><p>
    Это позволит разместить наши ссылки именно там, где мы хотим.
		Обратите внимание, что поля по-прежнему работают так же, как и в <a href="iih05-css-box-model.html">
		блоковой модели CSS</a>.
		Как и в обычной блоковой модели, в flexbox особое значение имеют auto отступы
		(подробнее об этом  <a href="#flex-items-and-auto-margins">в конце урока</a>).
</p>

<figure>
<img class="pic-pages" src="./images/iih08-12-menu-bar-grouped-items-2-50cec0.7c36b832.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 12: поля меню, размещенные с помощью вложенных контейнеров flexbox
</small></figcaption>
</figure>

<p>
    Белые рамки нам больше не понадобятся.
		Можно их смело удалить.
</p>

<div class="title">выравнивание по оси (вертикальное)<br>cross-axis (vertical) alignment</div>
<p>
    До сих пор мы манипулировали горизонтальным выравниванием, но flex-контейнеры
		могут также определять вертикальное выравнивание своих элементов.
		Это то, что просто невозможно сделать с плавающими элементами.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-13-align-items-vs-justify-content-4d380e.ab784eaa.png"
width="55%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 13: justify-content (слева и справа), align-items (сверху и снизу)
</small></figcaption>
</figure>

<p>
    Чтобы изучить это, нам нужно добавить заголовок под нашим меню.
		Добавьте следующую разметку в файл flexbox.html после элемента .menu-container:
</p><p class="code">
&lt;div class='header-container'&gt;<br>
&lt;div class='header'&gt;<br>
&lt;div class='subscribe'&gt;Subscribe &#9662;&lt;/div&gt;<br>
&lt;div class='logo'&gt;&lt;img src='images/awesome-logo.svg'/&gt;&lt;/div&gt;<br>
&lt;div class='social'&gt;&lt;img src='images/social-icons.svg'/&gt;&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;
</p><p>
    Затем добавьте несколько базовых стилей, чтобы выровнять его по элементу .menu:
</p><p class="code">
<span class="code-blue">.header-container</span> {<br>
<span class="code-green">color</span>: #5995DA;<br>
<span class="code-green">background-color</span>: #D6E9FE;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;<br>
}<br>
<br>
<span class="code-blue">.header</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">height</span>: 300px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: space-between;<br>
}
</p><p>
    Все это должно быть знакомо, однако сценарий немного отличается от нашего меню.
		Так как .header имеет явную высоту, элементы могут быть расположены вертикально
		внутри него.
		В официальной спецификации это называется "выравнивание по оси" [cross-axis]
		- вскоре узнаете, почему. Но для наших целей это можно назвать "вертикальным"
		выравниванием.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-14-header-align-items-c53758.f10d1f7c.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 14: вертикальное выравниванием в контейнере заголовка с помощью
		свойства align-items
</small></figcaption>
</figure>

<p>
    Вертикальное выравнивание определяется добавлением свойства align-items
		к flex-контейнеру.
		Чтобы наша страница-пример соответствовала приведенному выше скриншоту,
		добавьте следующую строку:
</p><p class="code">
<span class="code-blue">.header</span> {<br>
/* ... */<br>
<span class="code-green">align-items</span>: center;
<span class="code-grey">/* добавьте это */</span><br>
}
</p><p>
    Варианты свойства align-items аналогичны justify-content:
</p><ul>
<li>center</li>
<li>flex-start (top)</li>
<li>flex-end (bottom)</li>
<li>stretch</li>
<li>baseline</li>
</ul>

<figure>
<img class="pic-pages" src="./images/iih08-15-flex-align-items-26abfd.9d4b350a.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 15: flex-start (блоки в верху контейнера), center (блоки в центре
		контейнера), flex-end (блоки в низу контейнера, stretch (блоки, заполняющие
		высоту контейнера)
</small></figcaption>
</figure>

<p>
    Большинство из вышеназванных вариантов довольно просты.
		С вариантом stretch стоит немного поэкспериментировать, потому что stretch
		позволяет отобразить фон каждого элемента.
		Давайте рассмотрим это ближе, добавив в файл styles.css следующее:
</p><p class="code">
.header {<br>
 /* ... */<br>
align-items: stretch;    /* Измените это */<br>
}<br>
<br>
.social,<br>
.logo,<br>
.subscribe {<br>
border: 1px solid <span class="code-green">#5995DA;</span><br>
}
</p><p>
    Блок для каждого элемента расширяется на всю высоту flex-контейнера,
		независимо от того, сколько контента он содержит.
		Чаще всего такое поведение используется для создания колонок одинаковой высоты
		с переменным количеством контента в каждой из них - что очень сложно сделать
		с плавающими элементами.
</p><p>
    Перед тем как двигаться дальше, обязательно удалите вышеуказанные изменения
		и вертикально отцентрируйте наш контент внутри .header.
</p>

<div class="title" id="wrapping-flex-items">обертывание элементов<br>wrapping flex items</div>
<p id="grid-01">
    Flexbox - это более мощная альтернатива <a href="iih07-floats.html#floats-for-grids">
		grid-сеткам на основе плавающих элементов</a>.
		Он может не только отображать элементы в виде сетки, но и изменять их выравнивание,
		направление, порядок и размер.
		Для создания сетки нам понадобится свойство flex-wrap.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-16-flex-wrap-b960c1.73a3247a.png"
width="55%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 16: без обертывания (блоки выходят за пределы контейнера), с
		обертыванием (блоки переходят на следующую строку в контейнере)
</small></figcaption>
</figure>

<p>
    Добавьте ряд фотографий в файл flexbox.html, чтобы нам было с чем работать.
		Поместите их внутрь &lt;body&gt;, под элементом .header-container:
</p><p class="code" id="grid-02">
&lt;div class='photo-grid-container'&gt;<br>
&lt;div class='photo-grid'&gt;<br>
&lt;div class='photo-grid-item first-item'&gt;<br>
&lt;img src='images/one.svg'/&gt;<br>
&lt;/div&gt;<br>
&lt;div class='photo-grid-item'&gt;<br>
&lt;img src='images/two.svg'/&gt;<br>
&lt;/div&gt;<br>
&lt;div class='photo-grid-item'&gt;<br>
&lt;img src='images/three.svg'/&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;
</p><p>
    Опять же, соответствующие CSS должны быть вам знакомы по предыдущим секциям:
</p><p class="code" id="grid-03">
<span class="code-blue">.photo-grid-container</span> {<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;<br>
}<br>
<br>
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: flex-start;<br>
}<br>
<br>
<span class="code-blue">.photo-grid-item</span> {<br>
<span class="code-green">border</span>: 1px solid #fff;<br>
<span class="code-green">width</span>: 300px;<br>
<span class="code-green">height</span>: 300px;<br>
}
</p><p id="grid-04">
    Все должно работать, как и ожидалось, но посмотрите, что произойдет,
		если мы добавим больше элементов, чем поместится в flex-контейнер.
		Вставьте две дополнительные фотографии в .photo-grid:
</p><p class="code" id="grid-05">
&lt;div class='photo-grid-item'&gt;<br>
&lt;img src='images/four.svg'/&gt;<br>
&lt;/div&gt;<br>
&lt;div class='photo-grid-item last-item'&gt;<br>
&lt;img src='images/five.svg'/&gt;<br>
&lt;/div&gt;
</p><p>
    По умолчанию они вытекают за край страницы:
</p>

<figure id="grid-06">
<img class="pic-pages" src="./images/iih08-17-grid-no-flex-wrap-66c396.5dd84e4f.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 17: веб-страница с неправильной версткой из-за отсутствия обертывания flexbox
</small></figcaption>
</figure>

<p>
    Такое вытекание за край еще можно оправдать, если вы пытаетесь создать баннер
		с горизонтальной прокруткой кучи фотографий, но это совсем, совсем не то,
		чего мы хотим.
		Мы хотим, чтобы не помещающиеся элементы смещались в следующий ряд.
		Для этого воспользуемся свойством flex-wrap:
</p><p class="code" id="grid-07">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">flex-wrap</span>: wrap;<br>
}
</p><p>
    Теперь наши flex-элементы ведут себя так же, как плавающие элементы, только
		flexbox дает нам больше контроля над тем, как "лишние" элементы выравниваются
		в последней строке с помощью свойства justify-content.
		Например, последняя строка сейчас выровнена по левому краю.
		Попробуйте выровнять ее по центру, обновив наше правило .photo-grid,
		например, так:
</p><p class="code" id="grid-08">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;
<span class="code-grey">/* Измените это */</span><br>
<span class="code-green">flex-wrap</span>: wrap;<br>
	}
</p><p>
    Добиться этого с макетами на основе плавающих элементов невероятно сложно.
</p>

<figure id="grid-09">
<img class="pic-pages" src="./images/iih08-18-grid-with-flex-wrap-1da4da.f85376b4.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 18: веб-страница, с корректной grid-сеткой, созданной с помощью
		правильного обертывания flexbox
</small></figcaption>
</figure>

<div class="title" id="flex-container-direction">направление контейнера<br>flex container direction</div>
<p>
    "Направление" означает, в каком направлении контейнер отображает свои элементы
		- горизонтально или вертикально.
		До сих пор все контейнеры, которые мы видели, использовали горизонтальное
		направление по умолчанию, что означает, что элементы рисуются один за другим
		в одной строке, а затем переходят в следующий столбец, когда заканчивается место.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-19-flex-direction-9acadf.b054ca57.png"
width="55%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 19: ряд (ROW - 3 горизонтальных блока), столбец (COLUMN - 3
		вертикальных блока)
</small></figcaption>
</figure>

<p id="grid-10">
    Одна из самых удивительных вещей в flexbox - его способность преобразовывать
		ряды в столбцы с помощью всего одной строки CSS.
		Попробуйте добавить следующее объявление flex-direction в наше правило .photo-grid:
</p><p class="code">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">flex-direction</span>: column;<br>
}
</p><p id="grid-11">
    Это изменит направление контейнера по сравнению со стандартным значением
		ряда [row value].
		Вместо сетки наша страница теперь имеет одну вертикальную колонку:
</p>

<figure>
<img class="pic-pages" src="./images/iih08-20-flex-direction-column-1bb8a0.209267d3.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 20: веб-страница с сеткой, превращенная в вертикальный столбец ячеек
</small></figcaption>
</figure>

<p>
    Ключевым условием адаптивного дизайна является одна HTML-разметка как для
		мобильных, так и ноутбуков/ПК.
		Небольшая проблема состоит в том, что большинство мобильных макетов имеют
		одну колонку, в то время как большинство макетов для ноутбуков/ПК располагают
		элементы горизонтально.
		Только представьте, насколько полезным станет flex-direction, когда мы начнем
		создавать <a href="iih10-responsive-design.html">адаптивные макеты</a>.
</p>

<div class="title-under">АСПЕКТЫ ВЫРАВНИВАНИЯ<br>alignment considerations</div>
<p>
    Обратите внимание, что колонка прижимается к левой стороне своего flex-контейнера,
		несмотря на наше объявление justify-content: center;.
		Когда вы меняете направление контейнера, вы также меняете направление свойства
		justify-content.
		Теперь оно относится к вертикальному выравниванию контейнера, а не к горизонтальному.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-21-flex-direction-axes-b30e85.d1bca75a.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 21: оси перевернуты, когда flex-direction равно column
</small></figcaption>
</figure>

<p id="grid-12">
    Чтобы горизонтально выровнять колонку, нам нужно задать свойство align-items
		для нашей .photo-grid:
</p><p class="code">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">flex-direction</span>: column;<br>
<span class="code-green">align-items</span>: center;
<span class="code-grey">/* Добавьте это */</span><br>
}
</p>

<div class="title">порядок контейнеров<br>flex container order</div>
<p>
    До сих пор существовала тесная взаимосвязь между порядком расположения HTML-элементов
		и тем, как блоки отображаются на веб-странице.
		С помощью плавающих элементов или техники flexbox, которую мы сейчас изучаем,
		единственный способ заставить блок отображаться перед или после
		другого блока - это перемещение по HTML-разметке.
		Однако скоро все изменится.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-22-flex-direction-reverse-532d8f.d1f2fbd3.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 22: ряд (ROW - слева направо), обратный ряд (ROW-REVERSE - справа
		налево), столбец (COLUMN - сверху вниз), обратный столбец (COLUMN-REVERSE - снизу вверх)
</small></figcaption>
</figure>

<p id="grid-13">
    Свойство flex-direction тоже позволяет контролировать порядок отображения
		элементов с помощью свойств row-reverse и column-reverse.
		Чтобы увидеть это в действии, преобразуем наш столбец обратно в сетку,
		но на этот раз мы изменим порядок отображения:
</p><p class="code">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-green">width</span>: 900px;<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: center;<br>
<span class="code-green"> flex-wrap</span>: wrap;<br>
<span class="code-green">flex-direction</span>: row-reverse;
<span class="code-grey">/* <--- Реально офигенно круто! */</span><br>
<span class="code-green">align-items</span>: center;<br>
}
</p><p>
    Теперь оба ряда отображаются справа налево, а не слева направо.
		Но обратите внимание, что порядок меняется только для каждой строки: первый
		ряд начинается не с 5, а с 3.
		Это полезное поведение для многих распространенных паттернов дизайна (в частности,
		обратный порядок колонок открывает много возможностей для мобильных макетов).
		В следующем разделе вы научитесь еще большей детализации.
</p>

<figure id="grid-14">
<img class="pic-pages" src="./images/iih08-23-grid-direction-row-reverse-78cc12.f79ada41.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 23: веб-страница, на которой строки сетки отображаются в обратном
		порядке (3, 2, 1 в первом ряду и 5, 4 во втором)
</small></figcaption>
</figure>

<p>
    Переупорядочивание элементов внутри таблицы стилей - это серьезное дело.
		До появления flexbox для этого приходилось прибегать к хакам JavaScript.
		Однако не стоит злоупотреблять своими новыми возможностями.
		Как уже говорилось в начале учебника, всегда следует <a href="iih02-basic-web-pages.html#structure-vs-presentation">
		отделять структуру от презентации</a>.
		Изменение порядка является чисто визуальным - ваш HTML должен быть
		понятен и без применения этих стилей.
</p>

<div class="title" id="flex-item-order">порядок элементов<br>flex item order</div>
<p>
    Весь этот урок до сего момента был посвящен позиционированию flex элементов
<em>через их родительские контейнеры</em>.
		Однако также существует возможность управлять отдельными элементами.
		В оставшейся части урока мы сместим фокус с flex контейнеров на элементы,
		которые в них содержатся.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-24-flex-direction-vs-order-021cee.7a3e129a.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 24: настройка порядка отдельных flex элементов через свойство order
</small></figcaption>
</figure>

<p>
    Добавление свойства order к flex элементу определяет его порядок в контейнере,
		не затрагивая окружающие элементы.
		По умолчанию его значение равно 0, а увеличение или уменьшение этого значения
		перемещает элемент вправо или влево соответственно.
</p><p id="grid-15">
    Это можно использовать, например, чтобы поменять местами порядок элементов
		.first-item и .last-item в нашей сетке.
		Мы также должны изменить значение row-reverse из предыдущего раздела обратно
		на row, потому что так будет немного легче распознать наши исправления:
</p><p class="code" id="grid-16">
<span class="code-blue">.photo-grid</span> {<br>
<span class="code-grey">/* ... */</span><br>
<span class="code-green">flex-direction</span>: row;
<span class="code-grey">/* Обновите это */</span><br>
<span class="code-green">align-items</span>: center;<br>
}<br>
<br>
<span class="code-blue">.first-item</span> {<br>
<span class="code-green">order</span>: 1;<br>
}<br>
<br>
<span class="code-blue">.last-item</span> {<br>
<span class="code-green">order</span>: -1;<br>
}
</p><p>
    В отличие от настроек row-reverse и column-reverse в flex контейнере, порядок
		действует вне границ рядов/колонок.
		Приведенный выше фрагмент поменяет местами первый и последний элементы, даже
		если они находятся в разных рядах.
</p>

<div class="title">выравнивание элементов<br>flex item alignment</div>
<p>
    То же самое мы можем сделать с вертикальным выравниванием.
		Что если мы хотим, чтобы ссылка "Подписаться" [<strong>Subscribe</strong>]
		и иконки соцсетей находились внизу заголовка, а не в центре?
		Выровняйте их по отдельности!
		Здесь на помощь приходит свойство align-self.
		Добавление этого свойства к элементу flex отменяет значение align-items из
		его контейнера:
</p><p class="code">
<span class="code-blue">.social</span><br>
<span class="code-blue">.subscribe</span> {<br>
<span class="code-green">align-self</span>: flex-end;<br>
<span class="code-green"> margin-bottom</span>: 20px;<br>
}
</p><p>
    Это должно отправить их в нижнюю часть .header.
		Обратите внимание, что и margin и padding действуют так, как от них ожидается.
</p>

<figure id="grid-17">
<img class="pic-pages" src="./images/iih08-25-grid-align-self-4302c2.85d0fc6c.png"
width="70%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 25: веб-страница, показывающая иконки, с помощью свойства align-self
		выровненные по нижнему краю [bottom-aligned]
</small></figcaption>
</figure>

<p>
    Элементы можно выравнивать и другими способами, используя те же значения,
		что и свойство align-items, перечисленные ниже для удобства.
</p><ul>
<li>center</li>
<li>flex-start (top)</li>
<li>flex-end (bottom)</li>
<li>stretch</li>
<li>baseline</li>
</ul>

<div class="title">гибкие элементы<br>flexible items</div>
<p>
    Все наши примеры были связаны с элементами с фиксированной шириной или определяемой
		контентом шириной.
		Это позволило нам сосредоточиться на аспектах позиционирования flexbox, но
		это также означает, что мы игнорировали природу "гибкого блока".
		Flex элементы являются <em>гибкими</em>: они могут сжиматься и растягиваться в
		соответствии с шириной своих контейнеров.
</p><p>
    Свойство flex определяет ширину отдельных элементов в flex контейнере.
		Точнее, оно позволяет им иметь гибкую ширину.
		Оно работает как некий коэффициент веса [weight], указывающий flex контейнеру,
		как распределить дополнительное пространство между элементами.
		Например, элемент со значением flex, равным 2, будет увеличиваться в два раза
		быстрее, чем элементы с стандартным значением, равным 1.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-26-flexible-items-cfe7a3.e3584961.png"
width="65%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 26: отсутствие flex (3 квадратных блока), равный flex (3 прямоугольных
		блока), неравный flex (2 меньших блока, один вытянутый)
</small></figcaption>
</figure>

<p>
    Для дальнейших экспериментов нам нужен футер.
		Вставьте его после элемента .photo-grid-container:
</p><p class="code">
&lt;div class='footer'&gt;<br>
&lt;div class='footer-item footer-one'&gt;&lt;/div&gt;<br>
&lt;div class='footer-item footer-two'&gt;&lt;/div&gt;<br>
&lt;div class='footer-item footer-three'&gt;&lt;/div&gt;<br>
&lt;/div&gt;<br>
</p><p>
    Затем, немного CSS:
</p><p class="code">
<span class="code-blue">.footer</span> {<br>
<span class="code-green">display</span>: flex;<br>
<span class="code-green">justify-content</span>: space-between;<br>
}<br>
<br>
<span class="code-blue">.footer-item</span> {<br>
<span class="code-green">border</span>: 1px solid #fff;<br>
<span class="code-green">background-color</span>: #D6E9FE;<br>
<span class="code-green">height</span>: 200px;<br>
<span class="code-green">flex</span>: 1;<br>
}
</p><p>
    Этот flex: 1; велит элементам растягиваться в соответствии с
		шириной .footer.
	  Поскольку все они имеют одинаковый вес [weight], они будут растягиваться
		одинаково:
</p>

<figure>
<img class="pic-pages" src="./images/iih08-27-footer-flexible-items-220ac8.02046562.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 27: три одинаковых голубых блока, растянутые по всей ширине футера
</small></figcaption>
</figure>

<p>
    Если увеличить вес одного из элементов, он будет расти быстрее остальных.
		Например, мы можем заставить третий элемент расти в два раза быстрее, чем
		два других, с помощью следующего правила:
</p><p class="code">
<span class="code-blue">.footer-three</span> {<br>
<span class="code-green">flex</span>: 2;<br>
}
</p><p>
    Сравните это со свойством justify-content, которое распределяет дополнительное
		пространство <em>между</em> элементами.
		Это выглядит похоже, но теперь мы распределяем это пространство в самих элементах.
		В результате мы полностью контролируем размещение гибких элементов в своих
		контейнерах.
</p>

<div class="title-under">ЭЛЕМЕНТЫ ФИКСИРОВАННОЙ ШИРИНЫ<br>static item widths</div>
<p>
    Мы даже можем сочетать гибкие блоки с блоками фиксированной ширины.
		В flex: initial происходит возврат к конкретному свойству ширины элемента.
		Это позволяет нам по-разному комбинировать статические и гибкие блоки.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-28-combining-flexible-and-static-items-52aacb.64fa3f5b.png"
width="60%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 28: блок фиксированной ширины (flex: initial), гибкий блок (flex: 1)
</small></figcaption>
</figure>

<p>
    Мы хотим, чтобы наш футер вел себя так, как на скриншоте выше.
		Гибкий блок в центре, а те, что по обе стороны, фиксированной ширины.
		Все, что для этого нужно сделать - добавить следующее правило в нашу таблицу
		стилей:
</p><p class="code">
<span class="code-blue">.footer-one</span><br>
<span class="code-blue">.footer-three</span> {<br>
<span class="code-green">background-color</span>: #5995DA;<br>
<span class="code-green">flex</span>: initial;<br>
<span class="code-green">width</span>: 300px;<br>
}
</p><p>
    Без этого flex: initial; объявление flex: 1; было бы унаследовано от правила
		.footer-item, в результате чего свойства ширины игнорировались бы.
    initial исправляет это, и мы получаем гибкий макет, который также содержит
		элементы фиксированной ширины.
		Измененяя размер окна браузера, мы увидим, что в футере изменяется только
		размер среднего блока.
</p>

<figure>
<img class="pic-pages" src="./images/iih08-29-footer-flexible-items-static-widths-af0a32.2dfc1aff.png"
width="50%" alt="Interneting is hard HTML+CSS">
<figcaption><small>
    Скриншот 29: два блока фиксированной ширины по обе стороны
		от гибкого блока. Все три полностью заполняют весь футер.
</small></figcaption>
</figure>

<p>
    Это довольно распространенная компоновка, и не только в футерах.
		Например, на многих сайтах есть боковая панель фиксированной ширины (или
		несколько боковых панелей) и гибкий блок контента, содержащий основной текст
		страницы.
		По сути, это более насыщенная версия футера, который мы только что создали.
</p>

<div class="title" id="flex-items-and-auto-margins">элементы и отступы<br>
    flex items and auto-margins</div>
<p>
    Auto отступы [auto-margins] в flexbox - это нечто особенное.
		Они могут использоваться как альтернатива <a href="#grouping-flex-items">
		дополнительному &lt;div&gt;</a> при попытке выровнять группу элементов по
		левому/правому краю контейнера.
		Воспринимайте auto-margin как "разделитель" для flex элементов в одном контейнере.
</p><p>
    Давайте посмотрим, как выровнять наши элементы в .menu, чтобы получилось следующее:
</p><p class="code">
&lt;div class='menu-container'&gt;<br>
&lt;div class='menu'&gt;<br>
&lt;div class='date'&gt;Aug 14, 2016&lt;/div&gt;<br>
&lt;div class='signup'&gt;Sign Up&lt;/div&gt;<br>
&lt;div class='login'&gt;Login&lt;/div&gt;<br>
&lt;/div&gt;<br>
&lt;/div&gt;
</p><p>
    При перезагрузке страницы пункты должны равномерно распределиться по нашему
		меню, как в начале главы.
		Мы можем воспроизвести желаемый макет, вставив auto-margin между пунктами,
		которые мы хотим отделить, как показано ниже:
</p><p class="code">
<span class="code-blue">.signup</span> {<br>
<span class="code-green">margin-left</span>: auto;<br>
}
</p><p>
    auto-margin съедает <em>все</em> лишнее пространство в flex-контейнере,
		поэтому вместо равномерного распределения элементов, мы перемещаем .signup
		и все следующие элементы (.login) в правую часть контейнера.
		Получится точно такой же макет, как и раньше, но без лишнего вложенного &lt;div&gt;
		для группировки.
		Иногда приятнее оставить HTML более простым.
</p>


<div class="title">резюме</div>
<p>
    Flexbox дал нам тонну потрясающих новых инструментов для верстки веб-страниц.
		Сравните эти приемы с тем, что мы могли сделать с <a href="iih07-floats.html">
		float элементами</a>, и станет ясно, что flexbox - это более совершенный способ
		компоновки современных веб-сайтов:
</p><ul>
<li>Используйте display: flex; для создания flex-контейнера.</li>
<li>Используйте justify-content, чтобы задать горизонтальное выравнивание элементов.</li>
<li>Используйте align-items, чтобы задать вертикальное выравнивание элементов.</li>
<li>Используйте flex-direction, если вам нужны столбцы, а не ряды.</li>
<li>Используйте значения row-reverse или column-reverse, чтобы изменить порядок элементов.</li>
<li>Используйте order, чтобы настроить порядок отдельных элементов.</li>
<li>Используйте align-self, чтобы выровнять отдельные элементы по вертикали.</li>
<li>Используйте flex для создания гибких блоков, которые могут растягиваться и сжиматься.</li>
</ul><p>
    Помните, что эти свойства flexbox - всего лишь язык, позволяющий указывать
		браузерам, как расположить множество HTML-элементов.
		Самое сложное - это не написание HTML- и CSS-кода, а концептуальное (на листе
		бумаги) определение поведения всех необходимых блоков для создания желаемого
		макета.
</p><p>
    Когда дизайнер передает вам эскиз для воплощения, ваша первая задача - нарисовать
		на нем кучу блоков и определить, как они должны складываться, растягиваться и
		сжиматься, чтобы добиться желаемого дизайна.
		Как только вы это сделаете, вам будет довольно легко создать код, используя
		новые техники flexbox.
</p><p>
    Режим верстки flexbox должен использоваться для большинства ваших веб-страниц,
		но есть некоторые вещи, с которыми он не очень хорошо справляется, например,
		мягкая настройка положения элементов и предотвращение их взаимодействия с
		остальной частью страницы.
		После того как на следующем уроке мы рассмотрим эти виды продвинутых техник
		позиционирования, вы станете экспертом по позиционированию в HTML и CSS.
</p>

<section id="chapter-next">
<a href="/iih09-advanced-positioning.html"
class="chapter-next">
    СЛЕДУЮЩИЙ УРОК ></a>
</section>
<br><br>
</div>
</body>
</html>
